use Collection;
use System.IO.Filesystem;

class StreamParser {
	@input : InputStream;

	@stream : Char[];
	@stream_position : Int;
	@cur_char : Char;

	@level : Int;
	@skip_next : Bool;

	@is_delim : Bool;
	@type : StreamParser->Type;
	@value : String;

	enum Type {
		OBJECT_START,
		OBJECT_END,
		ARRAY_START,
		ARRAY_END,
		LABEL,
		STRING,
		NUMBER,
		NULL,
		TRUE,
		FALSE
	}

	New(input : InputStream) {
		@input := input;

		stream_str := @input->ReadLine();
		if(stream_str <> Nil) {
			@stream := stream_str->ToCharArray();
			@stream_position := 0;

			@cur_char := @stream[@stream_position];
		}
		else {
			@cur_char := '\0';
		};
	}

	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 1) {
			stream := FileReader->New(args[0]);
			
			parser := StreamParser->New(stream);
			while(parser->More()) {
				type_name := parser->GetTypeName();
				type_value := parser->GetTypeValue();
				level := parser->GetLevel();

				if(level = 2 & parser->GetType() <> StreamParser->Type->OBJECT_START) {
					"{$level}: {$type_name} => '{$type_value}'"->PrintLine();
					"---"->PrintLine();
				};

				parser->Next();
			};
		}
		else {
			">>> usage: filename <<<"->ErrorLine();
		};
	}

	method : Get() ~ Nil {
		string_buffer : String;
		num_buffer : String;		

		while(@cur_char <> '\0' & <>@is_delim & @level > -1) {
			Whitespace();

			if(@cur_char = '{' ) {
				@type := StreamParser->Type->OBJECT_START;
				@level += 1;
				@is_delim := true;
			}
			else if(@cur_char = '[') {
				@type := StreamParser->Type->ARRAY_START;
				@level += 1;
				@is_delim := true;				
			}
			else if(@cur_char = '}' ) {
				if(num_buffer <> Nil) {
					@type := StreamParser->Type->NUMBER;
					@value := String->New(num_buffer);
					num_buffer := Nil;
					@is_delim := true;		

					@skip_next := true;
				}
				else {
					@level -= 1;
					@type := StreamParser->Type->OBJECT_END;
					@is_delim := true;
				};
			}
			else if(@cur_char = ']') {
				if(num_buffer <> Nil) {
					@type := StreamParser->Type->NUMBER;
					@value := String->New(num_buffer);
					num_buffer := Nil;
					@is_delim := true;		

					@skip_next := true;
				}
				else {
					@level -= 1;
					@type := StreamParser->Type->ARRAY_END;
					@is_delim := true;
				};
			}	
			else if(@cur_char = '"') {
				if(string_buffer = Nil) {
					string_buffer := String->New();

					NextChar();
					while(@cur_char <> '"') {
						string_buffer->Append(@cur_char);
						NextChar();
					};
					NextChar();
					
					@skip_next := true;
					Whitespace();

					if(@cur_char = ':') {
						@type := StreamParser->Type->LABEL;
						@is_delim := true;
					}
					else {
						@type := StreamParser->Type->STRING;
						@is_delim := true;
					};
					@value := String->New(string_buffer);

					string_buffer := Nil;
				};
			}
			else if(@cur_char->IsDigit() | (num_buffer <> Nil & @cur_char = '.')) {
				if(string_buffer = Nil) {
					if(num_buffer = Nil) {
						num_buffer := String->New();
					}
					num_buffer->Append(@cur_char);
				}
				else {
					string_buffer->Append(@cur_char);
				};
			}
			else if(string_buffer = Nil & num_buffer = Nil) {
				if(@cur_char = 'n') {
					if(<>Match("null")) {
						SetError("expected 'null'")
					}
					else {						
						@type := StreamParser->Type->NULL;
						@is_delim := true;
					};
				}
				else if(@cur_char = 't') {
					if(<>Match("true")) {
						SetError("expected 'true'")
					}
					else {						
						@type := StreamParser->Type->TRUE;
						@is_delim := true;
					};
				}
				else if(@cur_char = 'f') {
					if(<>Match("false")) {
						SetError("expected 'false'")
					}
					else {						
						@type := StreamParser->Type->FALSE;
						@is_delim := true;
					};
				}
				else {
					if(@cur_char <> ',' & @cur_char <> ':') {
						SetError("expected : [':' or ',' or '\"']")
					};	
				};	
			}
			else {
				if(num_buffer <> Nil) {
					@type := StreamParser->Type->NUMBER;
					@value := String->New(num_buffer);
					num_buffer := Nil;
					@is_delim := true;				
				};
			};
			
			if(@skip_next) {
				@skip_next := false;
			}
			else {
				NextChar();
			};
		};
	}

	method : public : GetType() ~ StreamParser->Type {
		return @type;
	}

	method : public : GetTypeName() ~ String {
		select(@type) {
			label StreamParser->Type->OBJECT_START {
				return "(+) object-start";
			}

			label StreamParser->Type->OBJECT_END {
				return "(-) object-end";
			}
			
			label StreamParser->Type->ARRAY_START {
				return "(+) array-start";
			}

			label StreamParser->Type->ARRAY_END {
				return "(+) array-end";
			}

			label StreamParser->Type->LABEL {
				return "label";
			}

			label StreamParser->Type->STRING {
				return "string";
			}

			label StreamParser->Type->NUMBER {
				return "number";
			}

			label StreamParser->Type->NULL {
				return "null";
			}

			label StreamParser->Type->TRUE {
				return "true";
			}

			label StreamParser->Type->FALSE {
				return "false";
			}
		};

		return ">>> unknown <<<";
	}

	method : public : GetTypeValue() ~ String {
		select(@type) {
			label StreamParser->Type->OBJECT_START {
				return "{";
			}

			label StreamParser->Type->OBJECT_END {
				return "}";
			}
			
			label StreamParser->Type->ARRAY_START {
				return "[";
			}

			label StreamParser->Type->ARRAY_END {
				return "]";
			}

			label StreamParser->Type->LABEL
			label StreamParser->Type->STRING
			label StreamParser->Type->NUMBER {
				return @value;
			}
 
			label StreamParser->Type->NULL {
				return "null";
			}

			label StreamParser->Type->TRUE {
				return "true";
			}

			label StreamParser->Type->FALSE {
				return "false";
			}
		};

		return "";
	}

	method : public : GetLevel() ~ Int {
		return @level;
	}

	method : public : InLevel(level : Int) ~ Bool {
		return @level = level & @type <> StreamParser->Type->OBJECT_END & @type <> StreamParser->Type->ARRAY_END;
	}

	method : public : Next() ~ Nil {
		@is_delim := false;
	}

	method : public : More() ~ Bool {
		if(@cur_char = '\0') {
			return false;
		};

		Get();
		return true;
	}

	method : SetError(message : String) ~ Nil {
		">>> {$message} <<<"->PrintLine();
		@cur_char := '\0';
		@skip_next := true;
	}

	method : native : Whitespace() ~ Nil {
		while(@cur_char = ' ' | @cur_char = '\t' | @cur_char = '\r' | @cur_char = '\n') {
			NextChar();
		};
	}

	method : native : NextChar() ~ Nil {
		if(@stream_position < @stream->Size()) {
			@cur_char := @stream[@stream_position];
		}
		else {
			stream_str := @input->ReadLine();
			if(stream_str <> Nil) {
				@stream := stream_str->ToCharArray();
				@stream_position := 0;

				@cur_char := @stream[@stream_position];
			}
			else {
				@cur_char := '\0';
			};
		};

		@stream_position += 1;
	}

	method : native : Match(string : String) ~ Bool {
		each(c in string) {
			if(c <> @cur_char) {
				return false;
			};
			NextChar();
		};

		return true;
	}
}