# A class for Min Heap  
class MinHeap { 
      
    # To store array of elements in heap 
    heapArray : Int[];
    capacity : Int;
    current_heap_size : Int;
    
    # Constructor  
    New(n : Int) { 
        capacity := n; 
        heapArray := Int->New[capacity]; 
        current_heap_size := 0; 
    } 
      
    # Swapping using reference  
    method : swap(arr : Int[], a : Int, b : Int) ~ Nil { 
        temp := arr[a]; 
        arr[a] := arr[b]; 
        arr[b] := temp; 
    } 
      
      
    # Get the Parent index for the given index 
    method : parent(key : Int) ~ Int { 
        return (key - 1) / 2; 
    } 
      
    # Get the Left Child index for the given index 
    method : left(key : Int) ~ Int { 
        return 2 * key + 1; 
    } 
      
    # Get the Right Child index for the given index 
    method : right(key : Int) ~ Int { 
        return 2 * key + 2; 
    } 

    # Inserts a new key 
    method : public : insertKey(key : Int) ~ Bool { 
        if (current_heap_size = capacity) { 
              
            # heap is full 
            return false; 
        } 
      
        # First insert the new key at the end  
        i := current_heap_size; 
        heapArray[i] := key; 
        current_heap_size++; 
          
        # Fix the min heap property if it is violated  
        while (i <> 0 & heapArray[i] < heapArray[parent(i)]) { 
            swap(heapArray, i, parent(i)); 
            i := parent(i); 
        } 
        return true; 
    } 
      
    # Decreases value of given key to new_val.  
    # It is assumed that new_val is smaller  
    # than heapArray[key].  
    method : decreaseKey(key : Int, new_val : Int) ~ Nil { 
        heapArray[key] := new_val; 
  
        while (key <> 0 & heapArray[key] < heapArray[parent(key)]) { 
            swap(heapArray, key, parent(key)); 
            key := parent(key); 
        } 
    } 
      
    # Returns the minimum key (key at 
    # root) from min heap  
    method : getMin() ~ Int { 
        return heapArray[0]; 
    } 
      
      
    # Method to remove minimum element  
    # (or root) from min heap  
    method : public : extractMin() ~ Int { 
        if (current_heap_size <= 0) { 
            return Int->MaxSize(); 
        } 
  
        if (current_heap_size = 1) { 
            current_heap_size--; 
            return heapArray[0]; 
        } 
          
        # Store the minimum value,  
        # and remove it from heap  
        root := heapArray[0]; 
  
        heapArray[0] := heapArray[current_heap_size - 1]; 
        current_heap_size--; 
        MinHeapify(0); 
  
        return root; 
    } 
          
    # This function deletes key at the  
    # given index. It first reduced value  
    # to minus infinite, then calls extractMin() 
    method : public : deleteKey(key : Int) ~ Nil { 
        decreaseKey(key, Int->MinSize()); 
        extractMin(); 
    } 
      
    # A recursive method to heapify a subtree  
    # with the root at given index  
    # This method assumes that the subtrees 
    # are already heapified 
    method : MinHeapify(key : Int) ~ Nil { 
        l := left(key); 
        r := right(key); 
  
        smallest := key; 
        if (l < current_heap_size & heapArray[l] < heapArray[smallest]) { 
            smallest := l; 
        } 
        if (r < current_heap_size & heapArray[r] < heapArray[smallest]) { 
            smallest := r; 
        } 
  
        if (smallest <> key) { 
            swap(heapArray, key, smallest); 
            MinHeapify(smallest); 
        } 
    } 
      
    # Increases value of given key to new_val. 
    # It is assumed that new_val is greater  
    # than heapArray[key].  
    # Heapify from the given key 
    method : increaseKey(key : Int, new_val : Int) ~ Nil { 
        heapArray[key] := new_val; 
        MinHeapify(key); 
    } 
      
    # Changes value on a key 
    method : changeValueOnAKey(key : Int, new_val : Int) ~ Nil { 
        if (heapArray[key] = new_val) { 
            return; 
        } 
        if (heapArray[key] < new_val) { 
            increaseKey(key, new_val); 
        } else { 
            decreaseKey(key, new_val); 
        } 
    } 
} 
  
# Driver Code 
class MinHeapTest { 
    function : Main(args : String[]) ~ Nil {
        h := MinHeap->New(11); 
        h->insertKey(13); 
        h->insertKey(2); 
        h->insertKey(1); 
        h->insertKey(5); 
        h->insertKey(3);  
        
        Standard->Print(h->extractMin())->PrintLine(); 
        Standard->Print(h->extractMin())->PrintLine(); 
        Standard->Print(h->extractMin())->PrintLine(); 
        Standard->Print(h->extractMin())->PrintLine(); 
        Standard->Print(h->extractMin())->PrintLine(); 
    } 
} 