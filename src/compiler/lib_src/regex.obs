#~
RegEx engine for Objeck.
operations: 
'.' - any 1
'?' - 0 or 1
'*' - 0 or more
'+' - 1 or more
'|' - or
'()' - grouping

Copyright (c) 2012 Randy Hollines
Copyright (c) 2004 Jan Burgy.
Can be distributed under the MIT license, see bottom of file.
~#

use IO;
use Struct;

bundle RegEx {
	enum Token := -16 {
		LPRN,
		RPRN,
		CONCAT,
		KLEENE,
		ALTERN,
		OPTION
	}
	
	enum Operand := -32 {
		STOP,
		JUMP,
		MATCH,
		NOT_MATCH,
		MATCH_RANGE,
		BRANCH
	}
	
	class Instr {
		@operand : Operand;
		@address : Int;
		
		New(operand : Operand, address : Int) {
			@operand := operand;
			@address := address;
		}

		method : public : GetOperand() ~ Operand {
			return @operand;
		} 
		
		method : public : GetAddress() ~ Int {
			return @address;
		} 
	}
	
	class RegEx {
		@pattern : String;
		@string : String;
		@instrs : Instr[];
		@max_size : Int;
		@error : Bool;
		@start : Int;
		@end : Int;
		# TODO: use IntHash...
		@ranges : IntMap; 
		
		New(pattern : String) {
			@pattern := pattern;
			@max_size := 256;
			@error := false;
			@instrs := Nil;
			@start := -1;
			@end := -1;
			@ranges := IntMap->New(); 
			
			prep := Prepare();
# DumpSrc(prep);
			if(@error = false) {
				src := Convert(prep);
# DumpSrc(src);
				@instrs := Compile(src);
DumpInstrs(@instrs);
			};
		}
		
		method : Prepare() ~ Int[] {
			prep := Int->New[@max_size];
			index := 0;
			prn_count := 0;
			concat := false;
			range_offset := -64;
			
			each(i : @pattern) {
				c := @pattern->Get(i);
				
				if(c = '\\' & i + 1 < @pattern->Size()) {
					select(@pattern->Get(i + 1)) {
						label 'r': {
							i += 1;
							c := '\r';
						}
		
						label 'n': {
							i += 1;
							c := '\n';
						}

						label 't': {
							i += 1;
							c := '\t';
						}
						
						label 'a': {
							i += 1;
							c := '\a';
						}

						label 'b': {
							i += 1;
							c := '\b';
						}
					};
				};
				
				select(c) {
					label '[': {
						if(concat) {
							prep[index] := Token->CONCAT;
							index += 1;
						};
						
						# parse characters
						
						is_range := false;
						i += 1;
						c := @pattern->Get(i);
						start := i;
						while((c->IsChar() | c->IsDigit() | c = '-') & i < @pattern->Size()) {
							if(c = '-') {
								if(is_range) {
									"invalid character class"->PrintLine();
									@error := true;
									return Nil;
								};
								is_range := true;
							};
							
							# update
							i += 1;
							c := @pattern->Get(i);
						};
						end := i;
						
						if(start = end) {
							"invalid character class"->PrintLine();
							@error := true;
							return Nil;
						};
						
						# map range
						range := @pattern->SubString(start, end - start);
						if(is_range) {
							if(range->Size() = 3 & range->Get(1) = '-') {
								range_start := range->Get(0);
								range_end := range->Get(2);
								if(range_start >= range_end) {
									"invalid character class"->PrintLine();
									@error := true;
									return Nil;
								};
								
# Console->Print("range: ")->Print(range_start->As(Int))->Print(", ")->PrintLine(range_end->As(Int));
								
								prep[index] := range_offset;
								index += 1;
								
								@ranges->Insert(range_offset, range->As(Base));
								range_offset -= 1;
							}
							else {
								"invalid character class"->PrintLine();
								@error := true;
								return Nil;
							};
# Console->Print("class range=")->PrintLine(range);
						}
						# add elements
						else {
# Console->Print("class element(s)=")->PrintLine(range);	
							
							prep[index] := Token->LPRN;
							index += 1;
							each(j : range) {
								prep[index] := range->Get(j);
								index += 1;
								if(j + 1 < range->Size()) {
									prep[index] := Token->ALTERN;
									index += 1;
								};
							};
							prep[index] := Token->RPRN;
							index += 1;
						};
						
						# finish
						if(c <> ']') {
							"invalid character class"->PrintLine();
							@error := true;
							return Nil;
						};
						concat := true;
					}
					
					label '(': {
						prep[index] := Token->LPRN;
						index += 1;
						prn_count += 1;
						concat := false;
					}
					
					label ')': {
						prep[index] := Token->RPRN;
						index += 1;
						prn_count -= 1;
						concat := true;
					}
					
					label '*': {
						prep[index] := Token->KLEENE;
						index += 1;
						concat := true;
					}
					
					label '?': {
						prep[index] := Token->OPTION;
						index += 1;
						concat := true;
					}
					
					label '+': {
						if(i - 1 > -1) {
							prep[index] := @pattern->Get(i - 1);
							index += 1;
						}
						else {
							"invalid operation"->PrintLine();
							@error := true;
							return Nil;
						};
						
						prep[index] := Token->KLEENE;
						index += 1;
						concat := true;
					}
					
					label '|': {
						prep[index] := Token->ALTERN;
						index += 1;
						concat := false;
					}
					
					other: {
						if(concat) {
							prep[index] := Token->CONCAT;
							index += 1;
						};
						prep[index] := c;
						index += 1;
						concat := true;
					}
				};
			};
			prep[index] := Token->RPRN;
			index += 1;
			prep[index] := 0;
			
			if(prn_count <> 0) {
				"unbalanced parentheses"->PrintLine();
				@error := true;
				return Nil;
			};
			
			return prep;
		}
			
		method : Convert(prep : Int[]) ~ Int[] {
			postfix := Int->New[prep->Size()];			
			i := 0;
			t := prep[i];
			
			stack := Int->New[@max_size];
			top := 0; 
			j := 0; 
			
			stack[top] := Token->LPRN;
			top += 1;
			while(t <> 0) {
				select(t) {
					label Token->LPRN: {
						stack[top] := t;
						top += 1;
					}
					
					label Token->RPRN: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						top -= 1;
					}
					
					label Token->ALTERN:
					label Token->CONCAT: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						stack[top] := t;
						top += 1;
					}
					
					label Token->KLEENE:
					label Token->OPTION: {
						while(t <= stack[top - 1]) {
							top -= 1;
							postfix[j] := stack[top];
							j += 1;
						};
						postfix[j] := t;
						j += 1;
					}
					
					other: {
						if(stack[top - 1] = Token->CONCAT->As(Int)) {
							top -= 1;
							postfix[j] := Token->CONCAT;
							j += 1;
						};	
						postfix[j] := t;
						j += 1;
					}
				};
				i += 1;
				t := prep[i];
			};
			postfix[j] := 0;
			
			return postfix;
		}
		
		method : Compile(src : Int[]) ~ Instr[] {
			pc := 0;
			top := 0;
			stack := Int->New[@max_size];
			code := Instr->New[src->Size() * 5];

			i := 0;
			s := src[i];
			while(s <> 0) {
				select(s) {
					label Token->CONCAT: {
						top -= 1;
					}
					
					label Token->KLEENE: {
						code[pc] := Instr->New(Operand->BRANCH, '*'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;

						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc - 2);
					}
					
					label Token->OPTION: {
						code[pc] := Instr->New(Operand->JUMP, pc + 3);
						pc += 1;
					
						code[pc] := Instr->New(Operand->BRANCH, '?'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;

						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc - 2);
					}
			
					label Token->ALTERN: {
						code[pc] := Instr->New(Operand->JUMP, pc + 4);
						pc += 1;
						
						code[pc] := Instr->New(Operand->BRANCH, '|'->As(Int));
						pc += 1;
						
						code[pc] := code[stack[top - 1]];
						pc += 1;
						
						code[pc] := code[stack[top - 2]];
						pc += 1;
						
						code[stack[top - 2]] := Instr->New(Operand->JUMP, pc - 3);
						code[stack[top - 1]] := Instr->New(Operand->JUMP, pc);
						top -= 1;
					}
					
					other: {
						stack[top] := pc;
						top += 1;

						code[pc] := Instr->New(Operand->JUMP, pc + 1);
						pc += 1;
						
						if(s <= -64) {
							code[pc] := Instr->New(Operand->MATCH_RANGE, s);
							pc += 1;
						}
						else if(s = '.') {
							code[pc] := Instr->New(Operand->NOT_MATCH, src[i + 3]);
							pc += 1;
						}
						else {
							code[pc] := Instr->New(Operand->MATCH, s);
							pc += 1;
						};
					}
				};
				i += 1;
				s := src[i];		
			};
			code[pc] := Instr->New(Operand->STOP, pc);
			pc += 1;
			
			return code;
		}
		
		method : native : Execute(instrs : Instr[], string : String, offset : Int) ~ Bool {
			top := 0;
			stack := Int->New[@max_size];
			i := offset;
			pc := 0;
						
			do {
				instr := instrs[pc];
				select(instr->GetOperand()) {
					label Operand->STOP: {
# Console->Print(pc)->PrintLine(": STOP");
						@end := i;
						return true;
					}
					
					label Operand->JUMP: {
# Console->Print(pc)->Print(": JUMP, addr=")->PrintLine(instr->GetAddress());								
						pc := instr->GetAddress();
					}

					label Operand->NOT_MATCH: {
# Console->Print(pc)->Print(": NOT_MATCH, symb='")->Print(instr->GetAddress()->As(Char))->PrintLine('\'');
						if(string->Get(i) <> instr->GetAddress()->As(Char)) {
							if(@start < 0) {
								@start := i;
							};
							i += 1;
							pc += 1;
						}
						else {
							if(top > 0) {
								top -=1 ;
								pc := stack[top];
							}
							else {
								@start := -1;
								return false;
							};
						};
					}

					label Operand->MATCH: {
# Console->Print(pc)->Print(": MATCH, symb='")->Print(instr->GetAddress()->As(Char))->Print("' char=")->PrintLine(instr->GetAddress()->As(Char));					
						if(string->Get(i) = instr->GetAddress()->As(Char)) {
							if(@start < 0) {
								@start := i;
							};
							i += 1;
							pc += 1;
						}
						else {
							if(top > 0) {
								top -=1 ;
								pc := stack[top];
							}
							else {
								@start := -1;
								return false;
							};
						};
					}
					
					label Operand->MATCH_RANGE: {
						range := @ranges->Find(instr->GetAddress())->As(String);
# Console->Print(i)->Print(": MATCH_RANGE, range='")->Print(range)->PrintLine('\'');
						c := string->Get(i);
						if(c >= range->Get(0) & c <= range->Get(2)) {
							if(@start < 0) {
								@start := i;
							};
							i += 1;
							pc += 1;
						}
						else {
							if(top > 0) {
								top -=1 ;
								pc := stack[top];
							}
							else {
								@start := -1;
								return false;
							};
						};					
					}
					
					label Operand->BRANCH: {
# Console->Print(pc)->Print(": BRANCH, symb='")->Print(instr->GetAddress()->As(Char))->PrintLine('\'');
						pc += 1;
						stack[top] := pc + 1;
						top += 1;
					}
				};
# "---"->PrintLine();
			}
			while(instr->GetOperand() <> Operand->STOP  & i <= string->Size());
			
			return false;
		}
		
		method : public : Apply(string : String) ~ String {
			@string := string;
			if(@error = true) {
				return "";
			};
			
			if(Execute(@instrs, string, 0)) {
				if(@start < 0) {
					return string;
				};
				
# Console->Print("range: ")->Print(@start)->Print(", ")->PrintLine(@end);				
				return string->SubString(@start, @end - @start);
			};
			
			return "";
		}
		
		method : public : Next() ~ String {
			if(@error = true | @string = Nil | @end = -1) {
				return "";
			};
			
			@start := -1;
			if(Execute(@instrs, @string, @end)) {
				if(@start < 0) {
					return @string;
				};
				
# Console->Print("range: ")->Print(@start)->Print(", ")->PrintLine(@end);				
				return @string->SubString(@start, @end - @start);
			};
			
			return "";
		}
		
		method : DumpInstrs(instrs : Instr[]) ~ Nil {
			i := 0;
			do {
				instr := instrs[i];
				select(instr->GetOperand()) {
					label Operand->STOP: {
						Console->Print(i)->PrintLine(": STOP");
					}
					
					label Operand->NOT_MATCH: {
						Console->Print(i)->Print(": NOT_MATCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');
					}
					
					label Operand->MATCH_RANGE: {
						range := @ranges->Find(instr->GetAddress())->As(String);
						Console->Print(i)->Print(": MATCH_RANGE, range='")
							->Print(range)->PrintLine('\'');							
					}
					
					label Operand->JUMP: {
						Console->Print(i)->Print(": JUMP, addr=")
							->PrintLine(instr->GetAddress());
					}

					label Operand->MATCH: {
						Console->Print(i)->Print(": MATCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');
					}
					
					label Operand->BRANCH: {
						Console->Print(i)->Print(": BRANCH, symb='")
							->Print(instr->GetAddress()->As(Char))->PrintLine('\'');				
					}
				};
				i += 1;
			}
			while(instr->GetOperand() <> Operand->STOP);
		}
		
		method : DumpSrc(prep : Int[]) ~ Nil {
			"source="->Print();
			i := 0;
			t := prep[i];
			while(t <> 0) {
				select(t) {
					label Token->LPRN: {
						'('->Print();
					}
					
					label Token->RPRN: {
						')'->Print();
					}
					
					label Token->KLEENE: {
						'*'->Print();
					}
					
					label Token->ALTERN: {
						'|'->Print();
					}
					
					label Token->CONCAT: {
						'&'->Print();
					}
					
					other: {
						c := t->As(Char);
						c->Print();
					}
				};
				i += 1;
				t := prep[i];
			};
			'\n'->Print();
		}
	}
}

#~
/*
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the
 * Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall
 * be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS
 * OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
~#
