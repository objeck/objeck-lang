#~~
Copyright (c) 2024 Randy Hollines
~~#	

use Web.HTTP, Collection, Data.JSON, Data.JSON.Scheme;

#~
Google Gemini ML client APIs (-lib gemini)
~#
bundle API.Google.Gemini {
	#~
	OAuth enabled endpoint class
	~#
	class OAuthEndPoint {
		@last_message : static : String;

		New() {}

		#~
		Get OAuth token
		@return OAuth token
		~#
		function : GetToken() ~ String {
			token_str := System.IO.Net.OAuth.OAuthToken->ReadTokenFormat(System.IO.Filesystem.FileReader->ReadFile("client_secrets.dat"));
			if(token_str = Nil) {
				scopes := [
					"https://www.googleapis.com/auth/cloud-platform", 
					"https://www.googleapis.com/auth/generative-language.retriever",
					"https://www.googleapis.com/auth/generative-language.tuning"];
				token := System.IO.Net.OAuth.OAuthClient->New("client_secrets.json", scopes)->GetToken();
				if(token <> Nil) {
					System.IO.Filesystem.FileWriter->WriteFile("client_secrets.dat", 
						System.IO.Net.OAuth.OAuthToken->FormatNewToken(token->GetAccessToken(), token->GetExpiresIn()));
					token_str := System.IO.Net.OAuth.OAuthToken->ReadTokenFormat(System.IO.Filesystem.FileReader->ReadFile("client_secrets.dat"));
				}
				else {
					">>> OAuth - Unable to load or parse: file='client_secrets.json', file_format='https://developers.google.com/api-client-library/dotnet/guide/aaa_client_secrets' <<<"->ErrorLine();
					return Nil;
				}
			};

			return token_str;
		}

		function : SetLastError(last_message : String) ~ Nil {
			@last_message := last_message;
		}

		#~
		Get the last error
		@return last error
		~#
		function : GetLastError() ~ String {
			return @last_message;
		}
	}
	
	#~
	Gemini model interactions
	
```
content := Content->New("user")->AddPart(TextPart->New("What number is this image showing?"))
  ->AddPart(BinaryPart->New(FileReader->ReadBinaryFile("thirdteen.png"), "image/png"));
candidates := Model->GenerateContent("models/gemini-1.5-flash", content, EndPoint->GetApiKey());
each(candidate in candidates) {
  candidate->ToString()->PrintLine();
};
```
	~#
	class Model from EndPoint implements Stringify {
		@description : String;
		@display_name : String;
		@input_token_limit : Int;
		@name : String;
		@output_token_limit : Int;
		@generation_methods : Vector<String>;
		@temperature : Float;
		@top_k : Int;
		@top_p : Float;
		@version : String;

		enum TaskType {
			TASK_TYPE_UNSPECIFIED,
			RETRIEVAL_QUERY,
			RETRIEVAL_DOCUMENT,
			SEMANTIC_SIMILARITY,
			CLASSIFICATION,
			CLUSTERING
		}

		New : private(model_json : JsonElement) {
			Parent();

			@description := model_json->Get("description")->GetString();
			@display_name := model_json->Get("displayName")->GetString();
			@input_token_limit := model_json->Get("inputTokenLimit")->GetInt();
			@name := model_json->Get("name")->GetString();
			@output_token_limit := model_json->Get("outputTokenLimit")->GetInt();

			@generation_methods := Vector->New()<String>;
			@generation_methods_json := model_json->Get("supportedGenerationMethods");
			each(generation_method_json in @generation_methods_json) {
				@generation_methods->AddBack(generation_method_json->GetString());
			}

			@temperature := 0.9;
			@temperature_json := model_json->Get("@temperature");
			if(@temperature_json <> Nil) {
				@temperature := @temperature_json->GetFloat();
			};

			top_k_json := model_json->Get("topK");
			if(top_k_json <> Nil) {
				@top_k := top_k_json->GetInt();
			};

			top_p_json := model_json->Get("topP");
			if(top_p_json <> Nil) {
				@top_p := top_p_json->GetFloat();
			};
			@version := model_json->Get("version")->GetString();
		}
		
		#~
		Lists available models
		@param key API key
		@return available models
		~#
		function : List(key : String) ~ Vector<Model> {
			models := Vector->New()<Model>;

			url_str := "https://generativelanguage.googleapis.com/v1/models?key={$key}"
			response_json := GetRequest(Url->New(url_str));

			if(response_json <> Nil) {
				# response_json->ToString()->PrintLine();

				next_page_json : JsonElement;
				do {
					# load next page, if it exists
					if(next_page_json <> Nil) {
						next_page_str := "&pageToken=";
						next_page_str += next_page_json->GetString();

						response_json := GetRequest(Url->New(url_str + next_page_str));
						if(response_json = Nil) {
							return Nil;
						};
					};

					models_json := response_json->Get("models");
					if(models_json <> Nil) {
						each(model_json in models_json) {
							models->AddBack(Model->New(model_json));
						};
					};
					next_page_json := response_json->Get("nextPageToken");
				}
				while(next_page_json <> Nil);
			};

			return models;
		}

		#~
		Gets a model by name
		@param model_name model name
		@param key API key
		@return available models
		~#
		function : Get(model_name : String, key : String) ~ Model {
			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}?key={$key}");
			model_json := GetRequest(url);

			if(model_json <> Nil) {
				# model_json->ToString()->PrintLine();
				return Model->New(model_json);
				
			};

			return Nil;
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content content for the model
		@param key API key
		~#
		function : GenerateContent(model_name : String, content : Content, key : String) ~ Vector<Candidate> {
			return GenerateContent(model_name, content, Nil, Nil, Nil, Nil, key);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content content for the model
		@param resp_schema response format		
		@param key API key
		~#
		function : GenerateContent(model_name : String, content : Content, resp_schema : Pair<String, ParameterType>, key : String) ~ Vector<Candidate> {
			return GenerateContent(model_name, content, Nil, resp_schema, Nil, Nil, key);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content content for the model
		@param funcs map of function callbacks, name must to map to function callback name
		@param key API key
		~#
		function : GenerateContent(model_name : String, content : Content, funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>, key : String) ~ Vector<Candidate> {
			return GenerateContent(model_name, content, funcs, Nil, Nil, Nil, key);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content model content
		@param funcs map of function callbacks, name must to map to function callback name
		@param safety_settings key/value safety settings
		@param resp_schema response format
		@param config generation configuration, currently unsupported
		@param key API key		
		~#
		function : GenerateContent(model_name : String, content : Content, funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>, resp_schema : Pair<String, ParameterType>, safety_settings : Vector<Collection.Tuple.Pair<String, String>>, config : GenerationConfig, key : String) ~ Vector<Candidate> {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return GenerateContent(model_name, contents, funcs, resp_schema, safety_settings, config, key);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param contents list of content for the model
		@param funcs map of function callbacks, name must to map to function callback name		
		@param safety_settings key/value safety settings
		@param resp_schema response format
		@param config generation configuration, currently unsupported
		@param key API key		
		~#
		function : GenerateContent(model_name : String, contents : Vector<Content>, funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>, resp_schema : Pair<String, ParameterType>, safety_settings : Vector<Collection.Tuple.Pair<String, String>>, config : GenerationConfig, key : String) ~ Vector<Candidate> {
			# add contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole());

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json);
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);
			
			# response schema 
			if(resp_schema <> Nil) {
				schema_json := resp_schema->GetSecond();
				schema_mime_type := resp_schema->GetFirst();

				gen_config_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				gen_config_obj_json->Insert("responseMimeType", schema_mime_type);
				gen_config_obj_json->Insert("responseSchema", schema_json->ToJson());

				contents_obj_json->Insert("generationConfig", gen_config_obj_json);
			};

			if(funcs <> Nil) {
				function_declaration_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
		
				func_key_values := funcs->GetKeyValues()<Pair<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>>;
				each(func_key_value in func_key_values) {
					func_def_dclr := func_key_value->GetSecond()<FunctionType, Func2Ref<JsonElement, JsonElement>>;
					func_dclr := func_def_dclr->GetFirst();

					function_declaration_array_json->Add(JsonParser->TextToElement(func_dclr->ToString()));
				};
				
				# create array of functions
				function_declaration_obj_array_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				function_declaration_obj_array_json->Insert("function_declarations", function_declaration_array_json);

				tools_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				tools_array_json->Add(function_declaration_obj_array_json);

				# set tools
				contents_obj_json->Insert("tools", tools_array_json);
			};
			
			# safety settings
			if(safety_settings <> Nil) {
				safety_setting_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(safety_setting in safety_settings) {
					safety_setting_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					safety_setting_obj_json->Insert("category", safety_setting->GetFirst());
					safety_setting_obj_json->Insert("threshold", safety_setting->GetSecond());
					safety_setting_array_json->Add(safety_setting_obj_json);
				};
				
				contents_obj_json->Insert("safetySettings", safety_setting_array_json);
			};

contents_obj_json->ToString()->PrintLine();
"---"->PrintLine();

			url := Url->New("https://generativelanguage.googleapis.com/v1beta/{$model_name}:generateContent?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
response->ToString()->PrintLine();
"---"->PrintLine();

					return BuildContentResponse(contents_obj_json, content_array_json, response, funcs, url, false);
				};
			};
			
			return Nil;
		}

		function : BuildContentResponse(contents_obj_json : JsonElement, content_array_json : JsonElement, response : JsonElement, 
				funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>, url : Url, is_chat : Bool) ~ Vector<Candidate> {
			
			candidates := Vector->New()<Candidate>;
					
			candidates_json := response->Get("candidates");
			each(candidate_json in candidates_json) {
				# general attributes
				content_json := candidate_json->Get("content");
				role := content_json->Get("role")->GetString();
				finish_reason := candidate_json->Get("finishReason")->GetString();

				# parts
				parts := Vector->New()<Part>;
				parts_json := content_json->Get("parts");

				if(is_chat) {
					content_array_json->Add(content_json);
				};

				each(part_json in parts_json) {
					part : Part;

					# text part
					if(part_json->Has("text")) {
						text_json := part_json->Get("text");
						part := TextPart->New(text_json->GetString());
					}
					# inline part
					else if(part_json->Has("inlineData")) {
						inline_mime_type := part_json->FindElements("inlineData/mimeType")->GetString();
						inline_data := part_json->FindElements("inlineData/data")->GetString();
						part := BinaryPart->New(Cipher.Decrypt->Base64(inline_data), inline_mime_type);
					}
					# inline part
					else if(part_json->Has("functionCall")) {
						func_call_json := part_json->Get("functionCall");
						
						func_name := func_call_json->Get("name")->GetString();
						func_args := func_call_json->Get("args");

						func_callback_mapping := funcs->Find(func_name)<FunctionType, Func2Ref<JsonElement, JsonElement>>;
						if(func_callback_mapping <> Nil) {
							func_callback_ref := func_callback_mapping->GetSecond()<Func2Ref<JsonElement, JsonElement>>;
							func_callback := func_callback_ref->Get();

							# call function and response
							func_callback_response := func_callback(func_args);

							# build response object
							parts_response_obj := JsonElement->New(JsonElement->JsonType->OBJECT);
							parts_response_obj->Insert("name", func_name);


							foo_obj := JsonElement->New(JsonElement->JsonType->OBJECT);
							foo_obj->Insert("name", func_name);
							foo_obj->Insert("content", func_callback_response);
							parts_response_obj->Insert("response", foo_obj);


							# set response object
							parts_response_wrapper_obj := JsonElement->New(JsonElement->JsonType->OBJECT);
							parts_response_wrapper_obj->Insert("functionResponse", parts_response_obj);

							# build response parts array
							parts_obj_array := JsonElement->New(JsonElement->JsonType->ARRAY);
							parts_obj_array->Add(parts_response_wrapper_obj);

							# set response parts array
							parts_obj_array_json := JsonElement->New(JsonElement->JsonType->OBJECT);
							parts_obj_array_json->Insert("parts", parts_obj_array);
							
							# add function callback request
							content_array_json->Add(content_json);

							# add function response
							content_array_json->Add(parts_obj_array_json);

							# "-- reply with added content data --"->PrintLine();
							# contents_obj_json->ToString()->PrintLine();

							if(url->GetQueryParameters()->Has("key")) {
								response := PostRequest(contents_obj_json, url);															
								if(response <> Nil) {
									# "-- response to reply with function data --"->PrintLine();
									# response->ToString()->PrintLine();	

									return BuildContentResponse(contents_obj_json, content_array_json, response, funcs, url, is_chat);
								};
							};
						};
					};

					parts->AddBack(part);
				};

				# safety ratings
				safety_ratings := Vector->New()<Collection.Tuple.Pair<String, String>>;
				safety_ratings_json := candidate_json->Get("safetyRatings");
				
				if(safety_ratings_json <> Nil) {
					each(safety_rating_json in safety_ratings_json) {
						safety_category := safety_rating_json->Get("category")->GetString();
						safety_probability := safety_rating_json->Get("probability")->GetString();
						safety_rating := Collection.Tuple.Pair->New(safety_category, safety_probability)<String, String>;

						safety_ratings->AddBack(safety_rating);
					};
				};

				candidates->AddBack(Candidate->New(role, finish_reason, parts, safety_ratings));
			};

			return candidates;
		}

		#~
		Generates an embedding from the model given an input Content
		@param content model content=
		@param key API key		
		~#
		function : EmbedContent(content : Content, key : String) ~ Float[] {
			return EmbedContent(content, Nil, Model->TaskType->TASK_TYPE_UNSPECIFIED, key);
		}

		#~
		Generates an embedding from the model given an input Content
		@param content model content=
		@param title title for the text. Only applicable when TaskType is RETRIEVAL_DOCUMENT
		@param type task type for which the embeddings will be used
		@param key API key		
		~#
		function : EmbedContent(content : Content, title : String, type : Model->TaskType, key : String) ~ Float[] {
			# content
			parts := content->GetParts();
			content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(part in parts) {
				if(part->TypeOf(TextPart)) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					text_part := part->As(TextPart);
					part_obj_json->Insert("text", text_part->GetText());
					parts_obj_json->Add(part_obj_json);
				};
			};
			content_obj_json->Insert("parts", parts_obj_json);
	
			embed_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			embed_obj_json->Insert("content", content_obj_json);

			if(type = Model->TaskType->RETRIEVAL_DOCUMENT) {
				embed_obj_json->Insert("title", title);
			};
			
			select(type) {
					label Model->TaskType->RETRIEVAL_QUERY {
						embed_obj_json->Insert("taskType", "RETRIEVAL_QUERY");
					}
					
					label Model->TaskType->RETRIEVAL_DOCUMENT {
						embed_obj_json->Insert("taskType", "RETRIEVAL_DOCUMENT");
					}
					
					label Model->TaskType->SEMANTIC_SIMILARITY {
						embed_obj_json->Insert("taskType", "SEMANTIC_SIMILARITY");
					}
					
					label Model->TaskType->CLASSIFICATION {
						embed_obj_json->Insert("taskType", "CLASSIFICATION");
					}
					
					label Model->TaskType->CLUSTERING {
						embed_obj_json->Insert("taskType", "CLUSTERING");
					}
			};
			# embed_obj_json->ToString()->PrintLine();
			
			model := "models/embedding-001";
			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model}:embedContent?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {
				response_json := PostRequest(embed_obj_json, url);
				if(response_json <> Nil) {
					values_array_json := response_json->FindElements("embedding/values");
					# values_array_json->Size()->PrintLine();

					values := Float->New[values_array_json->Size()];
					each(i : values_array_json) {
						value_json := values_array_json->Get(i);
						values[i] := value_json->GetFloat();
					};

					return values;
				};
			};
						
			return Nil;
		}

		#~
		Runs a model's tokenizer on input content and returns the token count
		@param model_name model name
		@param content content for the model
		@param key API key		
		~#
		function : CountTokens(model_name : String, content : Content, key : String) ~ Int {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return CountTokens(model_name, contents, key);
		}

		#~
		Runs a model's tokenizer on input content and returns the token count
		@param model_name model name
		@param contents list of content for the model
		@param key API key		
		~#
		function : CountTokens(model_name : String, contents : Vector<Content>, key : String) ~ Int {
			# contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole())

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json)
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

			url := Url->New("https://generativelanguage.googleapis.com/v1/{$model_name}:countTokens?key={$key}");
			if(url->GetQueryParameters()->Has("key")) {			
				response := PostRequest(contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					return response->Get("totalTokens")->GetInt();
				};
			};

			return -1;
		}

		#~
		Get the model's description
		@return model's description
		~#
		method : public : GetDescription() ~ String {
			return @description;
		}

		#~
		Get the model's display name
		@return model's display name
		~#
		method : public : GetDisplayName() ~ String {
			return @display_name;
		}

		#~
		Get the model's input token limit
		@return model's input token limit
		~#
		method : public : GetInputTokenLimit() ~ Int {
			return @input_token_limit;
		}

		#~
		Get the model's name
		@return model's name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Maximum number of output tokens available for this model
		@return maximum number of output tokens
		~#
		method : public : GetOutputTokenLimit() ~ Int {
			return @output_token_limit;
		}

		#~
		The model's supported generation methods.
		@return generation methods
		~#
		method : public : GetGenerationMethods() ~ Vector<String> {
			return @generation_methods;
		}

		#~
		Controls the randomness of the output. Values can range over [0.0,1.0], 
		inclusive. A value closer to 1.0 will produce responses that are more 
		varied, while a value closer to 0.0 will typically result in less 
		surprising responses from the model.
		@return model temperature 
		~#
		method : public : GetTemperature() ~ Float {
			return @temperature;
		}

		#~
		Get the top-k sampling of the most probable tokens.
		@return top-k sampling
		~#
		method : public : GetTopK() ~ Int {
			return @top_k;
		}

		#~
		Nucleus sampling considers the smallest set of tokens whose probability sum is at least topP.
		~#
		method : public : GetTopP() ~ Float {
			return @top_p;
		}

		#~
		Get the model version
		@return model version
		~#
		method : public : GetVersion() ~ String {
			return @version;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			buffer += "name='"
			buffer += @name;

			buffer += "', display_name="
			buffer += @display_name;

			buffer += "', version="
			buffer += @version;

			buffer += "' input_token_limit="
			buffer += @input_token_limit;

			buffer += ", output_token_limit="
			buffer += @output_token_limit;

			buffer += ", description=\""
			buffer += @description;

			buffer += "\"\nmethods:"
			each(generation_method in @generation_methods) {
				buffer += "\n\t";
				buffer += generation_method;
			};
			buffer += ']';

			return buffer;
		}
	}

	#~
	Text message part
	~#
	class TextPart from Part implements Stringify {
		@text : String;

		New(text : String) {
			Parent();
			@text := text;
		}

		#~
		Get text
		@return text
		~#
		method : public : GetText() ~ String {
			return @text;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "text='{$@text}'";
		}
	}

	#~
	Binary message part
	~#
	class BinaryPart from Part implements Stringify {
		@data : Byte[];
		@mime_type : String;

		New(data : Byte[], mime_type : String) {
			Parent();

			@data := data;
			@mime_type := mime_type;
		}

		#~
		Get Base64 encoding binary string
		@return encoding binary string
		~#
		method : public : GetBase64Data() ~ String {
			return Cipher.Encrypt->Base64(@data);
		}

		#~
		Get MIME type
		@return MIME type
		~#
		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			data_size := @data->Size();
			return "data_size={$data_size}, mime_type='{$@mime_type}'";
		}
	}

	#~
	Abstract message part
	~#
	class Part {
		New() {}
		method : virtual : public : ToString() ~ String;
	}

	# TODO: implement, support is spotty
	class GenerationConfig from EndPoint {
		New() {
			Parent();
		}
	}

	#~
	Prompt content
	~#
	class Content from EndPoint implements Stringify {
		@parts : Vector<Part>;
		@role : String;

		#~
		Constructor
		@param role role
		~#
		New(role : String) {
			Parent();
			@role := role;
			@parts := Vector->New()<Part>;
		}

		#~
		Constructor
		@param parts message parts to add
		@param role role
		~#
		New(parts : Vector<Part>, role : String) {
			Parent();
			@role := role;
			@parts := parts;
		}

		#~
		Adds a part to the content
		@param part to add
		@return self reference to Content
		~#
		method : public : AddPart(part : Part) ~ Content {
			@parts->AddBack(part);
			return @self;
		}

		#~
		Get all parts
		@return all parts
		~#
		method : public : GetParts() ~ Vector<Part> {
			return @parts;
		}

		#~
		Get all text
		@return all text
		~#
		method : public : GetAllText() ~ String {
			buffer := "";

			each(part in @parts) {
				if(part->TypeOf(TextPart)) {
					text_part := part->As(TextPart);
					buffer->Append(text_part->GetText());
				}
			};

			return buffer;
		}

		#~
		Get the first part
		@return first part
		~#
		method : public : GetFirstPart() ~ Part {
			last := @parts->Size() - 1;
			if(last > -1) {
				return @parts->Get(last);
			};

			return Nil;
		}

		#~
		Get the role
		@return role
		~#
		method : public : GetRole() ~ String {
			return @role;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "role='";
			buffer->Append(@role);

			buffer->Append("'\nparts:");
			each(part in @parts) {
				buffer->Append("\n\t");
				buffer->Append(part->ToString());
			};
			buffer->Append("\n---");
						
			return buffer;
		}
	}

	#~
	Candidate prompt response
	~#
	class Candidate from Content implements Stringify {
		@finish_reason : String;
		@safety_ratings : Vector<Collection.Tuple.Pair<String,String>>;
		
		New(role : String, finish_reason : String, parts : Vector<Part>, safety_ratings : Vector<Collection.Tuple.Pair<String,String>>) {
			Parent(parts, role);

			@role := role;
			@finish_reason := finish_reason;
			@parts := parts;
			@safety_ratings := safety_ratings;
		}

		#~
		Get finishing reason
		@return finishing reason
		~#
		method : public : GetFinishReason () ~ String {
			return @finish_reason;
		}

		#~
		Get safety ratings
		@return list of safety ratings
		~#
		method : public : GetSafetyRatings() ~ Vector<Collection.Tuple.Pair<String,String>> {
			return @safety_ratings;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "";

			buffer->Append("', role='");
			buffer->Append(@role);

			buffer->Append("', finish_reason='");
			buffer->Append(@finish_reason);

			buffer->Append("'\nparts:");
			each(part in @parts) {
				buffer->Append("\n\t");
				buffer->Append(part->ToString());
			};

			buffer->Append("'\n\tsafety_ratings:");
			each(safety_rating in @safety_ratings) {
				buffer->Append("\n\t");
				buffer->Append(safety_rating->ToString());
			};

			return buffer;
		}
	}

	#~
	Gemini chat session

```
session := Chat->New("models/gemini-pro", EndPoint->GetApiKey());

content := session->SendPart(TextPart->New("What is the tallest mountain in the California?"), "user");
content->GetFirstPart()->ToString()->PrintLine();

content := session->SendPart(TextPart->New("How tall is it?"), "user");
content->GetFirstPart()->ToString()->PrintLine();

content := session->SendPart(TextPart->New("Why is it so tall?"), "user");
content->GetFirstPart()->ToString()->PrintLine();

content := session->SendPart(TextPart->New("Where is it located?"), "user");
content->GetFirstPart()->ToString()->PrintLine();
"======"->PrintLine();

session->ToString()->PrintLine();
```
	~#
	class Chat from Content implements Stringify {
		@content_array_json : JsonElement;
		@contents_obj_json : JsonElement;
		@model_name : String;
		@key : String;

		New(model_name : String, key : String) {
			Parent();

			@model_name := model_name;
			@key := key;

			@content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			@contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			@contents_obj_json->Insert("contents", @content_array_json);
		}

		#~
		Send chart part
		@param part prompt chat part
		@param role prompt role
		@return prompt response
		~#
		method : public : SendPart(part : Part, role : String) ~ Candidate {
			content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			content_obj_json->Insert("role", role);

			parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			# text
			if(part->TypeOf(TextPart)) {
				text_part := part->As(TextPart);
				part_obj_json->Insert("text", text_part->GetText());
			}					
			else {
				binary_part := part->As(BinaryPart);

				inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
				inline_obj_json->Insert("data", binary_part->GetBase64Data());
				
				part_obj_json->Insert("inlineData", inline_obj_json);
			};

			parts_obj_json->Add(part_obj_json);

			content_obj_json->Insert("parts", parts_obj_json);
			@content_array_json->Add(content_obj_json);


			url := Url->New("https://generativelanguage.googleapis.com/v1/{$@model_name}:generateContent?key={$@key}");
			if(url->GetQueryParameters()->Has("key")) {
				# @contents_obj_json->ToString()->PrintLine();
				response := EndPoint->PostRequest(@contents_obj_json, url);
				if(response <> Nil) {
					# response->ToString()->PrintLine();
					candidates := Model->BuildContentResponse(@contents_obj_json, @content_array_json, response, Nil, url, true);
					return candidates->Last();
				};
			};
			
			return Nil;
		}

		#~
		Get all chat parts
		@return list of all chat parts
		~#
		method : public : GetAllParts() ~ Vector<Content> {
			contents := Vector->New()<Content>;

			contents_array_json := @contents_obj_json->Get("contents");
			each(candidate_json in contents_array_json) {
				# role and parts
				role := candidate_json->Get("role")->GetString();
				parts_json := candidate_json->Get("parts");
				
				parts := Vector->New()<Part>;
				each(part_json in parts_json) {
					part : Part;

					# text part
					if(part_json->Has("text")) {
						text_json := part_json->Get("text");
						part := TextPart->New(text_json->GetString());
					};

					# inline part
					if(part_json->Has("inlineData")) {
						inline_mime_type := part_json->FindElements("inlineData/mimeType")->GetString();
						inline_data := part_json->FindElements("inlineData/data")->GetString();
						part := BinaryPart->New(Cipher.Decrypt->Base64(inline_data), inline_mime_type);
					};

					parts->AddBack(part);
				};

				contents->AddBack(Content->New(parts, role));
			};

			return contents;
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "";

			buffer->Append("model='")
			buffer->Append(@model_name);
			buffer->Append("'\n###\n");

			parts := GetAllParts();
			each(i : parts) {
				part := parts->Get(i);
				buffer->Append(part->ToString());

				if(i + 1 < parts->Size()) {
					buffer->Append("\n");
				}
			};

			return buffer;
		}
	}

	#~
	Gemini endpoint
	~#
	class EndPoint {
		@last_message : static : String;
		@api_key : static : String;

		New() {}

		function : private : GetRequest(url : Url) ~ JsonElement {
			response := HttpsClient->QuickGet(url, "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : private : PostRequest(request : JsonElement, url : Url, headers : Map<String,String>) ~ JsonElement {
			response := HttpsClient->QuickPost(url, request->ToString()->ToByteArray(), "application/json", headers);
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		function : private : PostRequest(request : JsonElement, url : Url) ~ JsonElement {
			response := HttpsClient->QuickPost(url, request->ToString()->ToByteArray(), "application/json");
			if(response <> Nil) {
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				
				# response->GetContent()->ToString()->PrintLine();			
				
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				error_json := response_json->FindElements("error/message")
				if(error_json <> Nil) {
					error_message := error_json->GetString();
					">>> Error: {$error_message} <<<"->ErrorLine();
					return Nil;
				};

				return response_json;
			};

			return Nil;
		}

		#~
		Set the API file key path
		@param api_key API file key path
		~#
		function : SetApiKey(api_key : String) ~ Nil {
			@api_key := api_key;
		}

		#~
		Reads API from 'api_key.dat'
		@return API key
		~#
		function : GetApiKey() ~ String {
			if(@api_key = Nil) {
				filename := "gemini_api_key.dat";
				token := System.IO.Filesystem.FileReader->ReadFile(filename);
				if(token = Nil) {
					dir_str := System.IO.Filesystem.Directory->GetWorking();
					dir_str += System.IO.Filesystem.Directory->GetSlash();
					dir_str += filename;
					
					">>> Unable to read API key from: '{$dir_str}', also consider calling SetApiKey(..)"->ErrorLine();
				}
				else {
					@api_key := token->Trim();
				};
			};

			return @api_key;
		}

		function : SetLastError(last_message : String) ~ Nil {
			@last_message := last_message;
		}

		#~
		Get the last error
		@return last error
		~#
		function : GetLastError() ~ String {
			return @last_message;
		}
	}
}

#~
Google Gemini support for tuned models (-lib gemini)
~#
bundle API.Google.Gemini.Tuning {
	#~
	Fine-tuning model operations
	~#
	class Tuner from OAuthEndPoint implements Stringify {
		@display_name : String;
		@description : String;
		@tuning_task : TuningTask;
		@tune_model_source : Pair<String, String>;
		@base_model : String;
		@temperature : Float;
		@top_p : Float;
		@top_k : Int;

		New : private(display_name : String, description : String, tuning_task : TuningTask, tune_model_source : Pair<String, String>, 
				base_model : String, temperature : Float, top_p : Float, top_k : Int) {
			Parent();

			@display_name := display_name;
			@description := description;
			@tuning_task := tuning_task;
			@tune_model_source := tune_model_source;
			@base_model := base_model;
			@temperature := temperature;
			@top_p := top_p;
			@top_k := top_k;
		}

		#~
		Creates a tuned model
		@param display_name the name to display for this model in user interfaces
		@param base_model the name of the base model to tune from
		@param tuning_task the tuning task that creates the tuned model
		@return snapshot of tuned model and metadata
		~#
		function : Create(display_name : String, base_model : String, tuning_task : TuningTask) ~ API.Google.Gemini.Tuning.TunedModel {
			return Create(display_name, Nil, tuning_task, Nil, base_model, -1.0, -1.0, -1)
		}

		#~
		Creates a tuned model
		@param display_name the name to display for this model in user interfaces
		@param description a short description of this model
		@param tuning_task the tuning task that creates the tuned model
		@param tune_model_source used as the starting point for training the new model
		@param base_model the name of the base model to tune from
		@param temperature controls the randomness of the output
		@param top_p for nucleus sampling considers the smallest set of tokens whose probability sum is at least top-p.
		@param top_k for top-k sampling considers the set of top-k most probable tokens. this value specifies default to be used by the backend while making the call to the model
		@return snapshot of tuned model and metadata
		~#
		function : Create(display_name : String, description : String, tuning_task : TuningTask, tune_model_source : Pair<String, String>, 
				base_model : String, temperature : Float, top_p : Float, top_k : Int) ~ API.Google.Gemini.Tuning.TunedModel {
			query_json := Tuner->New(display_name, description, tuning_task, tune_model_source, base_model, temperature, top_p, top_k);
			data := query_json->ToString()->ToByteArray();

			# data->ToString()->PrintLine();
			# "---"->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/tunedModels"), data, "application/json", headers);
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return API.Google.Gemini.Tuning.TunedModel->New(response_json);
			};

			return Nil;
		}

		#~
		Creates a tuned model
		@param model_id resource model identifier
		@return tuned model
		~#
		function : Get(model_id : String) ~ TunedModel {
			url_str := "https://generativelanguage.googleapis.com/v1beta/{$model_id}";

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New(url_str), "application/json", headers);
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return API.Google.Gemini.Tuning.TunedModel->New(response_json)
			};

			return Nil;
		}

		#~
		Deletes all trained models
		@return true if successful, false otherwise
		~#
		function : DeleteAllModels() ~ Bool {
			tuned_models := List();
			each(tuned_model in tuned_models) {
				if(<>tuned_model->Delete()) {
					return false;
				}
			};
			
			return true;
		}

		#~
		Lists tuned models owned by the user
		@param model_id resource model identifier
		@return list of tuned models
		~#
		function : List() ~ Vector<TunedModel> {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/tunedModels"), "application/json", headers);
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				tuned_models := Vector->New()<TunedModel>;

				next_page_json : JsonElement;
				do {
					# load next page, if it exists
					if(next_page_json <> Nil) {
						next_page_str := "?pageToken=";
						next_page_str += next_page_json->GetString();

						url_str := "https://generativelanguage.googleapis.com/v1beta/tunedModels" + next_page_str;
						response := HttpsClient->QuickGet(Url->New(url_str), "application/json", headers);
						if(response = Nil) {
							return Nil;
						}
						else {
							# response->GetContent()->ToString()->PrintLine();							
							response_json := JsonParser->TextToElement(response->GetContent()->ToString());
							if(response_json = Nil) {
								"### Error: Unable to parse response ###"->ErrorLine();
								return Nil;
							};
							
							if(response_json->Has("error")) {
								error_str := response_json->FindElements("error/message")->GetString();
								SetLastError(error_str);
								return Nil;
							};
						};
					};

					tuned_models_json := response_json->Get("tunedModels");
					if(tuned_models_json <> Nil) {
						each(tuned_model_json in tuned_models_json) {						
							tuned_models->AddBack(API.Google.Gemini.Tuning.TunedModel->New(tuned_model_json));
						};
					};

					next_page_json := response_json->Get("nextPageToken");
				}
				while(next_page_json <> Nil);

				return tuned_models;
			};

			return Nil;
		}

		#~
		Creates a tuned model
		@param new_email email address of new owner
		@param model_id resource model identifier
		@return true if successful, false otherwise
		~#
		function : TransferOwnership(new_email : String, model_id : String) ~ Bool {
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("emailAddress", new_email);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$model_id}:transferOwnership"), data, "application/json", headers);			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			}

			return false;
		}

		#~
		JSON representation of the instance
		@return JSON representation of the instance
		~#
		method : public : ToJson() ~ JsonElement {
			tuned_model_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			tuned_model_json->Insert("displayName", @display_name);
			tuned_model_json->Insert("baseModel", @base_model);
			tuned_model_json->Insert("tuningTask", @tuning_task->ToJson());

			if(@description <> Nil) {
				tuned_model_json->Insert("description", @description);
			};

			if(@tune_model_source <> Nil) {
				tune_model_source_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				tune_model_source_json->Insert("tunedModel", @tune_model_source->GetFirst());
				tune_model_source_json->Insert("baseModel", @tune_model_source->GetSecond());
				tuned_model_json->Insert("tunedModelSource", tune_model_source_json);
			};

			if(@temperature > 1.0) {
				tuned_model_json->Insert("temperature", @temperature);
			};

			if(@top_p > 1.0) {
				tuned_model_json->Insert("topP", @top_p);
			};

			if(@top_k > 1.0) {
				tuned_model_json->Insert("topK", @top_k);
			};

			return tuned_model_json;
		}

		#~
		JSON string representation of the instance
		@return JSON string representation of the instance
		~#
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}

	#~
	Fine-tuned model
	~#
	class TunedModel from OAuthEndPoint implements Stringify {
		@name : String;
		@base_model : String;
		@display_name : String;
		@state : String;
		@create_time_str : String;
		@update_time_str : String;
		@temperature : Float;
		@top_p : Float;
		@top_k : Int;
		@metadata : Map<String, String>;

		New (tuned_model_json : JsonElement) {
			Parent();

			@name := tuned_model_json->Get("name")->GetString();
			if(tuned_model_json->Has("baseModel")) {
				@base_model := tuned_model_json->Get("baseModel")->GetString();
				@display_name := tuned_model_json->Get("displayName")->GetString();
				@state := tuned_model_json->Get("state")->GetString();
				@create_time_str := tuned_model_json->Get("createTime")->GetString();
				@update_time_str := tuned_model_json->Get("updateTime")->GetString();
				@temperature := tuned_model_json->Get("temperature")->GetFloat();
				@top_p := tuned_model_json->Get("topP")->GetFloat();
				@top_k := tuned_model_json->Get("topK")->GetInt();
			};

			metadata_json := tuned_model_json->Get("metadata");
			if(metadata_json <> Nil) {
				@metadata := Map->New()<String, String>;
				metadata_names := metadata_json->GetNames();
				each(metadata_name in metadata_names) {
					metadata_value := metadata_json->Get(metadata_name)->GetString();				
					@metadata->Insert(metadata_name, metadata_value);
				};
			};
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content content for the model
		@param funcs map of function callbacks, name must to map to function callback name
		~#
		method : public : GenerateContent(content : Content, funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>) ~ Vector<Candidate> {
			return GenerateContent(content, funcs, Nil, Nil);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param content model content
		@param funcs map of function callbacks, name must to map to function callback name
		@param safety_settings key/value safety settings
		@param config generation configuration, currently unsupported
		~#
		method : public : GenerateContent(content : Content, funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>, resp_schema : Pair<String, ParameterType>, safety_settings : Vector<Collection.Tuple.Pair<String, String>>) ~ Vector<Candidate> {
			contents := Vector->New()<Content>;
			contents->AddBack(content);

			return GenerateContent(contents, funcs, resp_schema, safety_settings);
		}

		#~
		Generates a response from the model given an input
		@param model_name model name
		@param contents list of content for the model
		@param funcs map of function callbacks, name must to map to function callback name		
		@param safety_settings key/value safety settings
		@param config generation configuration, currently unsupported
		~#
		method : public : GenerateContent(contents : Vector<Content>, funcs : Map<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>, resp_schema : Pair<String, ParameterType>, safety_settings : Vector<Collection.Tuple.Pair<String, String>>) ~ Vector<Candidate> {
			# add contents
			content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(content in contents) {
				parts := content->GetParts();
				content_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				content_obj_json->Insert("role", content->GetRole());

				parts_obj_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(part in parts) {
					part_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

					# text
					if(part->TypeOf(TextPart)) {
						text_part := part->As(TextPart);
						part_obj_json->Insert("text", text_part->GetText());
					}					
					else {
						binary_part := part->As(BinaryPart);

						inline_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						inline_obj_json->Insert("mimeType", binary_part->GetMimeType());
						inline_obj_json->Insert("data", binary_part->GetBase64Data());
						
						part_obj_json->Insert("inlineData", inline_obj_json);
					};

					parts_obj_json->Add(part_obj_json);
				};
				content_obj_json->Insert("parts", parts_obj_json);

				content_array_json->Add(content_obj_json);
			};
			contents_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			contents_obj_json->Insert("contents", content_array_json);

			# response schema 
			if(resp_schema <> Nil) {
				schema_json := resp_schema->GetSecond();
				schema_mime_type := resp_schema->GetFirst();

				gen_config_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				gen_config_obj_json->Insert("responseMimeType", schema_mime_type);
				gen_config_obj_json->Insert("responseSchema", schema_json->ToJson());

				contents_obj_json->Insert("generationConfig", gen_config_obj_json);
			};

			if(funcs <> Nil) {
				function_declaration_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
		
				func_key_values := funcs->GetKeyValues()<Pair<String, Pair<FunctionType, Func2Ref<JsonElement, JsonElement>>>>;
				each(func_key_value in func_key_values) {
					func_def_dclr := func_key_value->GetSecond()<FunctionType, Func2Ref<JsonElement, JsonElement>>;
					func_dclr := func_def_dclr->GetFirst();

					function_declaration_array_json->Add(JsonParser->TextToElement(func_dclr->ToString()));
				};
				
				# create array of functions
				function_declaration_obj_array_json := JsonElement->New(JsonElement->JsonType->OBJECT);
				function_declaration_obj_array_json->Insert("function_declarations", function_declaration_array_json);

				tools_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				tools_array_json->Add(function_declaration_obj_array_json);

				# set tools
				contents_obj_json->Insert("tools", tools_array_json);
			};
			
			# safety settings
			if(safety_settings <> Nil) {
				safety_setting_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(safety_setting in safety_settings) {
					safety_setting_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					safety_setting_obj_json->Insert("category", safety_setting->GetFirst());
					safety_setting_obj_json->Insert("threshold", safety_setting->GetSecond());
					safety_setting_array_json->Add(safety_setting_obj_json);
				};

				contents_obj_json->Insert("safetySettings", safety_setting_array_json);
			};

			# contents_obj_json->ToString()->PrintLine();
			# "---"->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");

			data := contents_obj_json->ToString()->ToByteArray();
			url := Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}:generateContent");

			response := HttpsClient->QuickPost(url, data, "application/json", headers);
			if(response <> Nil) {
				# response->GetContent()->PrintLine();
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				return Model->BuildContentResponse(contents_obj_json, content_array_json, response_json, funcs, url, false);
			};

			return Nil;
		}

		#~
		Lists available models
		@param key API key
		@return available models
		~#
		function : List(key : String) ~ Vector<TunedModel> {
			tuned_models := Vector->New()<TunedModel>;

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			
			url_str := "https://generativelanguage.googleapis.com/v1beta/tunedModels"
			response := HttpsClient->QuickGet(Url->New(url_str), headers);

			response_json	:= JsonParser->TextToElement(response->GetContent()->ToString());

			next_page_json : JsonElement;
			do {
				# load next page, if it exists
				if(next_page_json <> Nil) {
					next_page_str := "?pageToken=";
					next_page_str += next_page_json->GetString();

					url_next_str := url_str + next_page_str;
					response := HttpsClient->QuickGet(Url->New(url_next_str), "application/json", headers);
					if(response = Nil) {
						return Nil;
					}
					else {
						# response->GetContent()->ToString()->PrintLine();							
						response_json := JsonParser->TextToElement(response->GetContent()->ToString());
						if(response_json = Nil) {
							"### Error: Unable to parse response ###"->ErrorLine();
							return Nil;
						};
						
						if(response_json->Has("error")) {
							error_str := response_json->FindElements("error/message")->GetString();
							SetLastError(error_str);
							return Nil;
						};
					};
				};

				corporas_json := response_json->Get("corpora");
				if(corporas_json <> Nil) {
					each(corpora_json in corporas_json) {
						tuned_models->AddBack(TunedModel->New(corpora_json));
					};
				};

				next_page_json := response_json->Get("nextPageToken");
			}
			while(next_page_json <> Nil);

			return tuned_models;
		}

		#~
		Delete existing tuned model
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), "application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get name
		@return name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get base model
		@return base model
		~#
		method : public : GetBaseModel() ~ String {
			return @base_model;
		}

		#~
		Get display name
		@return display name
		~#
		method : public : GetDisplayName() ~ String {
			return @display_name;
		}

		#~
		Get state
		@return state
		~#
		method : public : GetState() ~ String {
			return @state;
		}

		#~
		Get temperature
		@return temperature
		~#
		method : public : GetTemperature() ~ Float {
			return @temperature;
		}

		#~
		Get top p
		@return top p
		~#
		method : public : GetTopP() ~ Float {
			return @top_p;
		}

		#~
		Get top k
		@return top k
		~#
		method : public : GetTopK() ~ Int {
			return @top_k;
		}

		#~
		String representation of the instance
		@return string representation of the instance
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";

			buffer += @name;
			if(@base_model = Nil) {
				buffer += '\'';
			}
			else {
				buffer += "', base_model='";
				buffer += @base_model;

				if(@display_name <> Nil) {
					buffer += "', display_name='";
					buffer += @display_name;
				};

				if(@state <> Nil) {
					buffer += "', state='";
					buffer += @state;
				};

				if(@base_model <> Nil) {
					buffer += "', base_model='";
					buffer += @base_model;
				};

				if(@create_time_str <> Nil) {
					buffer += "', create_time_str='";
					buffer += @create_time_str;
				};

				if(@update_time_str <> Nil) {
					buffer += "', update_time_str='";
					buffer += @update_time_str;
				};

				buffer += "', temperature='";
				buffer += @temperature;

				buffer += "', top_p='";
				buffer += @top_p;

				buffer += "', top_k='";
				buffer += @top_k;

				buffer += '\'';
			};

			if(@metadata <> Nil) {
				metadata_keys_values := @metadata->GetKeyValues()<Pair<String, String>>;
				buffer += "\nmetadata:";
				each(metadata_key_value in metadata_keys_values) {
					buffer += "\n\t";
				
					metadata_name := metadata_key_value->GetFirst();
					metadata_value := metadata_key_value->GetSecond();

					buffer += "name='";
					buffer += metadata_name;
					buffer += ", value='";
					buffer += metadata_value;
					buffer += "'";
				};
				buffer += '\n';
			};

			buffer += ']';

			return buffer;
		}
	}

	#~
	Task that create a tuned model
	~#
	class TuningTask implements Stringify {
		@training_data : Dataset;
		@hyper_params : Hyperparameters;
		
		#~
		Constructor
		@param training_data model training data
		@param hyper_params hyperparameters controlling the tuning process
		~#
		New(training_data : Dataset, hyper_params : Hyperparameters) {
			Parent();

			@training_data := training_data;
			@hyper_params := hyper_params;
		}

		#~
		Get model training data
		@return model training data
		~#
		method : public : GetTrainingData() ~ Dataset {
			return @training_data;
		}

		#~
		Get hyperparameters controlling the tuning process
		@return hyperparameters controlling the tuning process
		~#
		method : public : GetHyperparameters() ~ Hyperparameters {
			return @hyper_params;
		}

		#~
		JSON representation of the instance
		@return JSON representation of the instance
		~#
		method : public : ToJson() ~ JsonElement {
			tuning_task_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			tuning_task_obj_json->Insert("hyperparameters", @hyper_params->ToJson())
			tuning_task_obj_json->Insert("trainingData", @training_data->ToJson())

			return tuning_task_obj_json;
		}

		#~
		JSON string representation of the instance
		@return JSON string representation of the instance
		~#
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}

	#~
	Dataset for training or validation
	~#
	class Dataset implements Stringify {
		@examples : Vector<TuningExample>;

		#~
		Constructor
		~#
		New() {
			Parent();
			
			@examples := Vector->New()<TuningExample>;
		}

		#~
		Adds a training example
		@param example training example to add
		~#
		method : public : AddExample(example : TuningExample) ~ Nil {
			@examples->AddBack(example);
		}

		#~
		Gets training examples
		@return training examples
		~#
		method : public : GetExamples() ~  Vector<TuningExample> {
			return @examples;
		}

		#~
		JSON representation of the instance
		@return JSON representation of the instance
		~#
		method : public : ToJson() ~ JsonElement {
			examples_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);

			each(example in @examples) {
				examples_array_json->Add(example->ToJson());
			};

			examples_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			examples_obj_json->Insert("examples", examples_array_json)

			dataset_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			dataset_json->Insert("examples", examples_obj_json)


			return dataset_json;
		}

		#~
		JSON string representation of the instance
		@return JSON string representation of the instance
		~#
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}

	#~
	Single tuning example
	~#
	class TuningExample implements Stringify {
		@text_input : String;
		@output : String;

		#~
		Constructor
		@param text_input text model input
		@param output expected model output
		~#
		New(text_input : String, output : String) {
			Parent();
			
			@text_input := text_input;
			@output := output;
		}

		#~
		Get text model input
		@return text input
		~#
		method : public : GetTextInput() ~ String {
			return @text_input;
		}

		#~
		Get expected model output
		@return expected model output
		~#
		method : public : GetOutput() ~ String {
			return @output;
		}

		#~
		JSON representation of the instance
		@return JSON representation of the instance
		~#
		method : public : ToJson() ~ JsonElement {
			tuning_example_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			tuning_example_json->Insert("textInput", @text_input);
			tuning_example_json->Insert("output", @output);
			
			return tuning_example_json;
		}

		#~
		JSON string representation of the instance
		@return JSON string representation of the instance
		~#
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}

	#~
	Hyperparameters controlling the tuning process
	~#
	class Hyperparameters implements Stringify {
		@batch_size : Int;
		@learning_rate : Float;
		@epoch_count : Int;
		@learning_rate_multiplier : Float;

		#~
		Constructor
		@param batch_size the batch size hyperparameter for tuning
		@param learning_rate the learning rate hyperparameter for tuning
		@param epoch_count number of training epochs
		~#
		New(batch_size : Int, learning_rate : Float, epoch_count : Int) {
			Parent();
			
			@batch_size := batch_size;
			@learning_rate := learning_rate;
			@epoch_count := epoch_count;
			@learning_rate_multiplier := -1.0;
		}

		#~
		Constructor
		@param batch_size batch size hyperparameter for tuning
		@param learning_rate learning rate hyperparameter for tuning
		@param epoch_count number of training epochs
		@param learning_rate_multiplier learning rate multiplier is used to calculate a final learningrate based on the default (recommended) value
		~#
		New(batch_size : Int, learning_rate : Float, epoch_count : Int, learning_rate_multiplier : Float) {
			Parent();
			
			@batch_size := batch_size;
			@learning_rate := learning_rate;
			@epoch_count := epoch_count;
			@learning_rate_multiplier := learning_rate_multiplier;
		}

		#~
		Get the batch size hyperparameter for tuning
		@return batch size hyperparameter for tuning
		~#
		method : public : GetBatchSize() ~ Int {
			return @batch_size;
		}

		#~
		Get the learning rate hyperparameter for tuning
		@return learning rate hyperparameter for tuning
		~#
		method : public : GetLearningRate() ~ Float {
			return @learning_rate;
		}

		#~
		Get the number of training epochs
		@return number of training epochs
		~#
		method : public : GetEpochCount() ~ Int {
			return @epoch_count;
		}

		#~
		Get the learning rate multiplier
		@return learning rate multiplier
		~#
		method : public : GetLearningRateMultiplier() ~ Float {
			return @learning_rate_multiplier;
		}

		#~
		JSON representation of the instance
		@return JSON representation of the instance
		~#
		method : public : ToJson() ~ JsonElement {
			hyper_param_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			hyper_param_json->Insert("batchSize", @batch_size);
			hyper_param_json->Insert("learningRate", @learning_rate);
			hyper_param_json->Insert("epochCount", @epoch_count);

			if(@learning_rate_multiplier > 0.0) {
				hyper_param_json->Insert("learningRateMultiplier", @learning_rate_multiplier);
			};

			return hyper_param_json;
		}

		#~
		JSON string representation of the instance
		@return JSON string representation of the instance
		~#
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}
}

#~
Google Gemini corpus APIs (-lib gemini)
~#
bundle API.Google.Gemini.Corpus {
	#~
	Google Gemini corpus

```
# clean up
corpuses := Corpus->List();
each(corpus in corpuses) {
  documents := Document->List(corpus);
  each(document in documents) {
    chunks := Chunk->List(document);
    each(chunk in chunks) {
      chunk->Delete()->PrintLine();
    };
    document->Delete()->PrintLine();
  };
  corpus->Delete()->PrintLine();
};

# corups
corpus := Corpus->Create("Corpus 1");

metadata := Map->New()<String, String>;
metadata->Insert("about", "fruit, vegetable, vehicle, human, and animal");
document := Document->Create("Document 1", metadata, corpus);

metadata := Map->New()<String, String>;
metadata->Insert("category", "fruit");
Chunk->Create("Nature's candy! Seeds' sweet ride to spread, bursting with colors, sugars, and vitamins. Fuel for us, future for plants. Deliciously vital!", metadata, document)->ToString()->PrintLine();

metadata := Map->New()<String, String>;
metadata->Insert("category", "vegetable");
Chunk->Create("Not just leaves! Veggies sprout from roots, stems, flowers, and even bulbs. Packed with vitamins, minerals, and fiber galore, they fuel our bodies and keep us wanting more.", metadata, document)->ToString()->PrintLine();

metadata := Map->New()<String, String>;
metadata->Insert("category", "vehicle");
Chunk->Create("Metal chariots or whirring steeds, gliding on land, skimming seas, piercing clouds. Carrying souls near and far, vehicles weave paths for dreams and scars.", metadata, document)->ToString()->PrintLine();

metadata := Map->New()<String, String>;
metadata->Insert("category", "human");
Chunk->Create("Walking contradictions, minds aflame, built for laughter, prone to shame. Woven from stardust, shaped by clay, seeking answers, paving the way.", metadata, document)->ToString()->PrintLine();

metadata := Map->New()<String, String>;
metadata->Insert("category", "animal");
Chunk->Create("Sentient dance beneath the sun, from buzzing flies to whales that run. Flesh and feather, scale and claw, weaving instincts in nature's law. ", metadata, document)->ToString()->PrintLine();

metadata := Map->New()<String, String>;
metadata->Insert("category", "other");
Chunk->Create("Except for fruit, vegetable, vehicle, human, and animal", metadata, document)->ToString()->PrintLine();

# search
results := document->Query(query);
each(result in results) {
  relevance := result->GetFirst()->As(FloatRef);
  metadata := result->GetThird()->As(Map<String, String>);

  relevance->PrintLine();
  metadata->ToString()->PrintLine();
  "---"->PrintLine();
}
```	
	~#
	class Corpus from OAuthEndPoint implements Stringify {
		@name : String;
		@display_name : String;
		@create_time_str : String;
		@update_time_str : String;

		#~
		Get corpus ID
		@return corpus ID
		~#
		method : public : GetId() ~ String {
			return @name;
		}

		#~
		Get the display name
		@return display name
		~#
		method : public : GetName() ~ String {
			return @display_name;
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		New : private(request_json : JsonElement) {
			Parent();

			@name := request_json->Get("name")->GetString();
			@display_name := request_json->Get("displayName")->GetString();
			@create_time_str := request_json->Get("createTime")->GetString();
			@update_time_str := request_json->Get("updateTime")->GetString();
		}

		#~
		Create a new corpus
		@param name corpus name
		@return new corpus
		~#
		function : Create(name : String) ~ Corpus {
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("displayName", name);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/corpora"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Corpus->New(response_json);
			};

			return Nil;	
		}

		#~
		Get existing corpus
		@param name corpus name
		@return existing corpus
		~#
		function : Get(name : String) ~ Corpus {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
				"application/json", headers);

			if(response <> Nil) {
				#response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Corpus->New(response_json);
			};

			return Nil;	
		}
		
		#~
		Delete existing corpus
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), "application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		Query the corpus
		@param query string query
		@return query results as triple, 1) relevance, 2) string content, 3) content metadata
		~#
		method : public : Query(query : String) ~ Vector<Collection.Tuple.Triplet<FloatRef, String, Map<String, String>>> {
			# TODO metadata filters
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("query", query);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}:query"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				# process results
				relevance_results := Vector->New()<Collection.Tuple.Triplet<FloatRef, String, Map<String, String>>>;
				chunks_array_json := response_json->Get("relevantChunks");;
				each(chunk_json in chunks_array_json) {
					relevance_score := chunk_json->Get("chunkRelevanceScore")->GetFloat();
					relevance_data := Url->Decode(chunk_json->FindElements("chunk/data/stringValue")->ToString());

					relevance_metadata := Map->New()<String, String>;
					metadata_array_json := chunk_json->FindElements("chunk/customMetadata");
					each(metadata_obj_json in metadata_array_json) {
						key := metadata_obj_json->Get("key")->GetString();
						value := metadata_obj_json->Get("stringValue")->GetString();

						relevance_metadata->Insert(key, value);
					}

					result := Collection.Tuple.Triplet->New(relevance_score, relevance_data, relevance_metadata)<FloatRef, String, Map<String, String>>;
					relevance_results->AddBack(result);
				};

				return relevance_results;
			};

			return Nil;	
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";
			buffer += @name;

			buffer += "', display_name='"
			buffer += @display_name;

			buffer += "', create_time_str='"
			buffer += @create_time_str;

			buffer += "', update_time_str='"
			buffer += @update_time_str;

			buffer += "']";
			return buffer;
		}
	}

	#~
	Google Gemini document
	~#
	class Document from OAuthEndPoint implements Stringify {
		@name : String;
		@display_name : String;
		@create_time_str : String;
		@update_time_str : String;

		New : private(request_json : JsonElement) {
			Parent();

			@name := request_json->Get("name")->GetString();
			@display_name := request_json->Get("displayName")->GetString();
			@create_time_str := request_json->Get("createTime")->GetString();
			@update_time_str := request_json->Get("updateTime")->GetString();
		}

		#~
		Get document ID
		@return document ID
		~#
		method : public : GetId() ~ String {
			return @name;
		}

		#~
		Get the display name
		@return display name
		~#
		method : public : GetName() ~ String {
			return @display_name;
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Query the corpus
		@param query string query
		@return query results as triple, 1) relevance, 2) string content, 3) content metadata
		~#
		method : public : Query(query : String) ~ Vector<Collection.Tuple.Triplet<FloatRef, String, Map<String, String>>> {
			# TODO metadata filters
			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("query", query);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}:query"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				# process results
				relevance_results := Vector->New()<Collection.Tuple.Triplet<FloatRef, String, Map<String, String>>>;
				chunks_array_json := response_json->Get("relevantChunks");;
				each(chunk_json in chunks_array_json) {
					relevance_score := chunk_json->Get("chunkRelevanceScore")->GetFloat();
					relevance_data := Url->Decode(chunk_json->FindElements("chunk/data/stringValue")->ToString());

					relevance_metadata := Map->New()<String, String>;
					metadata_array_json := chunk_json->FindElements("chunk/customMetadata");
					each(metadata_obj_json in metadata_array_json) {
						key := metadata_obj_json->Get("key")->GetString();
						value := metadata_obj_json->Get("stringValue")->GetString();

						relevance_metadata->Insert(key, value);
					}

					result := Collection.Tuple.Triplet->New(relevance_score, relevance_data, relevance_metadata)<FloatRef, String, Map<String, String>>;
					relevance_results->AddBack(result);
				};

				return relevance_results;
			};

			return Nil;	
		}

		#~
		Create a new document
		@param name document name
		@param metadata document metadata
		@param corpus corpus to attach document
		@return new Document
		~#
		function : Create(name : String, metadata : Collection.Map<String, String>, corpus : Corpus) ~ Document {
			metadata_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			if(metadata <> Nil) {
				metadata_keys_values := metadata->GetKeyValues()<Pair<String, String>>;
				each(metadata_key_value in metadata_keys_values) {
					metadata_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					metadata_json->Insert("key", metadata_key_value->GetFirst());
					metadata_json->Insert("stringValue", metadata_key_value->GetSecond());

					metadata_array_json->Add(metadata_json);
				};
			};

			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("displayName", name);
			request_json->Insert("customMetadata", metadata_array_json);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			corpora_id := corpus->GetId();
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$corpora_id}/documents"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Document->New(response_json);
			};

			return Nil;	
		}

		#~
		Get existing document
		@param name document name
		@return existing document
		~#
		function : Get(name : String) ~ Document {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
				"application/json", headers);

			if(response <> Nil) {
				#response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Document->New(response_json);
			};

			return Nil;	
		}

		#~
		Get all existing documents
		@param corpus corpus of documents to list
		@return list of documents
		~#
		function : List(corpus : Corpus) ~ Collection.Vector<Document> {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");

			corpora_id := corpus->GetId();
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$corpora_id}/documents"), 
				"application/json", headers);

			if(response <> Nil) {
				
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				corpuses := Collection.Vector->New()<Document>;
				
				next_page_json : JsonElement;
				do {
					# load next page, if it exists
					if(next_page_json <> Nil) {
						next_page_str := "?pageToken=";
						next_page_str += next_page_json->GetString();

						url_str := "https://generativelanguage.googleapis.com/v1beta/tunedModels" + next_page_str;
						response := HttpsClient->QuickGet(Url->New(url_str), "application/json", headers);
						if(response = Nil) {
							return Nil;
						}
						else {
							# response->GetContent()->ToString()->PrintLine();
							response_json := JsonParser->TextToElement(response->GetContent()->ToString());
							if(response_json = Nil) {
								"### Error: Unable to parse response ###"->ErrorLine();
								return Nil;
							};
							
							if(response_json->Has("error")) {
								error_str := response_json->FindElements("error/message")->GetString();
								SetLastError(error_str);
								return Nil;
							};
						};
					};

					corporas_json := response_json->Get("documents");
					if(corporas_json <> Nil) {
						each(corpora_json in corporas_json) {
							corpuses->AddBack(Document->New(corpora_json));
						};
					};

					next_page_json := response_json->Get("nextPageToken");
				}
				while(next_page_json <> Nil);

				return corpuses;
			};

			return Nil;	
		}

		#~
		Delete existing document
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), 
				"application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";
			buffer += @name;

			buffer += "', display_name='"
			buffer += @display_name;

			buffer += "', create_time_str='"
			buffer += @create_time_str;

			buffer += "', update_time_str='"
			buffer += @update_time_str;

			buffer += "']";
			return buffer;
		}
	}

	#~
	Google Gemini document chunk
	~#
	class Chunk from OAuthEndPoint implements Stringify {
		@name : String;
		@data : String;
		@state : String;
		@create_time_str : String;
		@update_time_str : String;
		@metadata : Map<String, String>;

		New : private(request_json : JsonElement) {
			Parent();

			@name := request_json->Get("name")->GetString();
			@data := request_json->FindElements("data/stringValue")->GetString();
			@state := request_json->Get("state")->GetString();
			@create_time_str := request_json->Get("createTime")->GetString();
			@update_time_str := request_json->Get("updateTime")->GetString();

			@metadata := Map->New()<String, String>;
			metadata_array_json := request_json->Get("customMetadata");
			if(metadata_array_json <> Nil) {
				each(metadata_json in metadata_array_json) {
					name := metadata_json->Get("key")->GetString();
					value := metadata_json->Get("stringValue")->GetString();
					@metadata->Insert(name, value);
				};
			};
		}

		#~
		Get chunk ID
		@return chunk ID
		~#
		method : public : GetId() ~ String {
			return @name;
		}

		method : public : GetData() ~ String {
			return @data;
		}

		method : public : GetState() ~ String {
			return @state;
		}

		method : public : GetMetadata() ~  Map<String, String> {
			return @metadata;
		}

		#~
		Get creation time
		@return creation time
		~#
		method : public : GetCreateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@create_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Get update time
		@return update time
		~#
		method : public : GetUpdateTime() ~ System.Time.Date {
			return System.Time.DateUtility->Parse(@update_time_str, "yyyy-MM-ddThh:mm:ss", false);
		}

		#~
		Create a new document
		@param value check string value
		@param metadata document metadata
		@param document document to attach chunk
		@return new Document
		~#
		function : Create(value : String, metadata : Map<String, String>, document : Document) ~ Chunk {
			metadata_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
			if(metadata <> Nil) {
				metadata_keys_values := metadata->GetKeyValues()<Pair<String, String>>;
				each(metadata_key_value in metadata_keys_values) {
					metadata_json := JsonElement->New(JsonElement->JsonType->OBJECT);
					metadata_json->Insert("key", metadata_key_value->GetFirst());
					metadata_json->Insert("stringValue", metadata_key_value->GetSecond());

					metadata_array_json->Add(metadata_json);
				};
			};

			request_data_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_data_json->Insert("stringValue", value);

			request_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			request_json->Insert("data", request_data_json);
			
			request_json->Insert("customMetadata", metadata_array_json);
			data := request_json->ToString()->ToByteArray();
			# data->ToString()->PrintLine();

			doc_id := document->GetId();
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickPost(Url->New("https://generativelanguage.googleapis.com/v1beta/{$doc_id}/chunks"), data, 
				"application/json", headers);

			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Chunk->New(response_json);
			};

			return Nil;
		}

		#~
		Get existing chunk
		@param name chunk name
		@return existing chunk
		~#
		function : Get(name : String) ~ Chunk {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$name}"), 
				"application/json", headers);

			if(response <> Nil) {
				#response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				return Chunk->New(response_json);
			};

			return Nil;	
		}

		#~
		Delete existing chunk
		@return true if successful, false otherwise
		~#
		method : public : Delete() ~ Bool {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");
			response := HttpsClient->QuickDelete(Url->New("https://generativelanguage.googleapis.com/v1beta/{$@name}"), 
				"application/json", headers);
			
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return false;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return false;
				};

				return true;
			};

			return false;	
		}

		#~
		Get all existing chunks
		@param document document of documents to list
		@return list of chunks
		~#
		function : List(document : Document) ~ Collection.Vector<Chunk> {
			token := GetToken();
			headers := Collection.Map->New()<String, String>;
			headers->Insert("Authorization", "Bearer {$token}");

			doc_id := document->GetId();
			response := HttpsClient->QuickGet(Url->New("https://generativelanguage.googleapis.com/v1beta/{$doc_id}/chunks"), "application/json", headers);
			if(response <> Nil) {
				# response->GetContent()->ToString()->PrintLine();
				
				response_json := JsonParser->TextToElement(response->GetContent()->ToString());
				if(response_json = Nil) {
					"### Error: Unable to parse response ###"->ErrorLine();
					return Nil;
				};
				
				if(response_json->Has("error")) {
					error_str := response_json->FindElements("error/message")->GetString();
					SetLastError(error_str);
					return Nil;
				};

				corpuses := Collection.Vector->New()<Chunk>;
				
				next_page_json : JsonElement;
				do {
					# load next page, if it exists
					if(next_page_json <> Nil) {
						next_page_str := "?pageToken=";
						next_page_str += next_page_json->GetString();

						url_str := "https://generativelanguage.googleapis.com/v1beta/tunedModels" + next_page_str;
						response := HttpsClient->QuickGet(Url->New(url_str), "application/json", headers);
						if(response = Nil) {
							return Nil;
						}
						else {
							# response->GetContent()->ToString()->PrintLine();
							response_json := JsonParser->TextToElement(response->GetContent()->ToString());
							if(response_json = Nil) {
								"### Error: Unable to parse response ###"->ErrorLine();
								return Nil;
							};
							
							if(response_json->Has("error")) {
								error_str := response_json->FindElements("error/message")->GetString();
								SetLastError(error_str);
								return Nil;
							};
						};
					};

					corporas_json := response_json->Get("chunks");
					if(corporas_json <> Nil) {
						each(corpora_json in corporas_json) {
							corpuses->AddBack(Chunk->New(corpora_json));
						};
					};

					next_page_json := response_json->Get("nextPageToken");
				}
				while(next_page_json <> Nil);

				return corpuses;
			};

			return Nil;	
		}

		#~
		String representation of the object
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[name='";
			buffer += @name;

			buffer += "', state='"
			buffer += @state;

			buffer += "', data='"
			buffer += @data;

			buffer += "', create_time_str='"
			buffer += @create_time_str;

			buffer += "', update_time_str='"
			buffer += @update_time_str;

			buffer += "']";
			return buffer;
		}
	}
}
