#~~
Objeck 2D gaming support
Copyright (c) 2018-2020 Randy Hollines
~~#

use Game.SDL2;
use Collection;
use Data.JSON;

#~
2D gaming framework that uses SDL2 (-lib sdl_game)
~#
bundle Game.Framework {
	#~
	Animated sprite sheet
	~#
	class AnimatedImageSprite from ImageSprite {
		@clips : Vector<Rect>;
		
		New(renderer : Renderer, file : String, clips : Vector<Rect>) {
			Parent(renderer, file);
			if(@is_ok) {
				@clips := clips;
			};
		}

		New(renderer : Renderer, file : String) {
			Parent(renderer, file);
			if(@is_ok) {
				@clips := Vector->New()<Rect>;
			};
		}

		#~
		Renders sprite
		@param x x-position
		@param y y-position
		@param index sprite image index
		~#
		method : public : Render(x : Int, y : Int, index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clips->Size()) {
				@clip := @clips->Get(index);
				RenderAll(x, y, @clip, @angle, Nil, @flip);
			};
		}

		#~
		Renders sprite
		@param index sprite image index
		~#
		method : public : Render(index : Int) ~ Nil {
			if(@is_ok & index > -1 & index < @clips->Size()) {
				@clip := @clips->Get(index);
				RenderAll(@position->GetLeft(), @position->GetTop(), @clip, @angle, Nil, @flip);
			};
		}

		#~
		Adds a clip
		@param clip clip
		~#
		method : public : AddClip(clip : Rect) ~ Nil {
			@clips->AddBack(clip);
		}
		
		#~
		Adds clips
		@param num_x_clips number of x-clips
		@param x_clip_size x size of clips
		@param num_y_clips number of y-clips
		@param y_clip_size y size of clips
		~#
		method : public : AddClips(num_x_clips : Int, x_clip_size : Int, num_y_clips : Int, y_clip_size : Int) ~ Nil {
			for(i := 0; i < num_y_clips; i += 1;) {
				for(j := 0; j < num_x_clips; j += 1;) {
					@clips->AddBack(Rect->New(j * x_clip_size, i * y_clip_size, x_clip_size, x_clip_size));
				};
			};
		}

		#~
		Get number of clips used in the sprite sheet
		@return number of clips
		~#
		method : public : GetClipCount() ~ Int {
			return @clips->Size();
		}
	}

	#~
	Titled image sprite
	~#
	class TitledImageSprite implements Shape {
		@texture : Texture;
		@renderer : Renderer;
		@is_ok : Bool;
		@x : Int;
		@y : Int;
		@width : Int;
		@height : Int;
		@shapes : List<Shape>;

		New(renderer : Renderer, file : String, colorkey : Color) {
			@renderer := renderer;
			@shapes := List->New()<Shape>;

			@is_ok := LoadImage(file, colorkey);
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		#~
		Destroys and frees sprite resources
		~#
		method : public : Free() ~ Nil {
			if(@texture <> Nil)	{
				@texture->Destroy();
			};

			@shapes->Empty();
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @width;
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @height;
		}

		#~
		Gets relative sprite positions from original creation
		@return relative sprite position
		~#
		method : public : GetPosition() ~ Position {
			return Position->New(@x, @y, @width, @height);
		}

		#~
		Loads an image
		@param file image to load
		@param colorkey key color
		@return true if success, false otherwise
		~#
		method : LoadImage(file : String, colorkey : Color) ~ Bool {
			Free();
			
			surface := Image->Load(file);
			if(surface->IsNull()) {
			# "Unable to load image '{$file}'!"->ErrorLine();
				return false;
			};

			if(colorkey <> Nil) {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(colorkey->GetR(), colorkey->GetG(), colorkey->GetB()));
			}
			else {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(0, 0xFF, 0xFF));
			};

			texture := surface->CreateTexture(@renderer);
			if(texture->IsNull()) {
			# "Unable to create texture from '{$file}'!"->ErrorLine();
				return false;
			};

			@width := surface->GetW();
			@height := surface->GetH();
			
			surface->Free();
			@texture := texture;
			return @texture <> Nil;
		}

		#~
		Adds a tile at the specified location
		@param x x coordinate
		@param y y coordinate
		@return image sprite
		~#
		method : public : AddTile(x : Int, y : Int) ~ ImageSprite {
			sprite := ImageSprite->New(@renderer, @texture);
			sprite->SetPostion(Position->New(x, y, @width, @height));
			@shapes->AddBack(sprite);

			return sprite;
		}

		#~
		Removes sprite
		@param sprite sprite to remove
		@return true if found and removed, false otherwise
		~#
		method : public : RemoveTile(sprite : ImageSprite) ~ Bool {
			@shapes->Rewind();
			while(@shapes->More()) {
				shape := @shapes->Get()->As(ImageSprite);
				if(sprite = shape) {
					@shapes->Remove();
					return true;
				};
				@shapes->Next();
			};

			return false;
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			if(@is_ok) {	
				@shapes->Rewind();
				while(@shapes->More()) {
					shape := @shapes->Get()->As(ImageSprite);
					shape->GetPosition()->AddX(x);
					@x += x;
					@shapes->Next();
				};
			};
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			if(@is_ok) {	
				@shapes->Rewind();
				while(@shapes->More()) {
					shape := @shapes->Get()->As(ImageSprite);
					shape->GetPosition()->AddY(y);
					@y += y;
					@shapes->Next();
				};
			};
		}

		#~
		Renders an images based upon position instances
		~#
		method : public : Render() ~ Nil {
			if(@is_ok) {	
				@shapes->Rewind();
				while(@shapes->More()) {
					shape := @shapes->Get()->As(ImageSprite);
					shape->Render();
					@shapes->Next();
				};
			};
		}
	}

	#~
	Sprite image
	~#
	class ImageSprite from Sprite {
		@is_ok : Bool;
		@clip : Rect;
		@angle : Float;
		@flip : RendererFlip;

		New(renderer : Renderer, file : String, colorkey : Color, clip : Rect) {
			Parent(renderer);
			@clip := clip;
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, colorkey);
		}

		New(renderer : Renderer, file : String, colorkey : Color) {
			Parent(renderer);
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, colorkey);
		}

		New(renderer : Renderer, file : String) {
			Parent(renderer);
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
			@is_ok := LoadImage(file, Nil);
		}

		New(renderer : Renderer, texture : Texture) {
			Parent(renderer);
			@texture := texture;
			@is_ok := true;
			@angle := 0.0;
			@flip := RendererFlip->SDL_FLIP_NONE;
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		#~
		Loads an image
		@param file image to load
		@param colorkey key color
		@return true if success, false otherwise
		~#
		method : LoadImage(file : String, colorkey : Color) ~ Bool {
			Free();
			
			surface := Image->Load(file);
			if(surface->IsNull()) {
			# "Unable to load image '{$file}'!"->ErrorLine();
				return false;
			};

			if(colorkey <> Nil) {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(colorkey->GetR(), colorkey->GetG(), colorkey->GetB()));
			}
			else {
				surface->SetColorKey(true, surface->GetPixelFormat()->MapRGB(0, 0xFF, 0xFF));
			};

			texture := surface->CreateTexture(@renderer);
			if(texture->IsNull()) {
			# "Unable to create texture from '{$file}'!"->ErrorLine();
				return false;
			};

			@render_rect->SetW(surface->GetW());
			@render_rect->SetH(surface->GetH());
			
			surface->Free();
			@texture := texture;
			return @texture <> Nil;
		}

		#~
		Sets the image angle
		@param angle image angle
		~#
		method : public : SetAngle(angle : Float) ~ Nil {
			@angle := angle;
		}

		#~
		Gets the image angle
		@return image angle
		~#
		method : public : GetAngle() ~ Float {
			return @angle;
		}

		#~
		Sets flip of image
		@param flip direction to flip
		~#
		method : public : SetFlip(flip : RendererFlip) ~ Nil {
			@flip := flip;
		}

		#~
		Gets image flip
		@return direction to flip
		~#
		method : public : GetFlip() ~ RendererFlip {
			return @flip;
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y, Nil, @angle, Nil, @flip);
			};
		}

		#~
		Renders an image based upon position instance
		~#
		method : public : Render() ~ Nil {
			RenderAll(@position->GetLeft(), @position->GetTop(), @clip, @angle, Nil, @flip);
		}
	}

	#~
	Rendered TTF text
	~#
	class TextSprite from Sprite {
		@font : Font;
		@color : Color;
		@is_ok : Bool;

		New(renderer : Renderer, font : Font) {
			Parent(renderer);
			@font := font;
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		#~
		Sets the text font
		@param font TTF
		~#
		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}		

		#~
		Sets the text color
		@param color text color
		~#
		method : public : SetColor(color : Color) ~ Nil {
			@color := color;
		}

		#~
		Renders the set text
		@param text text to render
		~#
		method : public : RenderedText(text : String) ~ Nil {
			RenderedText(text, @color);
		}

		#~
		Renders the set text
		@param text text to render
		@param color color of text
		~#
		method : public : RenderedText(text : String, color : Color) ~ Nil {
			if(@font <> Nil) {
				Free();

				if(color = Nil) {
					color := Color->New(32, 32, 32);
				};

				# Render text surface
				text_surface := @font->RenderTextSolid(text, color);
				if(text_surface->IsNull()) {
				# "Unable to render text surface!"->ErrorLine();
					@is_ok := false;
				};

				texture := text_surface->CreateTexture(@renderer);
				@render_rect->SetW(text_surface->GetW());
				@render_rect->SetH(text_surface->GetH());
				text_surface->Free();
				
				@texture := texture;
				@is_ok := @texture <> Nil;
			}
			else {
				@is_ok := false;
			};
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@is_ok) {
				RenderAll(x, y);
			};
		}
	}

	#~
	Bitmap sprite
	~#
	class Sprite implements Shape {
		@texture : Texture;
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;
		@scale : Float;
		@scaled : Bool;

		New(renderer : Renderer) {			
			@renderer := renderer;			
			@render_rect := Rect->New();
			@position := Position->New(@render_rect);
			@scale := 1.0;
		}
		
		#~
		Sets scaling percentage 
		@param scale scaling percentage 
		~#
		method : public : SetScale(scale : Float) ~ Nil {
			@scale := scale;
			@scaled := false;
		}

		#~
		Gets scaling percentage 
		@return scaling percentage 
		~#
		method : public : GetScale() ~ Float {
			return @scale;
		}

		#~
		Sets the current x-position
		@param position new position
		~#
		method : public : SetPostion(position : Position) ~ Nil {
			@position := position;
		}

		#~
		Destroys and frees sprite resources
		~#
		method : public : Free() ~ Nil {
			if(@texture <> Nil)	{
				@texture->Destroy();
				@render_rect->SetX(0);
				@render_rect->SetY(0);
			};
		}

		#~
		Sets the color
		@param red red
		@param green green
		@param blue blue
		~#
		method : public : SetColor(red : Int, green : Int, blue : Int) ~ Nil {
			@texture->SetColorMod(red, green, blue);
		}

		#~
		Sets blend mode
		@param blending blend mode
		~#
		method : public : SetBlendMode(blending : BlendMode) ~ Nil {
			@texture->SetBlendMode(blending);
		}

		#~
		Sets alpha
		@param alpha setting
		~#		
		method : public : SetAlpha(alpha : Int) ~ Nil {
			@texture->SetAlphaMod(alpha );
		}

		method : RenderAll(x : Int, y : Int, clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			@render_rect->SetX(x);
			@render_rect->SetY(y);
			
			if(<>@scaled) {
				format := IntRef->New();
				access := IntRef->New();
				width := IntRef->New();
				height := IntRef->New();
				@texture->Query(format, access, width, height);
				@render_rect->SetW(width->Get() * @scale);
				@render_rect->SetH(height->Get() * @scale);
				@scaled := true;
			};

			if(clip <> Nil)	{
				@render_rect->SetW(clip->GetW() * @scale);
				@render_rect->SetH(clip->GetH() * @scale);
			};

			@renderer->CopyEx(@texture, clip, @render_rect, angle, center, flip);
		}

		#~
		Renders sprite
		@param x x position
		@param y y position
		@param clip clipping rectangle
		@param angle clipping rectangle
		@param center center point
		@param flip flip direction
		~#
		method : public : Render(x : Int, y : Int, clip : Rect := Nil, angle : Float := 0.0, 
				center : Point := Nil, flip : RendererFlip := RendererFlip->SDL_FLIP_NONE) ~ Nil {
			RenderAll(x, y, clip, angle, center, flip);
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : GetPosition() ~ Position {
			return @position;
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @position->GetLeft();
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @position->GetTop();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @position->GetRight();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @position->GetBottom();
		}

		#~
		Gets the center x-position
		@return center x-position
		~#
		method : public : GetCenterX() ~ Int {
			return @position->GetCenterX();
		}

		#~
		Gets the center y-position
		@return center y-position
		~#
		method : public : GetCenterY() ~ Int {
			return @position->GetCenterY();
		}

		#~
		Sets upper left position
		@param x x-position 
		@param y y-position 
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		#~
		Sets cener position
		@param x x-position 
		@param y y-position 
		~#
		method : public : SetCenter(x : Int, y : Int) ~ Nil {
			@position->SetCenter(x, y);
		}

		#~
		Sets position
		@param v2 vector position 
		~#
		method : public : Set(v2 : Vector2) ~ Nil {
			@position->Set(v2->GetX(), v2->GetY());
		}

		#~
		Sets left position
		@param x left position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@position->SetLeft(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@position->SetTop(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@position->SetRight(x2);
		}
		
		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@position->SetBottom(y2);
		}

		#~
		Sets center x-position
		@param x center x-position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@position->SetCenterX(x);
		}
		
		#~
		Sets center y-position
		@param y center y-position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@position->SetCenterY(y);
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@position->AddX(x);
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@position->AddY(y);
		}
	}

	#~
	Rectangle shape
	~#
	class Rectangle implements Shape {
		@render_rect : Rect;
		@position : Position;
		@renderer : Renderer;
		@color : Color;
		@fill : Bool;

		New(renderer : Renderer, w : Int, h : Int) {
			@renderer := renderer;
			@render_rect := Rect->New(w, h);
			@position := Position->New(@render_rect);
		}

		#~
		Sets the current x-position
		@param position new position
		~#
		method : public : SetPostion(position : Position) ~ Nil {
			@position := position;
		}

		method : public : Free() ~ Nil {			
		}

		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : GetWidth() ~ Int {
			return @render_rect->GetW();
		}

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : GetHeight() ~ Int {
			return @render_rect->GetH();
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @position->GetLeft();
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @position->GetTop();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @position->GetRight();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @position->GetBottom();
		}

		#~
		Gets the center x-position
		@return center x-position
		~#
		method : public : GetCenterX() ~ Int {
			return @position->GetCenterX();
		}

		method : public : GetCenterY() ~ Int {
			return @position->GetCenterY();
		}

		#~
		Sets center y-position
		@param x center y-position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@position->SetCenterX(x);
		}
		
		#~
		Sets center y-position
		@param y center y-position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@position->SetCenterY(y);
		}

		#~
		Sets left upper position
		@param x x-position 
		@param y y-position 
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@position->Set(x, y);
		}

		#~
		Sets center position
		@param x x-position 
		@param y y-position 
		~#
		method : public : SetCenter(x : Int, y : Int) ~ Nil {
			@position->SetCenter(x, y);
		}

		#~
		Sets position
		@param v2 vector position 
		~#
		method : public : Set(v2 : Vector2) ~ Nil {
			@position->Set(v2->GetX(), v2->GetY());
		}

		#~
		Sets left position
		@param x left position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@position->SetLeft(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@position->SetTop(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@position->SetRight(x2);
		}

		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@position->SetBottom(y2);
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@position->AddX(x);
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@position->AddY(y);
		}

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : GetPosition() ~ Position {
			return @position;
		}

		#~
		Sets rectangle color
		@param color color
		~#
		method : public : SetColor(color : Color) ~ Nil {
			@color := color;
		}

		#~
		Gets rectangle color
		@return color
		~#
		method : public : GetColor() ~ Color {
			return @color;
		}

		#~
		Sets color fill
		@param fill if true, color fills rectangle; false otherwise
		~#
		method : public : SetFill(fill : Bool) ~ Nil {
			@fill := fill;
		}

		#~
		Sets color fill
		@return if true, color fills rectangle; false otherwise
		~#
		method : public : GetFill() ~ Bool {
			return @fill;
		}

		#~
		Renders an image based upon position instance
		~#
		method : public : Render() ~ Nil {
			Render(@position->GetLeft(), @position->GetTop());
		}

		#~
		Renders an image
		@param x x-position
		@param y y-position
		~#
		method : public : Render(x : Int, y : Int) ~ Nil {
			if(@color = Nil) {
				@color := Color->New();
			};

			@render_rect->SetX(x);
			@render_rect->SetY(y);
			@renderer->SetDrawColor(@color->GetR(), @color->GetG(), @color->GetB(), @color->GetA());

			if(@fill) {
				@renderer->FillRect(@render_rect);
			}
			else {
				@renderer->DrawRect(@render_rect);
			};
		}
	}
	
	#~
	Shape position
	~#
	class Position {
		@rect : Rect;
		
		#~
		Creates a new rectangle with given size
		@param rect position
		~#
		New(rect : Rect) {
			@rect := rect;
		}

		#~
		Creates a new rectangle with given position and size
		@param x x-position
		@param y y-position
		@param w width
		@param h height
		~#
		New(x : Int, y : Int, w : Int, h : Int) {
			@rect := Rect->New(x, y, w, h);
		}

		#~
		Creates a new rectangle with given size
		@param w width
		@param h height
		~#
		New(w : Int, h : Int) {
			@rect := Rect->New(0, 0, w, h);
		}

		#~
		Gets bounding size
		@return size and rectangle
		~#
		method : public : GetRect() ~ Rect {
			return @rect;
		}

		#~
		Set upper left position
		@param x x-position
		@param y y-position
		~#
		method : public : Set(x : Int, y : Int) ~ Nil {
			@rect->SetX(x);
			@rect->SetY(y);
		}

		#~
		Set center position
		@param x x-position
		@param y y-position
		~#
		method : public : SetCenter(x : Int, y : Int) ~ Nil {
			SetCenterX(x);
			SetCenterY(y);
		}

		#~
		Set center x-position
		@param x x-position
		~#
		method : public : SetCenterX(x : Int) ~ Nil {
			@rect->SetX(x - @rect->GetW() / 2);
		}
		
		#~
		Set center y-position
		@param y y-position
		~#
		method : public : SetCenterY(y : Int) ~ Nil {
			@rect->SetY(y - @rect->GetH() / 2);
		}

		#~
		Sets left position
		@param x x-position
		~#
		method : public : SetLeft(x : Int) ~ Nil {
			@rect->SetX(x);
		}

		#~
		Sets top position
		@param y top position
		~#
		method : public : SetTop(y : Int) ~ Nil {
			@rect->SetY(y);
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@rect->AddX(x);
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@rect->AddY(y);
		}

		#~
		Sets right position
		@param x2 right position
		~#
		method : public : SetRight(x2 : Int) ~ Nil {
			@rect->SetX(x2 - @rect->GetW());
		}

		#~
		Sets bottom position
		@param y2 bottom position
		~#
		method : public : SetBottom(y2 : Int) ~ Nil {
			@rect->SetY(y2 - @rect->GetH());
		}

		#~
		Gets left position
		@return left position
		~#
		method : public : GetLeft() ~ Int {
			return @rect->GetX();
		}

		#~
		Gets right position
		@return right position
		~#
		method : public : GetRight() ~ Int {
			return @rect->GetX() + @rect->GetW();
		}

		#~
		Gets the center x-position
		@return center x-position
		~#
		method : public : GetCenterX() ~ Int {
			return @rect->GetX() + @rect->GetW() / 2;
		}

		#~
		Gets top position
		@return top position
		~#
		method : public : GetTop() ~ Int {
			return @rect->GetY();
		}

		#~
		Gets bottom position
		@return bottom position
		~#
		method : public : GetBottom() ~ Int {
			return @rect->GetY() + @rect->GetH();
		}

		#~
		Gets the center y-position
		@return center y-position
		~#
		method : public : GetCenterY() ~ Int {
			return @rect->GetY() + @rect->GetH() / 2;
		}

		#~
		Calculates the distance between two points
		@param x x-position
		@param y y-position
		@return distance between the two points
		~#
		method : Distance(x : Int, y : Int) ~ Int {
			x_norm := x - GetCenterX();
			y_norm := y - GetCenterY();
			return (x_norm * x_norm + y_norm * y_norm)->ToFloat()->Sqrt();
		}
		
		#~
		Calculates the distance between two points
		@param pos position
		@return distance between the two points
		~#
		method : Distance(pos : Position) ~ Int {
			x_norm := pos->GetCenterX() - GetCenterX();
			y_norm := pos->GetCenterY() - GetCenterY();
			return (x_norm * x_norm + y_norm * y_norm)->ToFloat()->Sqrt();
		}

		#~
		Determines if position overlaps rectangle
		@param pos position to test 
		@return true of overlap, false otherwise
		~#
		method : public : native : Overlaps(pos : Position) ~ Bool {
			y := GetTop();
			pos_y2 := pos->GetBottom();

			pos_y := pos->GetTop();
			y2 := GetBottom();

			pos_x := pos->GetLeft();
			x2 := GetRight();

			x := GetLeft();
			pos_x2 := pos->GetRight();
			
			return <>(y2 <= pos_y | y >= pos_y2 | x >= pos_x2 | x2 <= pos_x);
		}

		#~
		Determines if position intersect line
		@param x1 'x' start position
		@param y1 'y' start position
		@param x2 'x' end position
		@param y2 'y' end position
		@return true of intersection, false otherwise
		~#
		method : public : IntersectsLine(x1 : Int, y1 : Int, x2 : Int, y2 : Int) ~ Bool {
			return @rect->IntersectAndLine(IntRef->New(x1), IntRef->New(y1), IntRef->New(x2), IntRef->New(y2));
		}

		#~
		Determines if position intersect point
		@param x 'x' start position
		@param y 'y' start position
		@return true of intersection, false otherwise
		~#
		method : public : IntersectsPoint(x : Int, y : Int) ~ Bool {
			return x >= GetLeft() & x <= GetRight() & y >= GetTop() & y <= GetBottom();
		}

		#~
		Determines if position intersect point
		@param p point position
		@return true of intersection, false otherwise
		~#
		method : public : IntersectsPoint(p : Point) ~ Bool {
			x := p->GetX();
			y := p->GetY();

			return x >= GetLeft() & x <= GetRight() & y >= GetTop() & y <= GetBottom();
		}

		#~
		Determines if position a point
		@param p point
		@return true of intersection, false otherwise
		~#
		method : public : Contains(p : Point) ~ Bool {
			return @rect->PointIn(p);
		}

		#~
		Determines if position a point
		@param x x-position
		@param y y-position
		@return true of intersection, false otherwise
		~#
		method : public : Contains(x : Int, y : Int) ~ Bool {
			return @rect->PointIn(Point->New(x, y));
		}
	}

	#~
	Collection shape
	~#
	interface Shape {
		#~
		Gets sprite width
		@return sprite width
		~#
		method : public : virtual : GetWidth() ~ Int;

		#~
		Gets sprite height
		@return sprite height
		~#
		method : public : virtual : GetHeight() ~ Int;

		#~
		Gets sprite position
		@return sprite position
		~#
		method : public : virtual : GetPosition() ~ Position;

		#~
		Called by framework to free resource
		~#
		method : public : virtual : Free() ~ Nil;
	}

	#~
	Game framework
	~#
	class GameFramework {
		@is_ok : Bool;
		@screen_width : Int;
		@screen_height : Int;
		@renderer : Renderer;

		@clear_color : Color;
		@frame_rate : Int;
		@fps : Int;
		@frame_start : Int;

		@shapes : Vector<Shape>;

		@colors_dict : Hash<String, Color>;
		@image_sprites_dict : Hash<String, ImageSprite>;
		@rectangles_dict : Hash<String, Rectangle>;
		@text_sprites_dict : Hash<String, TextSprite>;		

		@mix_chunks : Vector<MixChunk>;
		@chunks_dict : Hash<String, MixChunk>;
		@music : MixMusic;

		@font : Font;
		@fonts : Vector<Font>;
		@fonts_dict : Hash<String, Font>;

		@joystick : Joystick;

		@event : Event;

		@debug_msg : static : String;

		#~
		Initializes game framework
		@param screen_width screen width
		@param screen_height screen height
		@param title screen title
		@param fps frame per second
		@param init_flags initialization flags
		~#
		New(screen_width : Int, screen_height : Int, title : String, fps : Int, init_flags : Int) {
			@fps := fps;
			@frame_rate := 1000 / @fps;
			@shapes := Vector->New()<Shape>;
			@mix_chunks := Vector->New()<MixChunk>;
			@fonts := Vector->New()<Font>;
						
			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		#~
		Initializes game framework
		@param screen_width screen width
		@param screen_height screen height
		@param title screen title
		~#
		New(screen_width : Int, screen_height : Int, title : String) {
			init_flags := HardwareFlags->SDL_INIT_VIDEO or
				HardwareFlags->SDL_INIT_AUDIO or 
				HardwareFlags->SDL_INIT_JOYSTICK;
			@fps := 60;	
			@frame_rate := 1000 / @fps;
			@shapes := Vector->New()<Shape>;
			@mix_chunks := Vector->New()<MixChunk>;
			@fonts := Vector->New()<Font>;

			@is_ok := Init(screen_width, screen_height, title, init_flags);
		}

		#~
		Prints debug message
		@param debug_msg message
		~#
		function : Debug(debug_msg : String) ~ Nil {
			if(@debug_msg = Nil) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			}
			else if(<>debug_msg->Equals(@debug_msg)) {
				@debug_msg := debug_msg;
				@debug_msg->ErrorLine();
			};
		}
		
		method : Init(screen_width : Int, screen_height : Int, title : String, init_flags : Int) ~ Bool {
			@screen_width := screen_width;
			@screen_height := screen_height;

			@colors_dict := Hash->New()<String, Color>;
			@image_sprites_dict := Hash->New()<String, ImageSprite>;
			@rectangles_dict := Hash->New()<String, Rectangle>;
			@text_sprites_dict := Hash->New()<String, TextSprite>;

			@chunks_dict := Hash->New()<String, MixChunk>;
			@fonts_dict := Hash->New()<String, Font>;

			if(Core->Init(init_flags) < 0) {
			# "SDL could not initialize!"->ErrorLine();
				return false;
			};
			
			if(<>Hints->Set("SDL_RENDER_SCALE_QUALITY", "1")) {
				"Warning: Linear texture filtering not enabled!"->ErrorLine();
				return false;
			};

			if(<>Hints->Set("SDL_HINT_VIDEO_HIGHDPI_DISABLED", "1")) {
				"Warning: High-DPI windows (\"Retina\" on Mac and iOS) not allowed!"->ErrorLine();
				return false;
			};

			@window := Window->New(title, WindowFlags->SDL_WINDOWPOS_UNDEFINED, 
				WindowFlags->SDL_WINDOWPOS_UNDEFINED, @screen_width, @screen_height, 
				WindowFlags->SDL_WINDOW_SHOWN);
			if(@window->IsNull()) {
				"Cannot create window!"->ErrorLine();
				return false;
			};

			@renderer := Renderer->New(@window, -1, 
				RendererFlags->SDL_RENDERER_ACCELERATED or RendererFlags->SDL_RENDERER_PRESENTVSYNC);
			if(@renderer->IsNull()) {
				"Cannot create renderer!"->ErrorLine();
				return false;
			};
			@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);

			img_flags := ImageFlags->IMG_INIT_PNG;
			if((Image->Init(img_flags) and img_flags) = 0) {
				"SDL image could not initialize!"->ErrorLine();
				return false;
			};

			if(Font->Init() < 0) {
				"SDL_ttf could not initialize!"->ErrorLine();
				return false;
			};
			
"--- 7 ---"->PrintLine();			
			font_path := Runtime->GetProperty("lib_dir");
			if(font_path = Nil) {
				"Failed to load font!"->ErrorLine();
				return false;
			};
			font_path += "/sdl/fonts/lazy.ttf";
"--- 8 ---"->PrintLine();
			@font := Font->New(font_path, 24);
			if(@font->IsNull()) {
				"Failed to load font '{$font_path}'!"->ErrorLine();
				return false;
			};
"--- 9 ---"->PrintLine();
			if(<>Mixer->OpenAudio(44100, Mixer->Flags->MIX_DEFAULT_FORMAT, 2, 2048)) {
				"SDL mixer could not initialize!"->ErrorLine();
				return false;
			};

			if(Joystick->Number() < 1) {
				"Warning: No joysticks connected!"->ErrorLine();
			};
			@joystick := Joystick->New(0);
			@event := Event->New();
			
			return true;
		}

		#~
		Initialization status flag
		@return true if initialized, false otherwise
		~#
		method : public : IsOk() ~ Bool {
			return @is_ok;
		}

		method : public : SetOk(success : Bool) ~ Nil {
			if(@is_ok & <>success) {
				@is_ok := false;
			};
		}

		#~
		Gets the framework renderer
		@return framework renderer
		~#
		method : public : GetRenderer() ~ Renderer {
			return @renderer;
		}

		#~
		Gets the framework event
		@return framework event
		~#
		method : public : GetEvent() ~ Event {
			return @event;
		}

		#~
		Sets the start frame
		~#
		method : public : FrameStart() ~ Nil {
			@frame_start := Timer->GetTicks();
		}

		#~
		Gets the frame per second
		~#
		method : public : GetFps() ~ Int {
			return @fps;
		}

		#~
		Sets the end frame
		~#
		method : public : FrameEnd() ~ Nil {
			end := Timer->GetTicks() - @frame_start;
			if(end < @frame_rate) {
				Timer->Delay(@frame_rate - end);
			};
		}

		#~
		Sets the clear color
		@param color clear color
		~#
		method : public : SetClearColor(color : Color) ~ Nil {
			@clear_color := color;
		}

		#~
		Sets the game font
		@param font game font
		~#
		method : public : SetFont(font : Font) ~ Nil {
			@font := font;
		}
		
		#~
		Gets the clear color
		@return clear color
		~#
		method : public : GetClearColor() ~ Color {
			return @clear_color;
		}

		#~
		Clears the scene
		~#
		method : public : Clear() ~ Nil {
			if(@clear_color = Nil) {
				@renderer->SetDrawColor(0xFF, 0xFF, 0xFF, 0xFF);
			}
			else {
				@renderer->SetDrawColor(@clear_color->GetR(), @clear_color->GetG(), 
					@clear_color->GetB(), @clear_color->GetA());
			};
			@renderer->Clear();
		}

		#~
		Shows the scene
		~#
		method : public : Show() ~ Nil {
			@renderer->Present();
		}

		#~
		Get specified image sprite
		@param name name of image sprite
		@return image sprite
		~# 
		method : public : GetImageSprite(name : String) ~ ImageSprite {
			return @image_sprites_dict->Find(name)<String>;
		}

		#~
		Get specified rectangle
		@param name name of rectangle
		@return rectangle
		~# 
		method : public : GetRectangle(name : String) ~ Rectangle {
			return @rectangles_dict->Find(name)<String>;
		}

		#~
		Get specified text sprite
		@param name name of text sprite
		@return text sprite
		~# 
		method : public : GetTextSprite(name : String) ~ TextSprite {
			return @text_sprites_dict->Find(name)<String>;
		}

		#~
		Get specified color
		@param name name of color
		@return color
		~# 
		method : public : GetColor(name : String) ~ Color {
			return @colors_dict->Find(name)<String>;
		}

		#~
		Get specified font
		@param name name of font
		@return font
		~# 
		method : public : GetFont(name : String) ~ Font {
			return @fonts_dict->Find(name)<String>;
		}

		#~
		Get mix chunk
		@param name name of mix chunk
		@return mix chunk
		~# 
		method : public : GetMixChunk(name : String) ~ MixChunk {
			return @chunks_dict->Find(name)<String>;
		}

		#~
		Build assets from a Json file
		@param file path to build file
		@return true if successful, false otherwise
		~# 
		method : public : BuildFromFile(file : String) ~ Bool {
			if(@is_ok) {
				parser := JsonParser->New(System.IO.Filesystem.FileReader->ReadFile(file));
				if(parser->Parse()) {
					root := parser->GetRoot();

					# sound
					sound := root->Get("sounds");
					if(sound <> Nil & sound->GetType() = JsonElement->JsonType->OBJECT) {
						# music
						music := sound->Get("music");
						if(music <> Nil & music->GetType() = JsonElement->JsonType->OBJECT) {
							path_attrib := music->Get("path");
							if(path_attrib <> Nil)	{
								path := path_attrib->GetValue();
								SetMusicChunk(path);
							}
							else {
								"### Missing music: 'path' attribute ###"->ErrorLine();	
								@is_ok := false;
								return false;
							};
						};
						
						# chucks
						chunks := sound->Get("chunks");
						if(chunks <> Nil & chunks->GetType() = JsonElement->JsonType->ARRAY) {
							each(i : chunks) {
								chunk := chunks->Get(i);
								if(chunk->GetType() = JsonElement->JsonType->OBJECT) {
									name_attrib := chunk->Get("name");
									path_attrib := chunk->Get("path");
									if(name_attrib <> Nil & path_attrib <> Nil) {
										name := name_attrib->GetValue();
										path := path_attrib->GetValue();
										@chunks_dict->Insert(name, AddMixChunk(path));
									}
									else {
										"### Missing chunk: 'name' or 'path' attribute ###"->ErrorLine();
										@is_ok := false;
										return false;
									};
								}
								else {
									"### Invalid chunk type ###"->ErrorLine();
									@is_ok := false;
									return false;
								};
							};
						};
					};

					# colors
					colors := root->Get("colors");
					if(colors <> Nil & colors->GetType() = JsonElement->JsonType->ARRAY) {
						each(i : colors) {
							color := colors->Get(i);
							if(color->GetType() = JsonElement->JsonType->OBJECT) {
								name_attrib := color->Get("name");
								code_attrib := color->Get("code");
								if(name_attrib <> Nil & code_attrib <> Nil) {
									name := name_attrib->GetValue();
									codes := code_attrib->GetValue()->Split(",");
									if(codes->Size() = 3) {
										@colors_dict->Insert(name, Color->New(codes[0]->ToInt(), codes[1]->ToInt(), codes[2]->ToInt()));
									}
									else {
										@colors_dict->Insert(name, Color->New(0, 0, 0));
									};
								}
								else {
									"### Missing color: 'name' or 'code' attribute ###"->ErrorLine();
									@is_ok := false;
									return false;
								};
							}
							else {
								"### Invalid color type ###"->ErrorLine();
								@is_ok := false;
								return false;
							};
						};
					};

					# fonts
					fonts := root->Get("fonts");
					if(fonts <> Nil & fonts->GetType() = JsonElement->JsonType->ARRAY) {
						each(i : fonts) {
							font_obj := fonts->Get(i);
							if(font_obj->GetType() = JsonElement->JsonType->OBJECT) {
								name_attrib := font_obj->Get("name");
								path_attrib := font_obj->Get("path");
								size_attrib := font_obj->Get("size");
								if(name_attrib <> Nil & path_attrib <> Nil & size_attrib <> Nil) {
									name := name_attrib->GetValue();
									path := path_attrib->GetValue();
									size := size_attrib->GetValue()->ToInt();
									font := AddFont(path, size);
									@fonts_dict->Insert(name, font);
								}
								else {
									"### Missing font: 'name', 'path' or 'size' attribute ###"->ErrorLine();
									@is_ok := false;
									return false;
								};
							}
							else {
								"### Invalid font type ###"->ErrorLine();
								@is_ok := false;
								return false;
							};
						};
					};

					# assets
					assets := root->Get("assets");
					if(assets <> Nil & assets->GetType() = JsonElement->JsonType->OBJECT) {
						# image_sprites
						image_sprites := assets->Get("image_sprites");
						if(image_sprites <> Nil & image_sprites->GetType() = JsonElement->JsonType->ARRAY) {
							each(i : image_sprites) {
								image_sprite := image_sprites->Get(i);
								if(image_sprite->GetType() = JsonElement->JsonType->OBJECT) {
									name_attrib := image_sprite->Get("name");
									path_attrib := image_sprite->Get("path");
									color_key_attrib := image_sprite->Get("color-key");
									render_rect_attrib := image_sprite->Get("render-rect");						
									if(name_attrib <> Nil & path_attrib <> Nil & color_key_attrib <> Nil & render_rect_attrib <> Nil) {
										name := name_attrib->GetValue();
										path := path_attrib->GetValue();										
										color_key := color_key_attrib->GetValue();
										render_rect := render_rect_attrib->GetValue()->Split(",");
										color := GetColor(color_key);

										image : ImageSprite;
										if(render_rect->Size() = 4) {
											image := AddImageSprite(path, color, Rect->New(render_rect[0]->ToInt(), render_rect[1]->ToInt(), render_rect[2]->ToInt(), render_rect[3]->ToInt()));
										}
										else {
											image := AddImageSprite(path, color);
										};
										@image_sprites_dict->Insert(name, image);
									}
									else if(name_attrib <> Nil & path_attrib <> Nil & color_key_attrib <> Nil) {
										name := name_attrib->GetValue();
										path := path_attrib->GetValue();
										color_key := color_key_attrib->GetValue();
										image := AddImageSprite(path, GetColor(color_key));
										@image_sprites_dict->Insert(name, image);
									}
									else if(name_attrib <> Nil & path_attrib <> Nil) {
										name := name_attrib->GetValue();
										path := path_attrib->GetValue();
										image := AddImageSprite(path);
										@image_sprites_dict->Insert(name, image);
									}									
									else {
										"### Missing image sprite: 'name' or 'path' attribute ###"->ErrorLine();
										@is_ok := false;
										return false;
									};
								}
								else {
									"### Invalid image sprite type ###"->ErrorLine();
									@is_ok := false;
									return false;
								};
							};
						};

						# rectangles
						rectangles := assets->Get("rectangles");
						if(rectangles <> Nil & rectangles->GetType() = JsonElement->JsonType->ARRAY) {
							each(i : rectangles) {
								rectangle := rectangles->Get(i);
								if(rectangle->GetType() = JsonElement->JsonType->OBJECT) {
									name_attrib := rectangle->Get("name");
									size_attrib := rectangle->Get("size");
									color_attrib := rectangle->Get("color");
									filled_attrib := rectangle->Get("filled");
									
									if(name_attrib <> Nil & size_attrib <> Nil) {
										name := name_attrib->GetValue();
										size := size_attrib->GetValue()->Split(",");
										
										rect_obj : Rectangle;
										if(size->Size() = 2) {
											rect_obj := AddRectangle(size[0]->ToInt(), size[1]->ToInt());
										}
										else {
											rect_obj := AddRectangle(8, 8);											
										};
										@rectangles_dict->Insert(name, rect_obj);

										if(color_attrib <> Nil) {
											rect_obj->SetColor(GetColor(color_attrib->GetValue()));
										};

										if(filled_attrib <> Nil) {
											rect_obj->SetFill(filled_attrib->GetValue()->ToLower()->Equals("true"));
										};
									}
									else {
										"### Invalid rectangle type ###"->ErrorLine();
										@is_ok := false;
										return false;
									};
								}
								else {
									"### Invalid rectangle type ###"->ErrorLine();
									@is_ok := false;
									return false;
								};
							};
						};

						# text_sprites
						text_sprites := assets->Get("text_sprites");
						if(text_sprites <> Nil & text_sprites->GetType() = JsonElement->JsonType->ARRAY) {
							each(i : text_sprites) {
								text_sprite := text_sprites->Get(i);
								if(text_sprite->GetType() = JsonElement->JsonType->OBJECT) {
									name_attrib := text_sprite->Get("name");
									font_attrib := text_sprite->Get("font");
									text_attrib := text_sprite->Get("text");
									color_attrib := text_sprite->Get("color");
																	
									if(name_attrib <> Nil) {
										name := name_attrib->GetValue();
										
										text_obj := AddTextSprite();
										@text_sprites_dict->Insert(name, text_obj);

										if(font_attrib <> Nil) {
											text_obj->SetFont(GetFont(font_attrib->GetValue()));
										};

										if(color_attrib <> Nil) {
											text_obj->SetColor(GetColor(color_attrib->GetValue()));
										};

										if(text_attrib <> Nil) {
											text_obj->RenderedText(text_attrib->GetValue());
										};
									}
									else {
										"### Invalid text sprite type ###"->ErrorLine();
										@is_ok := false;
										return false;
									};
								}
								else {
									"### Invalid text sprite type ###"->ErrorLine();
									@is_ok := false;
									return false;
								};
							};
						};
					}
					else {
					# "### Missing 'assets' element ###"->ErrorLine();
						@is_ok := false;
						return false;
					};
				};
			};

			return true;
		}	

		#~
		Adds a font
		@param file file path to font
		@param size font size
		@return font
		~#
		method : public : AddFont(file : String, size : Int) ~ Font {
			font := Font->New(file, size);
			if(font->IsNull()) {
				"Failed to load font '{$file}'!"->ErrorLine();
			};
			SetOk(<>font->IsNull());
			@fonts->AddBack(font);

			return font;
		}	

		#~
		Adds a sound mix chunk
		@param file file path to sound asset 
		@return mix chunk
		~#
		method : public : AddMixChunk(file : String) ~ MixChunk {
			chunk := MixChunk->New(file);
			if(chunk->IsNull()) {
				"Failed to load audio chunk '{$file}'!"->ErrorLine();
			};
			SetOk(<>chunk->IsNull());
			@mix_chunks->AddBack(chunk);

			return chunk;
		}

		#~
		Adds music chunk
		@param file file path to sound asset 
		@return music chunk
		~#
		method : public : SetMusicChunk(file : String) ~ MixMusic {
			@music := MixMusic->New(file);
			if(@music->IsNull()) {
				"Failed to load music '{$file}'!"->ErrorLine();
			};
			SetOk(<>@music->IsNull());
			return @music;
		}
		
		#~
		Adds a rectangle to the framework
		@param w rectangle width
		@param h rectangle height
		@return rectangle
		~#
		method : public : AddRectangle(w : Int, h : Int) ~ Rectangle {
			shape := Rectangle->New(@renderer, w, h);
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds a text sprite to the framework
		@return text sprite
		~#
		method : public : AddTextSprite() ~ TextSprite {
			shape := TextSprite->New(@renderer, @font);
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@param colorkey image color key
		@param render_rect bounding rectangle to render
		@return image sprite
		~#
		method : public : AddImageSprite(file : String, colorkey : Color, render_rect : Rect) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file, colorkey, render_rect);
			if(<>shape->IsOk()) {
				"Failed to load sprite '{$file}'!"->ErrorLine();
			};
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@param colorkey image color key, may be Nil
		@return image sprite
		~#
		method : public : AddImageSprite(file : String, colorkey : Color) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file, colorkey);
			if(<>shape->IsOk()) {
				"Failed to load sprite '{$file}'!"->ErrorLine();
			};
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an tiled image  to the framework
		@param file file path to image asset
		@param colorkey image color key, may be Nil
		@return tiled image 
		~#
		method : public : AddTitledImageSprite(file : String, colorkey : Color) ~ TitledImageSprite {
			shape := TitledImageSprite->New(@renderer, file, colorkey);
			if(<>shape->IsOk()) {
				"Failed to load sprite '{$file}'!"->ErrorLine();
			};
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@return image sprite
		~#
		method : public : AddImageSprite(file : String) ~ ImageSprite {
			shape := ImageSprite->New(@renderer, file);
			if(<>shape->IsOk()) {
				"Failed to load sprite '{$file}'!"->ErrorLine();
			};
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@param clips vector of rendering rectangles
		@return animated image sprite
		~#
		method : public : AddAnimatedImageSprite(file : String, clips : Vector<Rect>) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file, clips);
			if(<>shape->IsOk()) {
				"Failed to load sprite '{$file}'!"->ErrorLine();
			};
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Adds an image sprite to the framework
		@param file file path to image asset
		@return animated image sprite
		~#
		method : public : AddAnimatedImageSprite(file : String) ~ AnimatedImageSprite {
			shape := AnimatedImageSprite->New(@renderer, file);
			if(<>shape->IsOk()) {
				"Failed to load sprite '{$file}'!"->ErrorLine();
			};
			SetOk(shape->IsOk());
			@shapes->AddBack(shape);

			return shape;
		}

		#~
		Remove shape from framework
		@param shape shape to remove
		@return true if successful, false otherwise
		~#
		method : public : RemoveSprite(shape : Shape) ~ Bool {
			found := -1;
			
			for(i := 0; i < @shapes->Size() & found < 0; i +=1;) {
				if(@shapes->Get(i) = shape) {
					found := i;
				};
			};

			if(found > -1) {
				@shapes->Remove(found);
				shape->Free();

				return true;
			};

			return false;
		}

		#~
		Remove chunk from framework
		@param mix_chunk chunk to remove
		@return true if successful, false otherwise
		~#
		method : public : RemoveMixChunk(mix_chunk : MixChunk) ~ Bool {
			found := -1;
			
			for(i := 0; i < @mix_chunks->Size() & found < 0; i +=1;) {
				if(@mix_chunks->Get(i) = mix_chunk) {
					found := i;
				};
			};

			if(found > -1) {
				@mix_chunks->Remove(found);
				mix_chunk->Free();

				return true;
			};

			return false;
		}

		#~
		Remove chunk from framework
		@param font chunk to remove
		@return true if successful, false otherwise
		~#
		method : public : RemoveFont(font : Font) ~ Bool {
			found := -1;
			
			for(i := 0; i < @fonts->Size() & found < 0; i +=1;) {
				if(@fonts->Get(i) = font) {
					found := i;
				};
			};

			if(found > -1) {
				@fonts->Remove(found);
				font->Quit();

				return true;
			};

			return false;
		}

		#~
		Gets all shapes
		~#
		method : public : GetShapes() ~ Vector<Shape> {
			return @shapes;
		}

		#~
		Removes all shapes
		~#
		method : public : FreeShapes() ~ Nil {
			each(i : @shapes) {
				shape := @shapes->Get(i);
				shape->Free();
			};
			@shapes->Empty();
		}

		#~
		Removes all mix chunks
		~#
		method : public : FreeMixChunks() ~ Nil {
			each(i : @mix_chunks) {
				chunk := @mix_chunks->Get(i);
				chunk->Free();
			};
			@mix_chunks->Empty();
		}

		#~
		Removes all font
		~#
		method : public : FreeFonts() ~ Nil {
			each(i : @fonts) {
				chunk := @fonts->Get(i);
				chunk->Quit();
			};
			@fonts->Empty();
		}

		#~
		Free music
		~#
		method : public : FreeMusic() ~ Nil {
			if(@music <> Nil) {
				@music->Halt();
				@music->Free();
			};
		}
		
		#~
		Closes the framework
		~#
		method : public : Quit() ~ Nil {
			FreeShapes();
			FreeMixChunks();
			FreeFonts();

			if(@event <> Nil) {
				@event->Free();
			};

			if(@joystick <> Nil) {
				@joystick->Free();
			};
			
			Image->Quit();
			Font->Quit();
			Mixer->Quit();
			Core->Quit();
		}
	}

	#~
	2D floating-point vector
	~#
	class Vector2 {
		@x : Float;
		@y : Float;

		#~
		Creates a new vector
		~#
		New() {
			@x := 0.0;
			@y := 0.0;
		}

		#~
		Creates a new vector
		@param x x-position
		@param y y-position
		~#
		New(x : Float, y : Float) {
			@x := x;
			@y := y;
		}

		#~
		Gets the x-position
		@return x-position
		~#
		method : public : GetX() ~ Float {
			return @x;
		}

		#~
		Gets the y-position
		@return y-position
		~#
		method : public : GetY() ~ Float {
			return @y;
		}

		#~
		Sets the x-position
		@param x x-position
		~#
		method : public : SetX(x : Float) ~ Nil {
			@x := x;
		}

		#~
		Sets the x and y positions
		@param x x-position
		@param y y-position
		~#
		method : public : Set(x : Float, y : Float) ~ Nil {
			@x := x;
			@y := y;
		}

		#~
		Sets the y-position
		@param y y-position
		~#
		method : public : SetY(y : Float) ~ Nil {
			@y := y;
		}

		#~
		Calculates the magnitude squared
		@return magnitude squared
		~#
		method : public : MagnitudeSquared() ~ Float {
			return @x*@x + @y*@y;
		}

		#~
		Calculates the magnitude 
		@return magnitude 
		~#
		method : public : Magnitude() ~ Float {
			return MagnitudeSquared()->Sqrt();
		}		

		#~
		Normalizes a unit vector
		~#
		method : public : Normalize() ~ Nil {
			mag := Magnitude();
 			if(mag <> 0.0) {
 				Div(mag);
 			};
 		}
 		
		#~
		String representation of vector
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "{$@x}, {$@y}";
		}

		#~
		Increments the current x-position
		@param rhs increment to the current x-position
		~#
		method : public : AddX(rhs : Vector2) ~ Nil {
			@x += rhs->GetX();
		}

		#~
		Decrements the current x-position
		@param rhs decrements to the current x-position
		~#
		method : public : SubX(rhs : Vector2) ~ Nil {
			@x -= rhs->GetX();
		}

		#~
		Multiplies the current x-position
		@param rhs value to multiply to the current x-position
		~#
		method : public : MulX(rhs : Vector2) ~ Nil {
			@x *= rhs->GetX();
		}

		#~
		Divides the current x-position
		@param rhs value to divide by the current x-position
		~#
		method : public : DivX(rhs : Vector2) ~ Nil {
			@x /= rhs->GetX();
		}

		#~
		Increments the current x-position
		@param x increment to the current x-position
		~#
		method : public : AddX(x : Int) ~ Nil {
			@x += x;
		}

		#~
		Decrements the current x-position
		@param x decrements to the current x-position
		~#
		method : public : SubX(x : Int) ~ Nil {
			@x -= x;
		}

		#~
		Multiplies the current x-position
		@param x value to multiply to the current x-position
		~#
		method : public : MulX(x : Int) ~ Nil {
			@x *= x;
		}

		#~
		Divides the current x-position
		@param x value to divide by the current x-position
		~#
		method : public : DivX(x : Int) ~ Nil {
			@x /= x;
		}

		#~
		Increments the current y-position
		@param rhs increment to the current y-position
		~#
		method : public : AddY(rhs : Vector2) ~ Nil {
			@y += rhs->GetY();
		}

		#~
		Decrements the current y-position
		@param rhs decrements to the current y-position
		~#
		method : public : SubY(rhs : Vector2) ~ Nil {
			@y -= rhs->GetY();
		}

		#~
		Multiplies the current y-position
		@param rhs value to multiply to the current y-position
		~#
		method : public : MulY(rhs : Vector2) ~ Nil {
			@y *= rhs->GetY();
		}

		#~
		Divides the current y-position
		@param rhs value to divide by the current y-position
		~#
		method : public : DivY(rhs : Vector2) ~ Nil {
			@y /= rhs->GetY();
		}

		#~
		Increments the current y-position
		@param y increment to the current y-position
		~#
		method : public : AddY(y : Int) ~ Nil {
			@y += y;
		}

		#~
		Decrements the current y-position
		@param y decrements to the current y-position
		~#
		method : public : SubY(y : Int) ~ Nil {
			@y -= y;
		}

		#~
		Multiplies the current y-position
		@param y value to multiply to the current y-position
		~#
		method : public : MulY(y : Int) ~ Nil {
			@y *= y;
		}

		#~
		Divides the current y-position
		@param y value to divide by the current y-position
		~#
		method : public : DivY(y : Int) ~ Nil {
			@y /= y;
		}

		#~
		Adds to current vector
		@param rhs vector to add
		~#
		method : public : Add(rhs : Vector2) ~ Nil {
			@x += rhs->GetX();
			@y += rhs->GetY();
		}

		#~
		Subtracts from current vector
		@param rhs vector to subtract
		~#
		method : public : Sub(rhs : Vector2) ~ Nil {
			@x -= rhs->GetX();
			@y -= rhs->GetY();
		}

		#~
		Multiples current vector
		@param rhs vector to multiply
		~#
		method : public : Mul(rhs : Vector2) ~ Nil {
			@x *= rhs->GetX();
			@y *= rhs->GetY();
		}

		#~
		Divides current vector
		@param rhs vector to divide
		~#
		method : public : Div(rhs : Vector2) ~ Nil {
			@x /= rhs->GetX();
			@y /= rhs->GetY();
		}

		#~
		Multiples current vector
		@param v v to multiply by
		~#
		method : public : Mul(v : Float) ~ Nil {
			@x *= v;
			@y *= v;
		}

		#~
		Divides current vector
		@param v v to divide by
		~#
		method : public : Div(v : Float) ~ Nil {
			@x /= v;
			@y /= v;
		}

		#~
		Sets vector limit
		@param v limit
		~#
		method : public : Limit(v : Float) ~ Nil {
			Limit(v, v);
		}

		#~
		Sets vector limit
		@param x x-limit
		@param y y-limit
		~#
		method : public : Limit(x : Float, y : Float) ~ Nil {
			if(@x > x) {
				@x := x;
			};

			if(@y > y) {
				@y := y;
			};
		}

		#~
		Sets vector to zero
		~#
		method : public : Zero() ~ Nil {
			@x := 0.0;
			@y := 0.0;
		}
		
		#~
		Add two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Add(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() + rhs->GetX(), lhs->GetY() + rhs->GetY());
		}

		#~
		Subtract two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Sub(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() - rhs->GetX(), lhs->GetY() - rhs->GetY());
		}

		#~
		Multiplies two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Mul(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() * rhs->GetX(), lhs->GetY() * rhs->GetY());
		}

		#~
		Divides two vectors
		@param lhs left vector
		@param rhs right vector
		@return new vector
		~#
		function : Div(lhs : Vector2, rhs : Vector2) ~ Vector2 {
			return Vector2->New(lhs->GetX() / rhs->GetX(), lhs->GetY() / rhs->GetY());
		}

		#~
		Multiplies a vector by a value
		@param rhs vector
		@param v value to multiple by
		@return new vector
		~#
		function : Mul(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() * v, rhs->GetY() * v);
		}

		#~
		Divides a vector by a value
		@param rhs vector
		@param v value to divides by
		@return new vector
		~#
		function : Div(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() / v, rhs->GetY() / v);
		}

		#~
		Multiplies x-vector component by a value
		@param rhs vector
		@param v value to multiple by
		@return new vector
		~#
		function : MulX(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() * v, rhs->GetY());
		}

		#~
		Divides x-vector component by a value
		@param rhs vector
		@param v value to multiple by
		@return new vector
		~#
		function : DivX(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX() / v, rhs->GetY());
		}

		#~
		Multiplies y-vector component by a value
		@param rhs vector
		@param v value to multiply by
		@return new vector
		~#
		function : MulY(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX(), rhs->GetY() * v);
		}

		#~
		Divides y-vector component by a value
		@param rhs vector
		@param v value to divide by
		@return new vector
		~#
		function : DivY(rhs : Vector2, v : Float) ~ Vector2 {
			return Vector2->New(rhs->GetX(), rhs->GetY() / v);
		}

		#~
		Calculates the dot product
		@param rhs right vector
		@param lhs left vector
		@return dot product
		~#
		function : Dot(lhs : Vector2, rhs : Vector2) ~ Float {
			return lhs->GetX()*rhs->GetX() + lhs->GetY()*rhs->GetY();
		}
	}
}
