#~~
# TODO
# Copyright (c) 2025 Randy Hollines
# ONNX and OpenCV wrappers
~~#	

use System.API, API.OpenCV;

#~
Open Neural Network Exchange support (ONNX) for generative AI and large language models (-lib onnx)
~#
bundle API.Onnx {
	class : private : Proxy {
		@lib_proxy : static : DllProxy;
		
		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_onnx");
			};

			return @lib_proxy;
		}
	}

	class Runtime {
		function : YoloInference(image : Byte[], height : Int, width : Int, model : String, labels : String[]) ~ API.Onnx.YoloResult {

			if(image = Nil | labels = Nil) {
				return Nil;
			};

			array_args := Base->New[6];

			array_args[0] := Nil;
			array_args[1] := ByteArrayRef->New(image);
			array_args[2] := IntRef->New(height);
			array_args[3] := IntRef->New(width);
			array_args[4] := model;
			array_args[5] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_yolo_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.YoloResult);
			results->Set(image, labels);

			return results;
		}

		function : ResNetInference(image : Byte[], height : Int, width : Int, model : String, labels : String[]) ~ API.Onnx.ResNetResult {
			if(image = Nil | labels = Nil) {
				return Nil;
			};

			array_args := Base->New[6];

			array_args[0] := Nil;
			array_args[1] := ByteArrayRef->New(image);
			array_args[2] := IntRef->New(height);
			array_args[3] := IntRef->New(width);
			array_args[4] := model;
			array_args[5] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_resnet_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.ResNetResult);
			results->Set(image, labels);

			return results;
		}

		function : GetProviders() ~ String[] {
			array_args := Base->New[1];
			array_args[0] := StringArrayRef->New();
			
			Proxy->GetDllProxy()->CallFunction("onnx_get_provider_names", array_args);
			
			holder := array_args[0]->As(StringArrayRef);
			return holder->Get();
		}
	}

	class Option {
		New() {}
	}

	class YoloResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		@classifications : YoloClassification[];

		@image_bytes : Byte[];
		@image_labels : String[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets image byte
		@return image bytes
		~#
		method : public : GetImages() ~ Byte[] {
			return @image_bytes;
		}

		#~
		Gets the labels
		@return labels
		~#
		method : public : GetLabels() ~ String[] {
			return @image_labels;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims; 
		}

		#~
		Gets an array of classifications
		@return array of classifications
		~#
		method : public : GetClassifications() ~ YoloClassification[] {
			return @classifications;
		}

		function : native : GreatestFloat(start : Int, end : Int, output : Float[]) ~ Int {
			index := start;

			for(i := start + 1; i < end; i += 1;) {
				if(output[i] > output[index]) {
					index := i;
				}
			}

			return index;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, labels=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, labels=";
			};

			if(@shape = Nil) {
				buffer += "0, classifications=";
			}
			else {
				labels_size := @image_labels->Size();
				buffer += "{$labels_size}, classifications=";
			};

			if(@classifications = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				classifications_size := @classifications->Size();
				buffer += "{$classifications_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}

	class YoloClassification {
		@id : Int;
		@name : String;
		@confidence : Float;
		@bounds : Rect;

		New(id : Int, confidence : Float, bounds : Rect) {
			@id := id;
			@confidence := confidence;
			@bounds := bounds;
		}

		method : public : GetId() ~ Int {
			return @id;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GetBounds() ~ Rect {
			return @bounds;
		}

		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : ToString() ~ String {
			x := @bounds->GetX(); y := @bounds->GetY(); w := @bounds->GetWidth(); h := @bounds->GetHeight();
			return "id={$@id}, name={$@name}, conf={$@confidence}, bounds=[{$x}, {$y}, {$w}, {$h}]";
		}
	}

	class ResNetResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		@class_id : Int;
		@confidence : Float;
		@name : String;

		@image_bytes : Byte[];
		@image_labels : String[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetId() ~ Int {
			return @class_id;
		}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims;
		}

		#~
		Gets string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}
}
