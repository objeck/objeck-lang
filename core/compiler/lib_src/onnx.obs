#~~
# Copyright (c) 2025 Randy Hollines
# ONNX wrapper
~~#	

use Collection, System.API, API.OpenCV;

#~
Open Neural Network Exchange support (ONNX) for generative AI and large language models (-lib onnx)
~#
bundle API.Onnx {
	class : private : Proxy {
		@lib_proxy : static : DllProxy;
		
		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_onnx");
			};

			return @lib_proxy;
		}
	}

	#~
	Yolo runtime
	~#
	class Runtime {
		function : GetProviders() ~ String[] {
			array_args := Base->New[1];
			array_args[0] := StringArrayRef->New();
			
			Proxy->GetDllProxy()->CallFunction("onnx_get_provider_names", array_args);
			
			holder := array_args[0]->As(StringArrayRef);
			return holder->Get();
		}
	}

	#~
	Yolo inference session
	~#
	class YoloSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param provider execution provider
		@param config session configuration parameters
		~#
		New(model : String, provider : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[5];

			array_args[0] := IntRef->New();
			array_args[1] := provider;
			array_args[2] := StringArrayRef->New(keys_array);
			array_args[3] := StringArrayRef->New(values_array);
			array_args[4] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		Yolo image inference, support for models v8 and above
		@param image image bytes
		@param height image height
		@param image width width
		@param conf_threshold confidence threshold
		@param labels classification labels
		~#
		method : public : Inference(image : Byte[], height : Int, width : Int, conf_threshold : Float, labels : String[]) ~ API.Onnx.YoloResult {

			if(image = Nil | labels = Nil) {
				return Nil;
			};

			array_args := Base->New[7];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(width);
			array_args[5] := FloatRef->New(conf_threshold);
			array_args[6] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_yolo_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.YoloResult);
			results->Set(image, labels);

			return results;
		}
	}

	#~
	Yolo inference result
	~#
	class YoloResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		@classifications : YoloClassification[];

		@image_bytes : Byte[];
		@image_labels : String[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets image byte
		@return image bytes
		~#
		method : public : GetImages() ~ Byte[] {
			return @image_bytes;
		}

		#~
		Gets the labels
		@return labels
		~#
		method : public : GetLabels() ~ String[] {
			return @image_labels;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims; 
		}

		#~
		Gets an array of classifications
		@return array of classifications
		~#
		method : public : GetClassifications() ~ YoloClassification[] {
			return @classifications;
		}

		function : native : GreatestFloat(start : Int, end : Int, output : Float[]) ~ Int {
			index := start;

			for(i := start + 1; i < end; i += 1;) {
				if(output[i] > output[index]) {
					index := i;
				}
			}

			return index;
		}

		#~
		String representation 
		@return string representation 
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, labels=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, labels=";
			};

			if(@shape = Nil) {
				buffer += "0, classifications=";
			}
			else {
				labels_size := @image_labels->Size();
				buffer += "{$labels_size}, classifications=";
			};

			if(@classifications = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				classifications_size := @classifications->Size();
				buffer += "{$classifications_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}

	#~
	Yolo classification result
	~#
	class YoloClassification {
		@id : Int;
		@name : String;
		@confidence : Float;
		@bounds : Rect;

		New : private () {
		}

		#~
		Get classification ID
		@return classification ID
		~#
		method : public : GetId() ~ Int {
			return @id;
		}

		#~
		Get classification name
		@return classification name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get classification bounds
		@return classification bounds
		~#
		method : public : GetBounds() ~ Rect {
			return @bounds;
		}

		#~
		Get classification confidence
		@return classification confidence
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			x := @bounds->GetX(); y := @bounds->GetY(); w := @bounds->GetWidth(); h := @bounds->GetHeight();
			return "id={$@id}, name={$@name}, conf={$@confidence}, bounds=[{$x}, {$y}, {$w}, {$h}]";
		}
	}

	#~
	Yolo inference session
	~#
	class ResNetSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param provider execution provider
		@param config session configuration parameters
		~#
		New(model : String, provider : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[5];

			array_args[0] := IntRef->New();
			array_args[1] := provider;
			array_args[2] := StringArrayRef->New(keys_array);
			array_args[3] := StringArrayRef->New(values_array);
			array_args[4] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		ResNet image inference
		@param image image bytes
		@param height image height
		@param image width width
		@param labels classification labels
		~#
		method : public : Inference(image : Byte[], height : Int, width : Int, labels : String[]) ~ API.Onnx.ResNetResult {
			if(image = Nil | labels = Nil) {
				return Nil;
			};

			array_args := Base->New[6];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(width);
			array_args[5] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_resnet_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.ResNetResult);
			results->Set(image, labels);

			return results;
		}
	}

	#~
	ResNet results
	~#
	class ResNetResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		@class_id : Int;
		@confidence : Float;
		@name : String;

		@image_bytes : Byte[];
		@image_labels : String[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		#~
		Get classification ID
		@return classification ID
		~#
		method : public : GetId() ~ Int {
			return @class_id;
		}

		#~
		Get classification name
		@return classification name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get classification confidence
		@return classification confidence
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}

	#~
	Deeplab inference session
	~#
	class DeepLabSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param provider execution provider
		@param config session configuration parameters
		~#
		New(model : String, provider : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[5];

			array_args[0] := IntRef->New();
			array_args[1] := provider;
			array_args[2] := StringArrayRef->New(keys_array);
			array_args[3] := StringArrayRef->New(values_array);
			array_args[4] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		DeepLab image inference
		@param image image bytes
		@param height image height
		@param image width width
		@param labels classification labels
		~#
		method : public : Inference(image : Byte[], height : Int, width : Int) ~ API.Onnx.DeepLabResult {
			if(image = Nil) {
				return Nil;
			};

			array_args := Base->New[5];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(width);

			Proxy->GetDllProxy()->CallFunction("onnx_deeplab_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.DeepLabResult);

			return results;
		}
	}






	#~
	DeepLab results
	~#
	class DeepLabResult {
		New : private () {}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			return buffer;
		}
	}
}
