#~~
# TODO
# Copyright (c) 2025 Randy Hollines
# ONNX and OpenCV wrappers
~~#	

use System.API, API.OpenCV;

#~
Open Neural Network Exchange support (ONNX) for generative AI and large language models (-lib onnx)
~#
bundle API.Onnx {
	class : private : Proxy {
		@lib_proxy : static : DllProxy;
		
		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_onnx");
			};

			return @lib_proxy;
		}
	}

	class Runtime {
		function : YoloInference(image : Byte[], height : Int, width : Int, model : String, 
				labels : String[]) ~ API.Onnx.YoloResult {
			array_args := Base->New[5];

			array_args[0] := Nil;
			array_args[1] := ByteArrayRef->New(image);
			array_args[2] := IntRef->New(height);
			array_args[3] := IntRef->New(width);
			array_args[4] := model;

			Proxy->GetDllProxy()->CallFunction("onnx_yolo_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.YoloResult);
			results->Set(image, labels);

			return results;
		}

		function : ResNetInference(image : Byte[], height : Int, width : Int, model : String) ~ API.Onnx.ResNetResult {
			return Nil;
		}

		function : GetProviders() ~ String[] {
			array_args := Base->New[1];
			array_args[0] := StringArrayRef->New();
			
			Proxy->GetDllProxy()->CallFunction("onnx_get_provider_names", array_args);
			
			holder := array_args[0]->As(StringArrayRef);
			return holder->Get();
		}
	}

	class Option {
		New() {}
	}

	class YoloResult {
		# set by library
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		# end set by library

		@image_bytes : Byte[];
		@classifications : Collection.Vector<YoloClassification>;
		@image_labels : String[];
		@num_classes : Int;

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
			@num_classes := image_labels->Size();

			@classifications := Collection.Vector->New()<YoloClassification>;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets image byte
		@return image bytes
		~#
		method : public : GetImages() ~ Byte[] {
			return @image_bytes;
		}

		#~
		Gets the labels
		@return labels
		~#
		method : public : GetLabels() ~ String[] {
			return @image_labels;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims; 
		}

		method : native : ProcessClassifications() ~ Nil {
			if(@output <> Nil & @shape <> Nil & @dims <> Nil) {
				result_count := @shape[1]

				cols := @dims[1];
				rows := @dims[0];

				for(i := 0; i < result_count; i += 1;) {
					x := @output[i * (@num_classes + 5) + 0];
					y := @output[i * (@num_classes + 5) + 1];
					w := @output[i * (@num_classes + 5) + 2];
					h := @output[i * (@num_classes + 5) + 3];
					conf := @output[i * (@num_classes + 5) + 4];

					left := (((x - w / 2.0) * cols) / 640.0)->As(Int);
					top := (((y - h / 2.0) * rows) / 640.0)->As(Int);
					width := ((w * cols) / 640.0)->As(Int);
					height := ((h * rows) / 640.0)->As(Int);

					if(conf >= 0.7) {
						start := i * (@num_classes + 5) + 5;
						end := start + @num_classes;
						class_id := GreatestFloat(start, end, @output) - start;
						image_label := @image_labels[class_id];

						@classifications->AddBack(YoloClassification->New(class_id, image_label, conf, 
							Rect->New(left, top, width, height)));
					};
				};
			};
		}

		#~
		Gets an array of classifications
		@return array of classifications
		~#
		method : public : GetClassifications() ~ Collection.Vector<YoloClassification> {
			if(@classifications->IsEmpty()) {
				ProcessClassifications();
			};

			return @classifications;
		}

		function : native : GreatestFloat(start : Int, end : Int, output : Float[]) ~ Int {
			index := start;

			for(i := start + 1; i < end; i += 1;) {
				if(output[i] > output[index]) {
					index := i;
				}
			}

			return index;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, labels=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, labels=";
			};

			if(@shape = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				image_labels_size := @image_labels->Size();
				buffer += "{$image_labels_size}, image_labels_size-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}

	class YoloClassification {
		@id : Int;
		@name : String;
		@confidence : Float;
		@bounds : Rect;

		New(id : Int, name : String, confidence : Float, bounds : Rect) {
			@id := id;
			@name := name;
			@confidence := confidence;
			@bounds := bounds;
		}

		method : public : GetId() ~ Int {
			return @id;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GetBounds() ~ Rect {
			return @bounds;
		}

		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : ToString() ~ String {
			x := @bounds->GetX(); y := @bounds->GetY(); w := @bounds->GetWidth(); h := @bounds->GetHeight();
			return "id={$@id}, class='{$@name}', conf={$@confidence}, bounds=[{$x}, {$y}, {$w}, {$h}]";
		}
	}

	class ResNetResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims;
		}

		#~
		Gets string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}
}
