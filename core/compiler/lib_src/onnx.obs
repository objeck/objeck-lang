#~~
# Copyright (c) 2025 Randy Hollines
# ONNX wrapper
~~#	

use Collection, System.API, API.OpenCV, Data.JSON;

#~
Open Neural Network Exchange support (ONNX) for generative AI and large language models (-lib onnx)
~#
bundle API.Onnx {
	class : private : Proxy {
		@lib_proxy : static : DllProxy;
		
		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_onnx");
			};

			return @lib_proxy;
		}
	}

	#~
	Yolo runtime
	~#
	class Runtime {
		function : GetProviders() ~ String[] {
			array_args := Base->New[1];
			array_args[0] := StringArrayRef->New();
			
			Proxy->GetDllProxy()->CallFunction("onnx_get_provider_names", array_args);
			
			holder := array_args[0]->As(StringArrayRef);
			return holder->Get();
		}
	}

	#~
	Yolo inference session
	~#
	class YoloSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param config session configuration parameters
		~#
		New(model : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[4];

			array_args[0] := IntRef->New();
			array_args[1] := StringArrayRef->New(keys_array);
			array_args[2] := StringArrayRef->New(values_array);
			array_args[3] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		Yolo image inference, support for models v8 and above
		@param image image bytes
		@param height image height
		@param image width width
		@param conf_threshold confidence threshold
		@param labels classification labels
		~#
		method : public : Inference(image : Byte[], height : Int, width : Int, conf_threshold : Float, labels : String[]) ~ API.Onnx.YoloResult {

			if(image = Nil | labels = Nil) {
				return Nil;
			};

			array_args := Base->New[7];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(width);
			array_args[5] := FloatRef->New(conf_threshold);
			array_args[6] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_yolo_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.YoloResult);
			results->Set(image, labels);

			return results;
		}
	}

	#~
	Yolo inference result
	~#
	class YoloResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		@classifications : YoloClassification[];

		@image_bytes : Byte[];
		@image_labels : String[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets image byte
		@return image bytes
		~#
		method : public : GetImages() ~ Byte[] {
			return @image_bytes;
		}

		#~
		Gets the labels
		@return labels
		~#
		method : public : GetLabels() ~ String[] {
			return @image_labels;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims; 
		}

		#~
		Gets an array of classifications
		@return array of classifications
		~#
		method : public : GetClassifications() ~ YoloClassification[] {
			return @classifications;
		}

		function : native : GreatestFloat(start : Int, end : Int, output : Float[]) ~ Int {
			index := start;

			for(i := start + 1; i < end; i += 1;) {
				if(output[i] > output[index]) {
					index := i;
				}
			}

			return index;
		}

		#~
		JSON representation 
		@return JSON representation 
		~#
		method : public : ToJson() ~ JsonElement {
			elem_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			dims_array := JsonElement->New(JsonElement->JsonType->ARRAY);
			dims_array->Add(@dims[0]); dims_array->Add(@dims[1]);
			elem_json->Insert("image-dims", dims_array);

			shape_array := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(shape_elem in @shape) {
				shape_array->Add(shape_elem);
			};

			classes_array := JsonElement->New(JsonElement->JsonType->ARRAY);
			each(classification in @classifications) {
				classes_array->Add(classification->ToJson());
			};
			elem_json->Insert("classes", classes_array);

			return elem_json;
		}

		#~
		String representation 
		@return string representation 
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, labels=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, labels=";
			};

			if(@shape = Nil) {
				buffer += "0, classifications=";
			}
			else {
				labels_size := @image_labels->Size();
				buffer += "{$labels_size}, classifications=";
			};

			if(@classifications = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				classifications_size := @classifications->Size();
				buffer += "{$classifications_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}

	#~
	Yolo classification result
	~#
	class YoloClassification {
		@id : Int;
		@name : String;
		@confidence : Float;
		@bounds : Rect;

		New : private () {
		}

		#~
		Get classification ID
		@return classification ID
		~#
		method : public : GetId() ~ Int {
			return @id;
		}

		#~
		Get classification name
		@return classification name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get classification bounds
		@return classification bounds
		~#
		method : public : GetBounds() ~ Rect {
			return @bounds;
		}

		#~
		Get classification confidence
		@return classification confidence
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		#~
		JSON representation 
		@return JSON representation 
		~#
		method : public : ToJson() ~ JsonElement {
			elem_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			elem_json->Insert("class-id", @id);
			elem_json->Insert("class-name", @name);
			elem_json->Insert("confidence", @confidence);
			elem_json->Insert("bounds" @bounds->ToJson());

			return elem_json;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			x := @bounds->GetX(); y := @bounds->GetY(); w := @bounds->GetWidth(); h := @bounds->GetHeight();
			return "id={$@id}, name={$@name}, conf={$@confidence}, bounds=[{$x}, {$y}, {$w}, {$h}]";
		}
	}

	#~
	ResNet inference session
	~#
	class ResNetSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param config session configuration parameters
		~#
		New(model : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[4];

			array_args[0] := IntRef->New();
			array_args[1] := StringArrayRef->New(keys_array);
			array_args[2] := StringArrayRef->New(values_array);
			array_args[3] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		ResNet image inference
		@param image image bytes
		@param height image height
		@param image width width
		@param labels classification labels
		~#
		method : public : Inference(image : Byte[], height : Int, width : Int, labels : String[]) ~ API.Onnx.ResNetResult {
			if(image = Nil | labels = Nil) {
				return Nil;
			};

			array_args := Base->New[6];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(width);
			array_args[5] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_resnet_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.ResNetResult);
			results->Set(image, labels);

			return results;
		}
	}

	#~
	ResNet results
	~#
	class ResNetResult {
		@output : Float[];
		@shape : Int[];
		@dims : Int[];
		@class_id : Int;
		@confidence : Float;
		@name : String;

		@image_bytes : Byte[];
		@image_labels : String[];

		New : private () {}

		#~
		Gets the output results
		@return output results
		~#
		method : public : GetOutput() ~ Float[] {
			return @output;
		}

		#~
		Get classification ID
		@return classification ID
		~#
		method : public : GetId() ~ Int {
			return @class_id;
		}

		#~
		Get classification name
		@return classification name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get classification confidence
		@return classification confidence
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		method : public : Set(image_bytes : Byte[], image_labels : String[]) ~ Nil {
			@image_bytes := image_bytes;
			@image_labels := image_labels;
		}

		#~
		Gets the output shape
		@return output shape
		~#
		method : public : GetShape() ~ Int[] {
			return @shape;
		}

		#~
		Gets the image dimensions
		@return image dimensions
		~#
		method : public : GetDimensions() ~ Int[] {
			return @dims;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "output-size=";

			if(@output = Nil) {
				buffer += "0, shape-size=";
			}
			else {
				output_size := @output->Size();
				buffer += "{$output_size}, shape-size=";
			};

			if(@shape = Nil) {
				buffer += "0, image-dims=";
			}
			else {
				shape_size := @shape->Size();
				buffer += "{$shape_size}, image-dims=";
			};

			if(@dims = Nil) {
				buffer += "0x0";
			}
			else {
				width := @dims[0];
				height := @dims[1];
				buffer += "{$width}x{$height}";
			};

			return buffer;
		}
	}

	#~
	Deeplab inference session
	~#
	class DeepLabSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param config session configuration parameters
		~#
		New(model : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[5];

			array_args[0] := IntRef->New();
			array_args[1] := StringArrayRef->New(keys_array);
			array_args[2] := StringArrayRef->New(values_array);
			array_args[3] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		DeepLab image inference
		@param image image bytes
		@param height image height
		@param image width width
		@param labels classification labels
		~#
		method : public : Inference(image : Byte[], labels : String[]) ~ API.Onnx.DeepLabResult {
			if(image = Nil) {
				return Nil;
			};

			array_args := Base->New[4];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := StringArrayRef->New(labels);

			Proxy->GetDllProxy()->CallFunction("onnx_deeplab_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.DeepLabResult);

			return results;
		}
	}

	#~
	DeepLab results
	~#
	class DeepLabResult {
		@masked_dims : Int[];
		@masked : API.OpenCV.Image;

		@overlay_dims : Int[];
		@overlay : API.OpenCV.Image;

		@classifications : DeepLabClassification[];

		#~
		Gets an array of classifications
		@return array of classifications
		~#
		method : public : GetClassifications() ~ DeepLabClassification[] {
			return @classifications;
		}

		New : private () {}

		#~
		Gets the masked image
		@return masked image
		~#
		method : public : GetMaskedImage() ~ API.OpenCV.Image {
			return @masked;
		}

		#~
		Gets the overlay image
		@return overlay image
		~#
		method : public : GetOverlayImage() ~ API.OpenCV.Image {
			return @overlay;
		}

		#~
		Gets the masked image dimensions
		@return masked image dimensions
		~#
		method : public : GetMaskedDimensions() ~ Int[] {
			return @masked_dims;
		}

		#~
		Gets the overlay image dimensions
		@return overlay image dimensions
		~#
		method : public : GetOverlayDimensions() ~ Int[] {
			return @overlay_dims;
		}

		#~
		JSON representation 
		@return JSON representation 
		~#
		method : public : ToJson() ~ JsonElement {
			elem_json := JsonElement->New(JsonElement->JsonType->ARRAY);

			each(classification in @classifications) {
				elem_json->Add(classification->ToJson());
			};

			return elem_json;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "masked-image-size=";

			if(@masked = Nil) {
				buffer += "<nil>, overlay-image-size=";
			}
			else {
				output_size := @masked->Size();
				buffer += "{$output_size}, overlay-image-size=";
			};

			if(@overlay = Nil) {
				buffer += "<nil>, classifications=";
			}
			else {
				output_size := @overlay->Size();
				buffer += "{$output_size}, classifications=";
			};

			if(@classifications = Nil) {
				buffer += 0;
			}
			else {
				classifications_size := @classifications->Size();
				buffer += classifications_size;
			};

			return buffer;
		}
	}

	#~
	DeepLab classification result
	~#
	class DeepLabClassification {
		@id : Int;
		@name : String;
		@confidence : Float;

		@polygons : Collection.Tuple.Pair[]<IntRef, IntRef>;

		New : private () {
		}

		#~
		Get classification ID
		@return classification ID
		~#
		method : public : GetId() ~ Int {
			return @id;
		}

		#~
		Get identified polygons 
		@return identified polygons
		~#
		method : public : GetPolygons() ~ Collection.Tuple.Pair[]<IntRef, IntRef> {
			return @polygons;
		}

		#~
		Get classification name
		@return classification name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get classification confidence
		@return classification confidence
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		#~
		JSON representation 
		@return JSON representation 
		~#
		method : public : ToJson() ~ JsonElement {
			elem_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			elem_json->Insert("class-id", @id);
			elem_json->Insert("class-name", @name);

			if(@polygons <> Nil) {
				polygons_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(polygon in @polygons) {
					polygon_json := JsonElement->New(JsonElement->JsonType->ARRAY);
					polygon_json->Add(polygon->GetFirst()->Get());
					polygon_json->Add(polygon->GetSecond()->Get());

					polygons_json->Add(polygon_json);
				};
				
				elem_json->Insert("polygons", polygons_json);
			};

			return elem_json;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			poly_count := 0;
			if(@polygons <> Nil) {
				poly_count := @polygons->Size();
			};

			return "[id={$@id}, name={$@name}, conf={$@confidence}, poly_count={$poly_count}]";
		}
	}

	#~
	OpenPose inference session
	~#
	class OpenPoseSession {
		@session : Int;

		#~
		Constructor.
		@param model Resnet model
		@param config session configuration parameters
		~#
		New(model : String, config : Map<String, String>) {
			keys := Vector->New()<String>;
			values := Vector->New()<String>;

			if(config <> Nil) {
				key_values := config->GetKeyValues()<Pair<String, String>>;
				each(key_value in key_values) {
					keys->AddBack(key_value->GetFirst());
					values->AddBack(key_value->GetSecond());
				};
			};

			keys_array := keys->ToArray();
			values_array := values->ToArray();

			array_args := Base->New[5];

			array_args[0] := IntRef->New();
			array_args[1] := StringArrayRef->New(keys_array);
			array_args[2] := StringArrayRef->New(values_array);
			array_args[3] := model;
						
			Proxy->GetDllProxy()->CallFunction("onnx_new_session", array_args);
			value := array_args[0]->As(IntRef);
			@session := value->Get();
		}

		#~
		Closes the session
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@session);

			Proxy->GetDllProxy()->CallFunction("onnx_close_session", array_args);
		}

		#~
		OpenPose image inference
		@param image image bytes
		@param height image height
		@param image width width
		~#
		method : public : Inference(image : Byte[], labels : String[]) ~ API.Onnx.OpenPoseResult {
			if(image = Nil) {
				return Nil;
			};

			array_args := Base->New[4];

			array_args[0] := Nil;
			array_args[1] := IntRef->New(@session);
			array_args[2] := ByteArrayRef->New(image);
			array_args[3] := StringArrayRef->New(labels);
			
			Proxy->GetDllProxy()->CallFunction("onnx_openpose_image_inf", array_args);
			
			results := array_args[0]->As(API.Onnx.OpenPoseResult);

			return results;
		}
	}

	#~
	OpenPose results
	~#
	class OpenPoseResult {
		@norm_x : Float;
		@norm_y : Float;
		@norm_w : Float;
		@norm_h : Float;

		@masked_dims : Int[];
		@masked : API.OpenCV.Image;

		@classifications : OpenPoseClassification[];
		
		New : private () {}

		#~
		Gets an array of classifications
		@return array of classifications
		~#
		method : public : GetClassifications() ~ OpenPoseClassification[] {
			return @classifications;
		}

		#~
		Gets the masked image
		@return masked image
		~#
		method : public : GetMaskedImage() ~ API.OpenCV.Image {
			return @masked;
		}

		#~
		Gets the masked image dimensions
		@return masked image dimensions
		~#
		method : public : GetMaskedDimensions() ~ Int[] {
			return @masked_dims;
		}

		#~
		Get normalized X-coordinate 
		@return normalized X-coordinate 
		~#
		method : public : GetNormalizedX() ~ Float {
			return @norm_x;
		}

		#~
		Get normalized y-coordinate 
		@return normalized y-coordinate
		~#
		method : public : GetNormalizedY() ~ Float {
			return @norm_y;
		}

		#~
		Get normalized height
		@return normalized height
		~#
		method : public : GetNormalizedHeight() ~ Float {
			return @norm_h;
		}

		#~
		Get normalized width
		@return normalized width
		~#
		method : public : GetNormalizedWidth() ~ Float {
			return @norm_w;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "masked-image-size=";

			if(@masked = Nil) {
				buffer += "<nil>, ";
			}
			else {
				output_size := @masked->Size();
				buffer += "{$output_size}, ";
			};

			buffer += "normalized=["
			buffer += @norm_x;
			buffer += ',';
			buffer += @norm_y;
			buffer += ',';
			buffer += @norm_w;
			buffer += ',';
			buffer += @norm_h;
			buffer += "], num_classes=";

			if(@classifications = Nil) {
				buffer += 0;
			}
			else {
				classifications_size := @classifications->Size();
				buffer += classifications_size;
			};

			return buffer;
		}
	}

	#~
	OpenPose classification result
	~#
	class OpenPoseClassification {
		@id : OpenPoseClassification->Type;
		@name : String;
		@norm_x : Float;
		@norm_y : Float;
		@confidence : Float;

		enum Type {
			NOSE, 
			LEFT_EYE,
			RIGHT_EYE,
			LEFT_EAR,
			RIGHT_EAR,
			LEFT_SHOULDER,
			RIGHT_SHOULDER,
			LEFT_ELBOW,
			RIGHT_ELBOW,
			LEFT_WRIST,
			RIGHT_WRIST,
			LEFT_HIP,
			RIGHT_HIP,
			LEFT_KNEE,
			RIGHT_KNEE,
			LEFT_ANKLE,
			RIGHT_ANKLE
		}

		New : private () {
		}

		#~
		Get classification ID
		@return classification ID
		~#
		method : public : GetId() ~ OpenPoseClassification->Type {
			return @id;
		}

		#~
		Get classification name
		@return classification name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get classification confidence
		@return classification confidence
		~#
		method : public : GetConfidence() ~ Float {
			return @confidence;
		}

		#~
		Get normalized X-coordinate 
		@return normalized X-coordinate
		~#
		method : public : GetNormalizedX() ~ Float {
			return @norm_x;
		}

		#~
		Get normalized y-coordinate 
		@return normalized y-coordinate
		~#
		method : public : GetNormalizedY() ~ Float {
			return @norm_y;
		}

		#~
		Get string representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			id := @id->As(Int);
			name := @name <> Nil ? @name : "<unknown>";

			return "[id={$id}, name={$name}, normalized=[{$@norm_x},{$@norm_x}], confidence={$@confidence}]";
		}
	}
}
