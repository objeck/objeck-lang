#~~
Copyright (c) 2023 Randy Hollines
~~#

use System.IO.Net; 
use Collection.Generic;
use Data.JSON;

#~
Web client support (-lib net)
~#
bundle Web.HTTP {
	#~
	URL parser, encoder and decoder
	~#
	class Url implements Compare {
		@parsed : Bool;
		@url : String;
		@scheme : String;
		@host : String;
		@port : Int;
		@frag : String;
		@query : String;
		@path : String;

		#~
		Parsed URL into components
		@param url raw URL
		~#
		New(url : String) {
			@url := url;
			@port := -1;
			@parsed := ParseUrl(url);
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			return @url->Compare(rhs);
		}

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @url->HashID();
		}

		#~
		Determines if given URL has been parsed correctly
		@return true if parsed, false otherwise
		~#
		method : public : Parsed() ~ Bool {
			return @parsed;
		}

		#~
		Gets original URL
		@return original URL
		~#
		method : public : GetUrl() ~ String {
			return @url;
		}

		#~
		Gets scheme
		@return scheme, Nil if not present
		~#
		method : public : GetScheme() ~ String {
			if(@parsed) {
				return @scheme;
			};

			return Nil;
		}

		#~
		Gets host
		@return host, Nil if not present
		~#
		method : public : GetHost() ~ String {
			if(@parsed) {
				return @host;
			};

			return Nil;
		}

		#~
		Gets scheme
		@return scheme, Nil if not present
		~#
		method : public : GetQuery() ~ String {
			if(@parsed) {
				return @query;
			};

			return Nil;
		}
		
		#~
		Gets port
		@return port, -1 if not present
		~#
		method : public : GetPort() ~ Int {
			if(@parsed) {
				return @port;
			};

			return -1;
		}

		#~
		Gets fragment
		@return fragment, Nil if not present
		~#
		method : public : GetFragment() ~ String {
			if(@parsed) {
				return @frag;
			};

			return Nil;
		}

		#~
		Gets path
		@return path, Nil if not present
		~#
		method : public : GetPath() ~ String {
			if(@parsed) {
				return @path;
			};

			return Nil;
		}

		method : ParseUrl(url : String) ~ Bool {
			# "-- url='{$url}' --"->PrintLine();
			scheme_index := url->Find(':');
			if(scheme_index < 0) {
				# "--- No URL scheme ---"->ErrorLine();
				return false;
			};
			@scheme := url->SubString(0, scheme_index);
			# "\t-- scheme='{$@scheme}' --"->PrintLine();

			scheme_index += 1;
			rest := url->SubString(scheme_index, url->Size() - scheme_index);
			# "\t-- rest='{$rest}' --"->PrintLine();

			if(rest->StartsWith("//")) {
				parts := rest->SubString(2, rest->Size() - 2)->Split("/");
				if(parts->Size() = 0) {
					ParsePart(rest->SubString(2, rest->Size() - 2), 0, false);
				}
				else {
					each(i : parts) {
						ParsePart(parts[i], i, i = parts->Size() - 1);
					};
				};
			}
			else {
				@path := rest;
			};

			return true;
		}

		method : ParsePart(part : String, index : Int, last : Bool) ~ Nil {
			# "\t-- part='{$part}' --"->PrintLine();

			# host and port
			if(index = 0) {
				if(part->StartsWith('[') | part->StartsWith('(')) {
					@host := part;
				}
				else {
					port_index := part->Find(':');
					if(port_index > -1) {
						@host := part->SubString(port_index);
						port_index += 1;
						port_str := part->SubString(port_index, part->Size() - port_index);
						@port := port_str->ToInt();
					}
					else {
						@host := part;
					};

					if(@host->EndsWith('/')) {
						@path := "/";
					};
				};
			}
			# path, query and fragment
			else {
				if(@path = Nil) {
					@path := "";
				};
				@path += '/';

				# query and fragment
				if(last) {
					sub_part : String;
					frag_index := part->Find('#');
					if(frag_index > -1) {
						sub_part := part->SubString(frag_index);
						# "\t-- sub_part='{$sub_part}' --"->PrintLine();							

						frag_index += 1;
						@frag := part->SubString(frag_index, part->Size() - frag_index);
					}
					else {
						sub_part := part;
					};

					query_index := sub_part->Find('?');
					if(query_index > -1) {
						# add to path
						if(query_index > 0)	{
							@path += sub_part->SubString(query_index);
						};
						query_index += 1;

						@query := sub_part->SubString(query_index, sub_part->Size() - query_index);
					}
					else {
						@path += sub_part;
					};
				}
				# path
				else {
					@path += part;
				};
			};
		}

		#~
		General encoding for HTML or XML strings
		@param str string to encode 
		@return encoded string 
		~#
		function : native : Encode(str : String) ~ String {
			buffer := String->New();
			each(i : str) {
				c := str->Get(i);
				select(c) {
					label ' ': {
						buffer->Append("%20");
					}

					label ';': {
						buffer->Append("%3B");
					}

					label '=': {
						buffer->Append("%3D");
					}

					label '$': {
						buffer->Append("%26");
					}

					label ',': {
						buffer->Append("%2C");
					}

					label '<': {
						buffer->Append("%3C");
					}

					label '>': {
						buffer->Append("%3E");
					}

					label '^': {
						buffer->Append("%5E");
					}

					label '`': {
						buffer->Append("%60");
					}

					label '\\': {
						buffer->Append("%5C");
					}

					label '[': {
						buffer->Append("%5B");
					}

					label ']': {
						buffer->Append("%5D");
					}

					label '{': {
						buffer->Append("%7B");
					}

					label '}': {
						buffer->Append("%7D");
					}

					label '|': {
						buffer->Append("%7C");
					}

					label '"': {
						buffer->Append("%22");
					}

					label ':': {
						buffer->Append("%3A");
					}

					label '/': {
						buffer->Append("%2F");
					}

					label '#': {
						buffer->Append("%23");
					}

					label '?': {
						buffer->Append("%3F");
					}

					label '&': {
						buffer->Append("%24");
					}

					label '@': {
						buffer->Append("%40");
					}

					label '%': {
						buffer->Append("%25");
					}

					label '+': {
						buffer->Append("%2B");
					}

					label '~': {
						buffer->Append("%7E");
					}

					other: {
						buffer->Append(c);
					}
				};
			};
			
			return buffer;
		}

		#~
		General decoding for HTML or XML strings		
		@param str encoded string
		@return decoded string
		~#
		function : native : Decode(str : String) ~ String {
			buffer := String->New();
			each(i : str) {
				c := str->Get(i);
				if(c = '%' & i + 2 < str->Size()) {
					value := "0x";
					value->Append(str->Get(i + 1));
					value->Append(str->Get(i + 2));
					buffer->Append(value->ToInt()->As(Char));
					i += 2;
				}
				else if(c = '+') {
					buffer->Append(' ');
				}
				else {
					buffer->Append(c);
				};
			};

			return buffer;
		}

		#~
		String representation of URL
		@return string representation of URL
		~#
		method : public : ToString() ~ String {
			buffer := "'{$@url}\n";

			if(@scheme <> Nil) {
				buffer += "\tscheme='{$@scheme}'\n";
			};

			if(@host <> Nil) {
				buffer += "\thost='{$@host}'\n";
			};

			if(@path <> Nil) {
				buffer += "\tpath='{$@path}'\n";
			};
			
			if(@port > -1) {
				buffer += "\tport='{$@port}'\n";
			};

			if(@query <> Nil) {
				buffer += "\tquery='{$@query}'\n";
			};
			
			if(@frag <> Nil) {
				buffer += "\tfragment='{$@frag}'\n";
			};
					
			return buffer;			
		}
	}

	class WebCommon {
		function : ParseAttribs(attrib_str : String) ~ Map<String, String> {
			attribs := Map->New()<String, String>;

			names_values := attrib_str->Split("; ");
			if(names_values->Size() > 0) {
				each(i : names_values) {
					names_value := names_values[i];					
					name_value_index := names_value->Find('=');
					if(name_value_index > 0) {						
						name := names_value->SubString(0, name_value_index);
						name_value_index += 1;
						value := names_value->SubString(name_value_index, names_value->Size() - name_value_index);
						attribs->Insert(name, value);
					}
					else {
						attribs->Insert(names_value, Nil);
					};
				};
			}
			else {
				name_value_index := attrib_str->Find('=');
				if(name_value_index > 0) {						
					name := attrib_str->SubString(0, name_value_index);
					name_value_index += 1;
					value := attrib_str->SubString(name_value_index, attrib_str->Size() - name_value_index);
					attribs->Insert(name, value);
				};
			};

			return attribs;
		}

		function : ReadChunked(content : Vector<String>, socket : System.IO.InputStream) ~ Nil {
			done := false;
			do {
				size_line := "0x";
				size_line->Append(socket->ReadLine());
				chunk_size := size_line->ToInt();
				if(chunk_size > 0) {

					total_read := 0;								
					buffer := Byte->New[8192];
					do {
						total_read += socket->ReadBuffer(0, buffer->Size(), buffer);
						content->AddBack(String->New(buffer));
						buffer->Clear();
					}
					while(total_read < chunk_size);

					# read CRLF
					socket->ReadByte(); 
					socket->ReadByte();
				}
				else {
					done := true;
				};
			}
			while(done <> true);
		}

		function : ReadLength(length : Int, content : Vector<String>, socket : System.IO.InputStream) ~ Nil {
			total_read := 0;		
			buffer := Byte->New[8192];
			do {
				total_read += socket->ReadBuffer(0, buffer->Size(), buffer);
				content->AddBack(String->New(buffer));
				buffer->Clear();
			}
			while(total_read < length);
		}

		function : ReadPost(content_length : Int, socket : System.IO.InputStream) ~ Byte[] {
			buffer := Byte->New[content_length];

			total_read := 0;
			temp := Byte->New[1024];
			do {
				read := socket->ReadBuffer(0, temp->Size(), temp);
				#~									
				if(@is_debug) {
					"Post: content_length='{$content_length}, read='{$read}, total_read='{$total_read}"->PrintLine();
				};
				~#

				Runtime->Copy(buffer, total_read, temp, 0, read);
				total_read += read;
			}
			while(total_read < content_length);

			return buffer;
		}
	}
	
	#~
	Downloads web content
	~#
	class WebDownloader {
		#~
		Downloads content for the given URLs
		@param urls list of URLs to download content from
		@param headers key/value headers
		@return map of URLs and content
		~#
		function : Download(urls : Vector<Url>, headers : Map<String, String>) ~ Vector<Pair<Url, String>> {
			group_size := 3;

			downloaders := Downloader->New[urls->Size()];
			each(i : urls) {
				downloaders[i] := Downloader->New(urls->Get(i), headers);
			};

			download_count := 0;
			while(download_count < urls->Size()) {
				group_ending := download_count + group_size;
				if(group_ending >= urls->Size()) {
					group_ending := urls->Size();
				};

				for(i := download_count; i < group_ending; i += 1;) {
					downloader := downloaders[i];
					downloader->Execute(Nil);
				};

				for(i := download_count; i < group_ending; i += 1;) {
					downloader := downloaders[i];
					downloader->Join();
				};

				download_count += group_ending;
			};

			results := Map->New()<Url, String>;
			each(i : urls) {
				downloader := downloaders[i];
				results->Insert(downloader->GetUrl(), downloader->GetContent());
			};

			return results->GetKeyValues();
		}
	}

	class Downloader from System.Concurrency.Thread {
		@url : Url;
		@content : String;
		@headers : Map<String, String>;

		New(url : Url, headers : Map<String, String>) {
			Parent();
			@url := url;
			@headers := headers;
		}

		method : public : GetUrl() ~ Url {
			return @url;
		}

		method : public : GetContent() ~ String {
			return @content;
		}

		method : public : Run(param : Base) ~ Nil {
			if(@url->GetScheme()->Equals("https")) {
				@content := HttpsClient->QuickGet(@url, @headers);
			}
			else if(@url->GetScheme()->Equals("http")) {
				@content := HttpClient->QuickGet(@url, @headers);
			};
		}
	}

	#~
	HTTP cookie
	~#
	class Cookie {
		@name : String;
		@value : String;
		@attribs : Map<String, String>;
		@expires : System.Time.Date;
		@is_debug : Bool;

		#~
		Constructor
		@param name cookie name
		@param value cookie value
		@param is_debug true to display debug information
		~#
		New(name : String, value : String, is_debug : Bool) {
			@name := name;
			@value := value;
			@is_debug := is_debug;
		}

		#~
		Constructor
		@param name cookie name
		@param value cookie value
		~#
		New(name : String, value : String) {
			@name := name;
			@value := value;
		}

		#~
		Constructor
		@param cookie_str cookie string
		~#
		New(cookie_str : String) {
			Parse(cookie_str);
		}

		#~
		Constructor
		@param cookie_str cookie string
		@param is_debug true to display debug information
		~#
		New(cookie_str : String, is_debug : Bool) {
			@is_debug := is_debug;
			Parse(cookie_str);
		}

		#~
		Get cookie name
		@return cookie name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Set cookie name
		@param name cookie name
		~#
		method : public : SetName(name : String) ~ Nil {
			@name := name;
		}

		#~
		Get cookie value
		@return cookie value
		~#
		method : public : GetValue() ~ String {
			return @value->RemoveAll('"');
		}

		#~
		Set cookie value
		@param value cookie value
		~#
		method : public : SetValue(value : String) ~ Nil {
			@value := value;
		}

		#~
		Get cookie attribute
		@param name attribute name
		@return cookie attribute value
		~#
		method : public : GetAttrib(name : String) ~ String {
			if(@attribs <> Nil) {
				return @attribs->Find(name);
			};

			return Nil;
		}

		#~
		Adds a cookie attribute
		@param name attribute name
		@return true if added, false otherwise
		~#
		method : public : AddAttrib(name : String) ~ Bool {
			return AddAttrib(name, Nil);
		}

		#~
		Adds a cookie attribute
		@param name attribute name
		@param value attribute value
		@return true if added, false otherwise
		~#
		method : public : AddAttrib(name : String, value : String) ~ Bool {
			if(@attribs = Nil) {
				@attribs := Map->New()<String, String>;
			};

			if(@attribs->Has(name)) {
				return false;
			};

			@attribs->Insert(name, value);
			return true;
		}

		#~
		Removes an attribute
		@param name attribute name
		@return true if added, false otherwise
		~#
		method : public : RemoveAttrib(name : String) ~ Bool {
			if(@attribs <> Nil) {
				return @attribs->Remove(name);
			};

			return false;
		}

		#~
		Sets the cookie to expire
		~#
		method : public : Expire() ~ Nil {
			@value := "";

			if(@attribs <> Nil & @attribs->Has("Expires")) {
				@attribs->Remove("Expires");
			};
			@expires := System.Time.Date->New(true);
			
		}

		#~
		Sets the cookie to expiration date
		@param expires expiration date
		~#
		method : public : SetExpiration(expires : System.Time.Date) ~ Bool {
			if(@attribs <> Nil & @attribs->Has("Expires")) {
				@attribs->Remove("Expires");
			};
			@expires := expires;
			
			return true;
		}

		#~
		Formats a cookie into a string
		@return string formatted cookie
		~#
		method : public : ToString() ~ String {
			buffer := "";

			buffer += @name;
			buffer += '=';
			buffer += @value;

			if(@attribs <> Nil) {
				buffer += "; ";

				attrib_pairs := @attribs->GetKeyValues()<Pair<String, String>>;
				each(i : attrib_pairs) {
					attrib_pair := attrib_pairs->Get(i);

					name := attrib_pair->GetFirst();
					value := attrib_pair->GetSecond();

					if(value = Nil) {
						buffer += name;
					}
					else {
						buffer += name;
						buffer += '=';
						buffer += value;
					};

					if(i + 1 < attrib_pairs->Size()) {
						buffer += "; ";
					};
				};
			};

			if(@expires <> Nil) {
				buffer += "; ";
				buffer += FormatGmtTime(@expires);
			};

			return buffer;
		}

		#~
		Formats a cookie name and value
		@return string formatted cookie name and value
		~#
		method : public : ToShortString() ~ String {
			buffer := "";
			
			buffer += @name;
			buffer += '=';
			buffer += @value;

			return buffer;
		}
		
		method : Parse(cookie_str : String) ~ Nil {
			if(cookie_str <> Nil) {
				names_values := cookie_str->Split("; ");
				if(names_values->Size() > 0) {
					each(i : names_values) {
						names_value := names_values[i];					
						name_value_index := names_value->Find('=');
						if(name_value_index > 0) {						
							name := names_value->SubString(0, name_value_index);
							name_value_index += 1;
							value := names_value->SubString(name_value_index, names_value->Size() - name_value_index);
							Add(name, value, i);
						}
						else {
							Add(names_value, Nil, i);
						};
					};
				}
				else {
					name_value_index := cookie_str->Find('=');
					if(name_value_index > 0) {						
						name := cookie_str->SubString(0, name_value_index);
						name_value_index += 1;
						value := cookie_str->SubString(name_value_index, cookie_str->Size() - name_value_index);
						Add(name, value, 0);
					};
				};
			};

			if(@is_debug) {
				"---"->PrintLine();
			};
		}

		method : Add(name : String, value : String, index : Int) ~ Nil {
			if(index = 0) {
				@name := name;
				@value := value;
			}
			else {
				if(@attribs = Nil) {
					@attribs := Map->New()<String, String>;
				};
				@attribs->Insert(name, value);
			};

			if(@is_debug) {
				if(value = Nil) {
					"name='{$name}'"->PrintLine();
				}
				else {
					"name='{$name}', value='{$value}'"->PrintLine();
				};
			};
		}
		
		method : native : FormatGmtTime(date : System.Time.Date) ~ String {
			buffer := "";

			days_of_week := ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
			buffer += days_of_week[date->GetWeekDay()];
			buffer += ", ";

			day := date->GetDay();
			if(day < 10) {
				buffer += '0';			
			};
			buffer += day;
			buffer += " ";

			months := ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
			buffer += months[date->GetMonth() - 1];
			buffer += " ";

			buffer += date->GetYear();
			buffer += " ";

			hour := date->GetHours();
			if(hour < 10) {
				buffer += '0';			
			};
			buffer += hour;
			buffer += ":";

			min := date->GetMinutes();
			if(min < 10) {
				buffer += '0';			
			};
			buffer += min;
			buffer += ":";

			sec := date->GetSeconds();
			if(sec < 10) {
				buffer += '0';			
			};
			buffer += sec;
			buffer += " GMT";

			return buffer;
		}
	}
}

#~
Web server support (-lib net)
~#
bundle Web.HTTP.Server {
	#~
	HTTP and HTTP web server
	~#
	class WebServer {
		@secure_server : static : TCPSecureSocketServer;
		@server : static : TCPSocketServer;
		@server_config : static : WebServerConfig;
		@is_debug : static : Bool;
        
		#~
		Starts a HTTPS server that listens for requests
		@param filename configuration file (an <a href='https://github.com/objeck/objeck-web-server/blob/master/config/simple_config.json' target='_blank'>example</a>)
		~#
		function : ServeSecure(filename : String) ~ Nil {
			if(@server_config = Nil) {
				@server_config := WebServerConfig->New(filename);
			};

			if(@server_config->Load()) {
				callback := @server_config->GetClass();
				port := @server_config->GetPort();
				cert := @server_config->GetCertPath();
				cert_key := @server_config->GetCertKeyPath();
				cert_key_passwd := @server_config->GetCertPassword();

				if(@server_config->IsDebug()) {
					callback_str := "<Nil>";
					if(callback <> Nil) {
						callback_str := callback->GetName();
					};

					"=> Web server config: impl_class='{$callback_str}', port={$port}, cert='{$cert}', cert_key='{$cert_key}', cert_passwd='{$cert_key_passwd}'"->PrintLine();
				};

				if(callback <> Nil & port > 0 & cert <> Nil & cert_key <> Nil & cert_key_passwd <> Nil) {
					ServeSecure(callback, port, cert, cert_key, cert_key_passwd, @server_config->IsDebug());
				};
			};
		}

		#~
		Starts a HTTPS server that listens for requests
		@param callback class inherited from 'HttpsRequestHandler'
		@param port server port
		@param cert SSL certificate
		@param cert_key SSL certificate key
		@param cert_key_passwd SSL certificate password
		@param is_debug true for debug output, false otherwise
		~#
		function : ServeSecure(callback : Class, port : Int, cert : String, cert_key : String, cert_key_passwd : String) ~ Nil {
			ServeSecure(callback, port, cert, cert_key, cert_key_passwd, false);
		}

		#~
		Starts a HTTPS server that listens for requests
		@param callback class inherited from 'HttpsRequestHandler'
		@param port server port
		@param cert SSL certificate
		@param cert_key SSL certificate key
		@param cert_key_passwd SSL certificate password
		@param is_debug true for debug output, false otherwise
		~#
		function : ServeSecure(callback : Class, port : Int, cert : String, cert_key : String, cert_key_passwd : String, is_debug : Bool) ~ Nil {
			@secure_server := TCPSecureSocketServer->New(cert, cert_key, cert_key_passwd, port);
			@is_debug := is_debug;

	  		Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			if(@secure_server->Listen()) {
				platform := Runtime->GetPlatform();
				host := TCPSocket->HostName();

				if(@is_debug) {
					"=> Running on '{$host}' ({$platform}) port {$port}..."->PrintLine();
				};

				while(true) {
					handler := callback->Instance(callback->GetName())->As(HttpsRequestHandler);
					handler->SetConfig(@server_config, @is_debug);
					handler->Execute(@secure_server->Accept());
				};
			}
			else {
				err_msg := @secure_server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
	  	}

	  	#~
		Starts a HTTP server that listens for requests
		@param filename configuration file (an <a href='https://github.com/objeck/objeck-web-server/blob/master/config/simple_config.json' target='_blank'>example</a>)
		~#
		function : Serve(filename : String) ~ Nil {
			@server_config := WebServerConfig->New(filename);
			if(@server_config->Load()) {
				# callback : Class, port : Int, is_debug : Bool
			};
		}

	  	#~
		Starts a HTTP server that listens for requests
		@param callback class inherited from 'HttpRequestHandler'
		@param port server port
		@param is_debug true for debug output, false otherwise
		~#
	  	function : Serve(callback : Class, port : Int) ~ Nil {
	  		Serve(callback, port, false);
	  	}

	  	#~
		Starts a HTTP server that listens for requests
		@param callback class inherited from 'HttpRequestHandler'
		@param port server port
		@param is_debug true for debug output, false otherwise
		~#
	  	function : Serve(callback : Class, port : Int, is_debug : Bool) ~ Nil {
	  		@server := TCPSocketServer->New(port);
			@is_debug := is_debug;

	  		Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			if(@server->Listen(8)) {
				platform := Runtime->GetPlatform();
				host := TCPSocket->HostName();

				if(@is_debug) {
					"=> Running on '{$host}' ({$platform}) port {$port}..."->PrintLine();
				};
                
				while(true) {
					handler := callback->Instance(callback->GetName())->As(HttpRequestHandler);
					handler->SetConfig(@server_config, @is_debug);
					handler->Execute(@server->Accept());
				};
			}
			else {
				err_msg := @server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
	  	}

		function : Shutdown(id : Int) ~ Nil {
			if(@secure_server <> Nil) {
				@secure_server->Close();
			};

			if(@server <> Nil) {
				@server->Close();
			};
            
			if(@is_debug) {
				"Shutting down..."->PrintLine();
			};
			Runtime->Exit(0);
		}
	}

	class WebServerConfig implements RequestPageHandler {
		@filename : String;
		@instance_str : String;
		@is_debug : Bool;
		@is_handling_files : Bool;
		@port : Int;
		@base_dir : String;
		@cert_path : String;
		@cert_key_path : String;
		@cert_passwd : String;
		@file_group_handler_map : Hash<String, FileGroupHandler>;
		@content_cache : Map<String, ByteArrayHolder>;

		New(filename : String) {
			@filename := filename;
			@file_group_handler_map := Hash->New()<String, FileGroupHandler>;
			@content_cache := Map->New()<String, ByteArrayHolder>;
		}

		method : public : GetFilename() ~ String {
			return @filename;
		}

		method : public : GetClass() ~ Class {
			class_instance := Class->Instance(@instance_str);
			if(class_instance <> Nil) {
				return class_instance->GetClass();
			};

			return Nil;
		}
		
		method : public : IsDebug() ~ Bool {
			return @is_debug;
		}

		method : public : IsHandlingFiles() ~ Bool {
			return @is_handling_files;
		}

		method : public : GetPort() ~ Int {
			return @port;
		}

		method : public : GetCertPath() ~ String {
			return @cert_path;
		}

		method : public : GetCertKeyPath() ~ String {
			return @cert_key_path;
		}

		method : public : GetCertPassword() ~ String {
			return @cert_passwd;
		}

		method : public : HasStaticHandler(name : String) ~ Bool {
			alias_str : String;
			if(name->StartsWith('/')) {
				alias_str := name->SubString(1, name->Size() - 1);
				if(alias_str = Nil) {
					return false;
				};
			}
			else {
				alias_str := name;
			};

			file_groups := @file_group_handler_map->GetValues()<FileGroupHandler>;
			each(i : file_groups) {
				file_group := file_groups->Get(i);
				if(file_group->HasGroupHander(alias_str)) {
					return true;
				};
			};

			return false;
		}

		method : public : Load() ~ Bool {
			parser := JsonParser->New(System.IO.Filesystem.FileReader->ReadFile(@filename));
			if(parser->Parse()) {				
				# process network config
				network_json := parser->GetRoot()->Get("network");
				if(network_json = Nil) {
					"Error: missing 'network' tag"->ErrorLine();
					return false;
				};
				
				network_instance_json := network_json->Get("instance");
				network_port_json := network_json->Get("port");
				if(network_instance_json = Nil | network_port_json = Nil) {
					"Error: missing 'instance' or 'port' tag"->ErrorLine();
					return false;
				};
				@instance_str := network_instance_json->GetString();
				@port := network_port_json->GetString()->ToInt();

				is_debug_json := network_json->Get("debug");
				if(is_debug_json <> Nil & <>is_debug_json->IsNull()) {
					@is_debug := is_debug_json->GetBool();
				};
				
				network_secure_json := network_json->Get("secure");
				if(network_secure_json <> Nil & <>network_secure_json->IsNull()) {
					network_cert_path_json := network_secure_json->Get("cert_path");
					network_cert_key_json := network_secure_json->Get("cert_key_path");
					network_cert_passwd_json := network_secure_json->Get("cert_passwd");

					if(network_cert_path_json = Nil | network_cert_key_json = Nil | network_cert_passwd_json = Nil) {
						"Error: missing SSL certificate tags"->ErrorLine();
						return false;
					};
					@cert_path := network_cert_path_json->GetString();
					@cert_key_path := network_cert_key_json->GetString();
					@cert_passwd := network_cert_passwd_json->GetString();
				};

				# process files
				files_json := parser->GetRoot()->Get("files");
				if(files_json <> Nil & <>files_json->IsNull()) {
					# common configuration 
					common_json := files_json->Get("common");
					if(common_json <> Nil) {
						common_base_dir_json := common_json->Get("base_dir");
						if(common_base_dir_json <> Nil & <>common_base_dir_json->IsNull()) {
							@base_dir := common_base_dir_json->GetString();
						};
					};

					# individual files
					items_json := files_json->Get("items");
					if(items_json <> Nil & <>items_json->IsNull()) {
						each(i : items_json) {
							item_json := items_json->Get(i);
							if(item_json->Has("groups")) {
								if(<>AddFiles(item_json)) {
									return false;
								};
							};
						};
					};
				
					@is_handling_files := true;
				};

				return true;
			};

			return false;
		}

		method : AddFiles(file_json : JsonElement) ~ Bool {
			groups_json := file_json->Get("groups");
			location_json :=  file_json->Get("location");
			mime_type_json := file_json->Get("mime-type");

			if(groups_json <> Nil & <>groups_json->IsNull() & location_json <> Nil & <>location_json->IsNull()) {
				groups_str := groups_json->GetString();
				type_strs := groups_str->Split(',');
				if(type_strs->Size() > 0) {
					each(i : type_strs) {
						type_str := type_strs[i];
						if(<>type_str->StartsWith('.')) {
							"Error: 'groups' values must start with '.'"->ErrorLine();
							return false;
						};

						if(<>AddHandler(type_str, file_json, mime_type_json)) {
							return false;
						};
					};
				}
				else {
					if(<>groups_str->StartsWith('.')) {
						"Error: 'groups' value must start with '.'"->ErrorLine();
						return false;
					};

					if(<>AddHandler(groups_str, file_json, mime_type_json)) {
						return false;
					};
				};
			};

			return true;
		}

		method : AddHandler(group : String, file_json : JsonElement, mime_type_json : JsonElement) ~ Bool {
			alias_str := "<None>";
			alias_json := file_json->Get("alias");
			if(alias_json <> Nil & <>alias_json->IsNull()) {
				alias_str := alias_json->GetString();
			};

			if(alias_str->StartsWith('.') | alias_str->EndsWith('.') | alias_str->Count('.') <> 1) {
				"Error: 'alias' value must have a file extension"->ErrorLine();
				return false;
			};

			location_str := "<None>";
			location_json := file_json->Get("location");
			if(location_json <> Nil & <>location_json->IsNull()) {
				location_str := location_json->GetString();
			};

			mime_type_str := "text/plain";
			mime_type_json := file_json->Get("mime-type");
			if(mime_type_json <> Nil & <>mime_type_json->IsNull()) {
				mime_type_str := mime_type_json->GetString();
			};

			cache_flag : Bool;
			cache_json := file_json->Get("cache");
			if(cache_json <> Nil & <>cache_json->IsNull()) {
				cache_flag := cache_json->GetBool();
			};

			# get/add handler
			group_handler := @file_group_handler_map->Find(group);
			if(group_handler = Nil) {
				group_handler := FileGroupHandler->New(group);
				@file_group_handler_map->Insert(group, group_handler);
			};

			if(<>group_handler->Insert(alias_str, location_str, mime_type_str, cache_flag)) {
				"Unable to add file: alias='{$alias_str}', location='{$location_str}'"->ErrorLine();
				return false;
			};

			return true;
		}

		method : public : ToString() ~ String {
			buffer := "[Network]\n";
			buffer += "\tfilename='{$@filename}', instance='{$@instance_str}', handling_files='{$@is_handling_files}', port='{$@port}, is_debug='{$@is_debug}\n";
			if(@cert_path <> Nil & @cert_key_path <> Nil & @cert_passwd <> Nil) {
				buffer += "\tcert_path='{$@cert_path}', cert_key='{$@cert_key_path}', cert_passwd='{$@cert_passwd}'\n";
			};

			buffer += "[Files]\n";
			file_group_pairs := @file_group_handler_map->GetKeyValues()<Pair<String, FileGroupHandler>>;
			each(i : file_group_pairs) {
				file_group_pair := file_group_pairs->Get(i);

				file_group_name := file_group_pair->GetFirst();
				buffer += "\t{'{$file_group_name}}\n";
				file_group_handler := file_group_pair->GetSecond();
				buffer += file_group_handler->ToString();
			};
			
			return buffer;
		}

		#~
		Callback for GET requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : ProcessGet(request : Request, response : Response) ~ Bool {
			return Process(request , response);
		}

		#~
		Callback for POST requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : ProcessPost(request : Request, response : Response) ~ Bool {
			return Process(request , response);
		}

		method : Process(request : Request, response : Response) ~ Bool {
			request_path : String;
			if(response->HasForwardAlias()) {
				request_path := response->GetForwardAlias();
			}
			else {
				request_path := request->GetPath();
			};

			request_group_index := request_path->FindLast('.');
			# alias
			if(request_group_index > 0) {
				request_group := request_path->SubString(request_group_index, request_path->Size() - request_group_index);
				if(request_group = Nil) {
					return false;
				};

				file_group_handler := @file_group_handler_map->Find(request_group);
				if(file_group_handler = Nil) {
					return false;
				};

				alias_str := request_path->SubString(1, request_path->Size() - 1);
				if(alias_str = Nil) {
					return false;
				};

				file_handler := file_group_handler->GetFileHander(alias_str);
				if(file_handler = Nil) {
					return false;
				};

				if(@is_debug) {
					file_handler_str := file_handler->ToString();
					"Item properties: {$file_handler_str}"->PrintLine();
				};
				
				buffer : Byte[];

				file_location : String;

				if(@base_dir <> Nil) {
					file_location := String->New(@base_dir);
					if(<>file_location->EndsWith('/') & <>file_location->EndsWith('\\')) {
						file_location += System.IO.Filesystem.Directory->GetSlash();
					};
					file_location += file_handler->GetLocation();
				}
				else {
					file_location := file_handler->GetLocation();
				};

				if(@is_debug) {
					"File location='{$file_location}'"->PrintLine();
				};

				# use caching
				if(file_handler->IsCached()) {
					buffer_holder := @content_cache->Find(file_location);
					if(buffer_holder = Nil) {
						buffer := System.IO.Filesystem.FileReader->ReadBinaryFile(file_location);
						if(buffer = Nil) {
							return false;
						};
						@content_cache->Insert(file_location, ByteArrayHolder->New(buffer));
						if(@is_debug) {
							"---"->PrintLine();
						};
					}
					else {
						if(@is_debug) {
							"=> Cached\n---"->PrintLine();
						};
						buffer := buffer_holder->Get();
					};
				}
				# non-caching
				else {	
					buffer := System.IO.Filesystem.FileReader->ReadBinaryFile(file_location);
					if(buffer = Nil) {
						return false;
					};					
				};
				response->SetCodeContent(200, buffer);
				
				return true;
			};

			return false;
		}
	}

	class : private : FileGroupHandler {
		@group : String;
		@alias_map : Map<String, FileHandler>;

		New(group : String) {
			@group := group;
			@alias_map := Map->New()<String, FileHandler>;
		}

		method : public : Insert(alias_str : String, location_str : String, mime_type_str : String, cache_flag : Bool) ~ Bool {
			if(alias_str->Equals("<None>") | location_str->Equals("<None>") | @alias_map->Has(location_str)) {
				return false;
			};

			file_handler := FileHandler->New(@group, alias_str, location_str, mime_type_str, cache_flag);
			@alias_map->Insert(alias_str, file_handler);

			return true;
		}

		method : public : GetFileHander(alias_str : String) ~ FileHandler {
			return @alias_map->Find(alias_str);
		}

		method : public : HasGroupHander(alias_str : String) ~ Bool {
			return @alias_map->Has(alias_str);
		}

		method : public : ToString() ~ String {
			buffer := "";

			alias_handlers := @alias_map->GetValues()<FileHandler>;
			each(i : alias_handlers) {
				alias_handler := alias_handlers->Get(i);
				buffer += '\t';
				buffer += alias_handler->ToString();
				buffer += "\n";
			};

			return buffer;
		}
	}

	class : private : FileHandler {
		@group : String;
		@alias_str : String;
		@location : String;
		@mime_type : String;
		@cache : Bool;

		New(group : String, alias_str : String, location : String, mime_type : String, cache : Bool) {
			@group := group;
			@alias_str := alias_str;
			@location := location;
			@mime_type := mime_type;
			@cache := cache;
		}

		method : public : GetAlias() ~ String {
			return @alias_str;
		}

		method : public : GetLocation() ~ String {
			return @location;
		}

		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		method : public : IsCached() ~ Bool {
			return @cache;
		}

		method : public : ToString() ~ String {
			return "alias='{$@alias_str}', location='{$@location}', mime_type='{$@mime_type}', cache={$@cache}, group='{$@group}'";
		}
	}

	#~
	Web server request
	~#
	class Request {
		@request_line : String;
		@request_path : String;
		@request_query : String;

		@request_headers : Map<String, String>;
		@request_params : Map<String, String>;
		@cookies : Map<String, Cookie>;
		@content : Byte[];

		New(request_line : String, request_headers : Map<String, String>) {
			@request_line := request_line;
			@request_headers := request_headers;

			query_index := @request_line->Find('?');
			if(query_index > 0) {
				@request_path := @request_line->SubString(query_index);
				query_index += 1;
				@request_query := @request_line->SubString(query_index, @request_line->Size() - query_index);
				@content := @request_query->ToByteArray();
			}
			else {
				@request_path := request_line;
			};
		}

		New(request_line : String, request_headers : Map<String, String>, content : Byte[]) {
			@request_line := request_line;
			@request_headers := request_headers;
			@content := content;
		}

		#~
		Parses an attribute string
		@param attrib_str attribute string
		@return map of names/values
		~#
		function : ParseAttribs(attrib_str : String) ~ Map<String, String> {
			return WebCommon->ParseAttribs(attrib_str);
		}

		#~
		Gets a parameter value
		@param name parameter name
		@return parameter value
		~#
		method : public : GetParam(name : String) ~ String {
			ParseParams();

			if(@request_params <> Nil) {
				return @request_params->Find(name);
			};

			return Nil;
		}

		#~
		Checks for a parameter
		@param name parameter name
		@return true if parameter exists, false otherwise
		~#
		method : public : HasParam(name : String) ~ Bool {
			ParseParams();

			if(@request_params <> Nil) {
				return @request_params->Has(name);
			};

			return false;
		}

		#~
		Gets parameters
		@return parameters
		~#
		method : public : GetParams() ~ Map<String, String> {
			ParseParams();

			if(@request_params <> Nil) {
				return @request_params;
			};

			return Nil;
		}

		method : ParseParams() ~ Nil {
			if(@content <> Nil & @request_params = Nil) {
				@request_params := Map->New()<String, String>;
				
				params_str := @content->ToString();
				param_names_values := params_str->Split('&');
				if(param_names_values->Size() > 0) {
					each(i : param_names_values) {
						param_name_value := param_names_values[i]->Split('=');
						if(param_name_value->Size() = 2) {
							name := param_name_value[0];
							value := Url->Decode(param_name_value[1]);
							@request_params->Insert(name, value);
						};
					};
				}
				else {
					param_name_value := params_str->Split('=');
					if(param_name_value->Size() = 2) {
						@request_params->Insert(param_name_value[0], param_name_value[1]);
					};
				};
			};
		}

		#~
		Gets a cookie value
		@param name cookie name
		@return cookie value
		~#
		method : public : GetCookie(name : String) ~ Cookie {
			ParseCookies();

			return @cookies->Find(name);
		}

		#~
		Checks for a cookie
		@param name cookie name
		@return true if cookie exists, false otherwise
		~#
		method : public : HasCookie(name : String) ~ Bool {
			ParseCookies();

			return @cookies->Has(name);
		}

		#~
		Gets cookies
		@return cookies
		~#
		method : public : GetCookies() ~ Vector<Cookie> {
			ParseCookies();

			return @cookies->GetValues()<Cookie>;
		}

		method : ParseCookies() ~ Nil {
			if(@cookies = Nil) {
				@cookies := Map->New()<String, Cookie>;
				
				cookies_str := @request_headers->Find("Cookie");
				if(cookies_str <> Nil) {
					cookie_names_values := cookies_str->Split("; ");
					each(i : cookie_names_values) {
						cookie_name_value := cookie_names_values[i]->Split('=');
						if(cookie_name_value->Size() = 2) {
							name := cookie_name_value[0];
							value := cookie_name_value[1];

							@cookies->Insert(name, Cookie->New(name, value));
						};
					};
				};
			};
		}

		#~
		Gets the request body content
		@return request content
		~#
		method : public : GetContent() ~ String {
			return @content->ToString();
		}

		#~
		Gets the request body content as bytes
		@return request content as bytes
		~#
		method : public : GetContentBytes() ~ Byte[] {
			return @content;
		}

		#~
		Gets the request line
		@return request line
		~#
		method : public : GetRequestLine() ~ String {
			return @request_line;
		}

		#~
		Gets the request path
		@return request path
		~#
		method : public : GetPath() ~ String {
			return @request_path;
		}

		#~
		Gets the request query
		@return request query
		~#
		method : public : GetQuery() ~ String {
			return @request_query;
		}

		#~
		Gets a request header
		@param name header name
		@return request header
		~#
		method : public : GetRequestHeader(name : String) ~ String {
			return @request_headers->Find(name)<String>;
		}
	}

	#~
	Web server response
	~#
	class Response {
		@code : Int;
		@content : Byte[];
		@compression : Compression;
		@is_compressed : Bool;
		@reason : String;
		@response_headers : Map<String, String>;
		@cookies : Map<String, Cookie>;
		@server_config : WebServerConfig;
		@request_path : String;
		@forward_alias_name : String;

		enum Compression := 100 {
			NONE,
			GZIP,
			DEFLATE,
			BR
		}

		New(server_config : WebServerConfig, request_path : String) {
			@server_config := server_config;
			@request_path := request_path;

			@code := 400;
			@compression := Compression->NONE;
			@is_compressed := false;
			@response_headers := Map->New()<String, String>;
			@cookies := Map->New()<String, Cookie>;
		}

		#~
		Adds a cookie
		@param cookie cookie
		~#
		method : public : AddCookie(cookie : Cookie) ~ Nil {
			@cookies->Insert(cookie->GetName(), cookie);
		}

		#~
		Updates a cookie
		@param name cookie name
		@param value cookie value
		~#
		method : public : GetCookie(name : String) ~ Cookie {
			return @cookies->Find(name);
		}

		#~
		Removes a cookie
		@param name cookie name
		~#
		method : public : RemoveCookie(name : String) ~ Nil {
			cookie := @cookies->Find(name);
			if(cookie <> Nil) {
				cookie->Expire();
			};
		}

		#~
		Gets all cookies
		@return all cookies
		~#
		method : public : GetCookies() ~ Vector<Cookie> {
			return @cookies->GetValues()<Cookie>;
		}

		#~
		Check to see if the response has configured handler
		@return true if handler exists, false otherwise
		~#
		method : public : HasStaticHandler() ~ Bool {
			if(@server_config <> Nil & @request_path <> Nil) {
				return @server_config->HasStaticHandler(@request_path);
			};

			return false;
		}

		#~
		Set the forward page alias
		@param name forward page alias
		@return true if set, false otherwise
		~#
		method : public : SetForwardAlias(name : String) ~ Bool {
			if(@server_config <> Nil & @server_config->HasStaticHandler(name)) {
				@forward_name := "";
				if(<>name->StartsWith('/')) {
					@forward_name += '/';
				};
				@forward_name += name;

				return true;
			};

			return false;
		}

		#~
		Gets the forward page alias
		@return forward page alias
		~#
		method : public : GetForwardAlias() ~ String {
			return @forward_alias_name;
		}

		#~
		Checks the forward page alias
		@return true if forward page alias exists, false otherwise
		~#
		method : public : HasForwardAlias() ~ Bool {
			return @forward_alias_name <> Nil;
		}

		#~
		Get the response code
		@return response code
		~#
		method : public : GetCode() ~ Int {
			return @code;
		}

		#~
		Set response code
		@param code response code
		~#
		method : public : SetCode(code : Int) ~ Nil {
			@code := code;
		}

		#~
		Set response content
		@param content response content
		~#
		method : public : SetContent(content : Byte[]) ~ Nil {
			@content := content;
		}

		#~
		Set response code
		@param content response content
		~#
		method : public : SetContent(content : String) ~ Nil {
			@content := content->ToByteArray();
		}

		#~
		Set the response compression, should be called after the content is set
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetCompression(compression : Compression) ~ Nil {
			if(<>@is_compressed & @content <> Nil) {
				select(compression) {
					label Compression->GZIP	{
						@content := @content->CompressGzip();
						@response_headers->Insert("Content-Encoding", "gzip");
						@is_compressed := true;
					}

					label Compression->DEFLATE {
						@content := @content->CompressZlib();
						@response_headers->Insert("Content-Encoding", "deflate");
						@is_compressed := true;
					}

					label Compression->BR {
						@content := @content->CompressBr();
						@response_headers->Insert("Content-Encoding", "br");
						@is_compressed := true;
					}
				};
			};
		}

		#~
		Set response code, content and compression type
		@param code response code
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetCodeContentCompression(code : Int, content : String, compression : Compression) ~ Nil {
			SetCodeContentCompression(code, content->ToByteArray(), compression);
		}

		#~
		Set response code, content and compression type
		@param code response code
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetCodeContentCompression(code : Int, content : Byte[], compression : Compression) ~ Nil {
			@code := code;
			@content := content;
			SetCompression(compression);
		}

		#~
		Set content and compression type
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetContentCompression(content : String, compression : Compression) ~ Nil {
			SetContentCompression(content->ToByteArray(), compression);
		}

		#~
		Set content and compression type
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetContentCompression(content : Byte[], compression : Compression) ~ Nil {
			@content := content;
			SetCompression(compression);
		}

		#~
		Set response code and content
		@param code response code
		@param content response content
		~#
		method : public : SetCodeContent(code : Int, content : Byte[]) ~ Nil {
			@code := code;
			@content := content;
		}

		#~
		Set response code and content
		@param code response code
		@param content response content
		~#
		method : public : SetCodeContent(code : Int, content : String) ~ Nil {
			@code := code;
			@content := content->ToByteArray();
		}

		#~
		Set response code and content
		@param code response code
		@param type content type
		@param content response content
		~#
		method : public : SetCodeTypeContent(code : Int, type : String, content : Byte[]) ~ Nil {
			@code := code;
			@content := content;
			SetContentType(type);
		}

		#~
		Set response code and content
		@param code response code
		@param type content type
		@param content response content
		~#
		method : public : SetCodeTypeContent(code : Int, type : String, content : String) ~ Nil {
			@code := code;
			@content := content->ToByteArray();
			SetContentType(type);
		}

		#~
		Get the response content
		@return response content
		~#
		method : public : GetContent() ~ Byte[] {
			return @content;
		}

		#~
		Get the response content as string
		@return response content as string
		~#
		method : public : GetStringContent() ~ String {
			return @content->ToString();
		}

		#~
		Set response reason
		@param reason response reason
		~#
		method : public : SetReason(reason : String) ~ Nil {
			@reason := reason;
		}

		#~
		Get the reason string
		@return reason sting
		~#
		method : public : GetReason() ~ String {
			return @reason;
		}

		#~
		Sets the content type
		@param type content type
		~#
		method : public : SetContentType(type : String) ~ Nil {
			@response_headers->Insert("Content-Type", type);
		}

		#~
		Gets a response header
		@param name header name
		@return response header
		~#
		method : public : GetHeader(name : String) ~ String {
			return @response_headers->Find(name)<String>;
		}

		#~
		Gets response headers
		@return response headers
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			return @response_headers;
		}

		#~
		Sets a response header
		@param name header name
		@param value header value
		~#
		method : public : SetHeader(name : String, value : String) ~ Nil {
			if(value = Nil | value->IsEmpty()) {
				@response_headers->Remove(name);
			}
			else {
				@response_headers->Insert(name, value)<String>;
			};
		}

		#~
		Removed a response header
		@param name header name
		~#
		method : public : RemoveHeader(name : String) ~ Nil {
			SetHeader(name, Nil);
		}

		#~
		Check for a response header
		@param name header name
		@return true if header exists, false otherwise
		~#
		method : public : HasHeader(name : String) ~ Bool {
			return @response_headers->Has(name);
		}

		#~
		Get the reason string
		@return reason sting
		~#
		method : public : ToString() ~ String {
			if(@content <> Nil) {
				content_size := @content->Size();
				return "code='{$@code}, reason='{$@reason}, content_size='{$content_size}";
			};

			return "<Nil>";
		}
	}
	
	#~
	Multipart encoding
	~#
	class MultipartEncoding {
		@encoded : Byte[];

		#~
		Parses multipart encoding
		@param encoded encoded bytes
		~#
		New(encoded : Byte[]) {
			@encoded := encoded;
		}
		
		#~
		Parses multipart encoding
		@return content parts
		~#
	    method : public : native : Parse() ~ Vector<MultipartContent> {
	        multipart_content := Vector->New()<MultipartContent>;

	        # read encoding string
	        marker_bytes := ReadLine(0, @encoded);
	        if(marker_bytes = Nil) {
	            return Nil;
	        };

	        encoding_size := @encoded->Size();
	        
	        # fetch all markers
	        marker_indexes := Byte->FindAll(@encoded, marker_bytes);
	        if(marker_indexes = Nil) {
	            return Nil;
	        };

	        boundry_index := 0;
	        for(i := 0; i < marker_indexes->Size() - 1; i += 1;) {
	            boundary_bytes := ReadLine(marker_indexes[i], @encoded);
	            if(boundary_bytes = Nil) {
	                return Nil;
	            };
	            boundry_index += boundary_bytes->Size();

	            # read white space
	            if(<>MatchSpace(boundry_index, @encoded)) {
	                return Nil;
	            };
	            boundry_index += 2;
	 
	            # read content headers
	            done := false;
	            headers := Map->New()<String, String>;
	            do {
	                # read content line
	                header_bytes := ReadLine(boundry_index, @encoded);
	                if(header_bytes <> Nil) {            
	                    boundry_index += header_bytes->Size();
	                    content_str := header_bytes->ToString();
	                    
	                    # parse header name/value pair
	                    content_str_index := content_str->Find(':');
	                    if(content_str_index > 0) {
	                        header_name := content_str->SubString(content_str_index);
	                        content_str_index += 2;
	                        header_value := content_str->SubString(content_str_index, content_str->Size() - content_str_index);
	                        
	                        if(<>header_name->IsEmpty() & <>header_value->IsEmpty()) {
	                            headers->Insert(header_name, header_value);
	                        };
	                    };
	                }
	                else {
	                    done := true;
	                };

	                # read white space
	                if(<>MatchSpace(boundry_index, @encoded)) {
	                    return Nil;
	                };
	                boundry_index += 2;
	            }
	            while(<>done);
	            
	            # read content
	            content_size := marker_indexes[i + 1] - boundry_index - 2;
	            
	            content_bytes := Byte->New[content_size];
	            if(<>Runtime->Copy(content_bytes, 0, @encoded, boundry_index, content_size)) {
	                return Nil;
	            };
	            boundry_index += content_bytes->Size();

	            # read white space
	            if(<>MatchSpace(boundry_index, @encoded)) {
	                return Nil;
	            };
	            boundry_index += 2;

	            multipart_content->AddBack(MultipartContent->New(headers, content_bytes));
	        };

			# read ending boundary
	        boundary_bytes := ReadLine(marker_indexes[marker_indexes->Size() - 1], @encoded);
	        if(boundary_bytes = Nil) {
	            return Nil;
	        };
	        boundry_index += boundary_bytes->Size();

	        # read white space
	        if(<>MatchSpace(boundry_index, @encoded)) {
	            return Nil;
	        };
	        boundry_index += 2;

	        boundary_str := boundary_bytes->ToString();
	        if(boundary_str->EndsWith("--") & encoding_size = boundry_index) {
	            return multipart_content;
	        };

	        return Nil;
	    }

	    method : native : ReadLine(offset : Int, encoded : Byte[]) ~ Byte[] {
	        i := offset;
	        if(i < encoded->Size()) {
	            done := false;
	            read := 0;
	            while(<>done & i < encoded->Size()) {
	                byte := encoded[i++];
	                if(byte = '\r') {
	                    done := true;
	                }
	                else {
	                    read += 1;
	                };
	            };

	            line := Byte->New[read];
	            if(Runtime->Copy(line, 0, encoded, offset, read)) {
	                return line;
	            };
	        };

	        return Nil;
	    }

	    method : native : MatchSpace(offset : Int, encoded : Byte[]) ~ Bool {
	        if(offset + 1 < encoded->Size()) {
	            return encoded[offset] = '\r' & encoded[offset + 1] = '\n';
	        };

	        return false;
	    }
	}

	#~
	Multipart content type
	~#
	class MultipartContent {
	    @headers : Map<String, String>;
	    @content : Byte[];

	    New(headers :  Map<String, String>, content : Byte[]) {
	        @headers := headers;
	        @content := content;
	    }

	    #~
		Get MIME content header
		@param name header name
		@return header value
		~#
	    method : public : GetHeader(name : String) ~ String {    
	        return @headers->Find(name);
	    }

	    #~
		Get MIME content header names
		@return header names
		~#
	    method : public : GetHeaderNames() ~ Vector<String> {    
	        return @headers->GetKeys()<String>;
	    }

	    #~
		Get MIME content
		@return MIME bytes
		~#
	    method : public : GetContent() ~ Byte[] {
	        return @content;
	    }
	}

	#~
	Interface for HTTP page requests
	~#
	interface RequestPageHandler {
		#~
		Callback for GET requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : virtual : ProcessGet(request : Request, response : Response) ~ Bool;

		#~
		Callback for POST requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : virtual : ProcessPost(request : Request, response : Response) ~ Bool;
	}
}