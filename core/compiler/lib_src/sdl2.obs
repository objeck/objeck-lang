#~~
SDL2 wrapper
Copyright (c) 2017-2020 Randy Hollines
~~#

use System.API;

#~
General SDL2 wrapper (-lib sdl2)
~#
bundle Game.SDL2 {
	class Proxy {
		@lib_proxy : static : DllProxy;
		
		function : GetDllProxy() ~ DllProxy {
			if(@lib_proxy = Nil) {
				@lib_proxy := DllProxy->New("libobjk_sdl");
			};

			return @lib_proxy;
		}
	}
	
	#~
 	SDL_MessageBox flags. If supported will display warning icon, etc.
	~#
	consts MessageBoxFlags {
	    SDL_MESSAGEBOX_ERROR := 0x00000010,
	    SDL_MESSAGEBOX_WARNING := 0x00000020,
	    SDL_MESSAGEBOX_INFORMATION := 0x00000040,
	    SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT := 0x00000080,
	    SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT := 0x00000100
	}
	
	#~
	SDL mouse wheel direction
	~#
	enum MouseWheelDirection {
	    SDL_MOUSEWHEEL_NORMAL,
	    SDL_MOUSEWHEEL_FLIPPED
    }

	#~
	SDL button state
	~#
	enum KeyState {
		SDL_PRESSED,
		SDL_RELEASED
	}

	#~
	SDL event action
	~#
	enum EventAction {
		SDL_ADDEVENT,
		SDL_PEEKEVENT,
		SDL_GETEVENT
	}

	#~
	OpenGL window attributes
	~#
	enum GLattr {
		SDL_GL_RED_SIZE,
	    SDL_GL_GREEN_SIZE,
	    SDL_GL_BLUE_SIZE,
	    SDL_GL_ALPHA_SIZE,
	    SDL_GL_BUFFER_SIZE,
	    SDL_GL_DOUBLEBUFFER,
	    SDL_GL_DEPTH_SIZE,
	    SDL_GL_STENCIL_SIZE,
	    SDL_GL_ACCUM_RED_SIZE,
	    SDL_GL_ACCUM_GREEN_SIZE,
	    SDL_GL_ACCUM_BLUE_SIZE,
	    SDL_GL_ACCUM_ALPHA_SIZE,
	    SDL_GL_STEREO,
	    SDL_GL_MULTISAMPLEBUFFERS,
	    SDL_GL_MULTISAMPLESAMPLES,
	    SDL_GL_ACCELERATED_VISUAL,
	    SDL_GL_RETAINED_BACKING,
	    SDL_GL_CONTEXT_MAJOR_VERSION,
	    SDL_GL_CONTEXT_MINOR_VERSION,
	    SDL_GL_CONTEXT_EGL,
	    SDL_GL_CONTEXT_FLAGS,
	    SDL_GL_CONTEXT_PROFILE_MASK,
	    SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
	    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
	    SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
	    SDL_GL_CONTEXT_RESET_NOTIFICATION,
	    SDL_GL_CONTEXT_NO_ERROR
	}

	#~
	State of the system's power supply
	~#
	enum PowererState {
		SDL_POWERSTATE_UNKNOWN,
	    SDL_POWERSTATE_ON_BATTERY,
	    SDL_POWERSTATE_NO_BATTERY,
	    SDL_POWERSTATE_CHARGING,
	    SDL_POWERSTATE_CHARGED
	}

	#~
	Texture access patterns
	~#
	enum TextureAccess {
	    SDL_TEXTUREACCESS_STATIC,
	    SDL_TEXTUREACCESS_STREAMING,
	    SDL_TEXTUREACCESS_TARGET
	}

	#~
	Mouse motion values
	~#
	consts MouseButtonValue {
		SDL_BUTTON_LEFT := 1,
		SDL_BUTTON_MIDDLE := 2,
		SDL_BUTTON_RIGHT := 3,
		SDL_BUTTON_X1 := 4,
		SDL_BUTTON_X2 := 5
	}

	#~
	Joystick hat values
	~#
	consts JoystickHatValue {
		SDL_HAT_CENTERED := 0x00,
		SDL_HAT_UP := 0x01,
		SDL_HAT_RIGHT := 0x02,
		SDL_HAT_DOWN := 0x04,
		SDL_HAT_LEFT := 0x08,
		SDL_HAT_RIGHTUP := 3,
		SDL_HAT_RIGHTDOWN := 6,
		SDL_HAT_LEFTUP := 9,
		SDL_HAT_LEFTDOWN := 12
	}

	#~
	Joystick types
	~#
	enum JoystickType {
	    SDL_JOYSTICK_TYPE_UNKNOWN,
	    SDL_JOYSTICK_TYPE_GAMECONTROLLER,
	    SDL_JOYSTICK_TYPE_WHEEL,
	    SDL_JOYSTICK_TYPE_ARCADE_STICK,
	    SDL_JOYSTICK_TYPE_FLIGHT_STICK,
	    SDL_JOYSTICK_TYPE_DANCE_PAD,
	    SDL_JOYSTICK_TYPE_GUITAR,
	    SDL_JOYSTICK_TYPE_DRUM_KIT,
	    SDL_JOYSTICK_TYPE_ARCADE_PAD,
	    SDL_JOYSTICK_TYPE_THROTTLE
	}

	#~
	Joystick power level
	SDL_JOYSTICK_POWER_EMPTY <= 5% 
    SDL_JOYSTICK_POWER_LOW <= 20% 
    SDL_JOYSTICK_POWER_MEDIUM <= 70% 
    SDL_JOYSTICK_POWER_FULL <= 100% 
	~#
	enum JoystickPowerLevel := -1 {
	    SDL_JOYSTICK_POWER_UNKNOWN,
	    SDL_JOYSTICK_POWER_EMPTY,
	    SDL_JOYSTICK_POWER_LOW,
	    SDL_JOYSTICK_POWER_MEDIUM,
	    SDL_JOYSTICK_POWER_FULL,
	    SDL_JOYSTICK_POWER_WIRED,
	    SDL_JOYSTICK_POWER_MAX
	}

	#~
	The list of axes available from a controller
	~#
	enum GameControllerAxis := -1 {
	    SDL_CONTROLLER_AXIS_INVALID,
	    SDL_CONTROLLER_AXIS_LEFTX,
	    SDL_CONTROLLER_AXIS_LEFTY,
	    SDL_CONTROLLER_AXIS_RIGHTX,
	    SDL_CONTROLLER_AXIS_RIGHTY,
	    SDL_CONTROLLER_AXIS_TRIGGERLEFT,
	    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
	    SDL_CONTROLLER_AXIS_MAX
	}

	#~
	The gamecontroller structure used to identify an SDL game controller
	~#
	enum GameControllerType {
	    SDL_CONTROLLER_TYPE_UNKNOWN,
	    SDL_CONTROLLER_TYPE_XBOX360,
	    SDL_CONTROLLER_TYPE_XBOXONE,
	    SDL_CONTROLLER_TYPE_PS3,
	    SDL_CONTROLLER_TYPE_PS4,
	    SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO,
	    SDL_CONTROLLER_TYPE_VIRTUAL,
	    SDL_CONTROLLER_TYPE_PS5,
	    SDL_CONTROLLER_TYPE_AMAZON_LUNA,
	    SDL_CONTROLLER_TYPE_GOOGLE_STADIA,
	    SDL_CONTROLLER_TYPE_NVIDIA_SHIELD,
	    SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_JOYCON_LEFT,
	    SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT,
	    SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_JOYCON_PAIR
	}

	#~
	The gamecontroller bind type
	~#
	enum GameControllerBindType {
	    SDL_CONTROLLER_BINDTYPE_NONE,
	    SDL_CONTROLLER_BINDTYPE_BUTTON,
	    SDL_CONTROLLER_BINDTYPE_AXIS,
	    SDL_CONTROLLER_BINDTYPE_HAT
	}

	#~
	The list of buttons available from a controller
	~#
	enum GameControllerButton := -1 {
	    SDL_CONTROLLER_BUTTON_INVALID,
	    SDL_CONTROLLER_BUTTON_A,
	    SDL_CONTROLLER_BUTTON_B,
	    SDL_CONTROLLER_BUTTON_X,
	    SDL_CONTROLLER_BUTTON_Y,
	    SDL_CONTROLLER_BUTTON_BACK,
	    SDL_CONTROLLER_BUTTON_GUIDE,
	    SDL_CONTROLLER_BUTTON_START,
	    SDL_CONTROLLER_BUTTON_LEFTSTICK,
	    SDL_CONTROLLER_BUTTON_RIGHTSTICK,
	    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
	    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
	    SDL_CONTROLLER_BUTTON_DPAD_UP,
	    SDL_CONTROLLER_BUTTON_DPAD_DOWN,
	    SDL_CONTROLLER_BUTTON_DPAD_LEFT,
	    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,
	    SDL_CONTROLLER_BUTTON_MISC1,
	    SDL_CONTROLLER_BUTTON_PADDLE1,
	    SDL_CONTROLLER_BUTTON_PADDLE2,
	    SDL_CONTROLLER_BUTTON_PADDLE3,
	    SDL_CONTROLLER_BUTTON_PADDLE4,
	    SDL_CONTROLLER_BUTTON_TOUCHPAD,
	    SDL_CONTROLLER_BUTTON_MAX
	}

	#~
	The different sensors defined by SDL
	~#
	enum SensorType := -1 {
	    SDL_SENSOR_INVALID,
	    SDL_SENSOR_UNKNOWN,
	    SDL_SENSOR_ACCEL,
	    SDL_SENSOR_GYRO
	}

	#~
	Pixel format values
	~#
	consts PixelValue {
		SDL_PIXELFORMAT_UNKNOWN := 0,
	    SDL_PIXELFORMAT_INDEX1LSB := 286261504,
	    SDL_PIXELFORMAT_INDEX1MSB := 287310080,
	    SDL_PIXELFORMAT_INDEX4LSB := 303039488,
	    SDL_PIXELFORMAT_INDEX4MSB := 304088064,
	    SDL_PIXELFORMAT_INDEX8 := 318769153,
	    SDL_PIXELFORMAT_RGB332 := 336660481,
	    SDL_PIXELFORMAT_RGB444 := 353504258,
	    SDL_PIXELFORMAT_RGB555 := 353570562,
	    SDL_PIXELFORMAT_RGB565 := 353701890,
	    SDL_PIXELFORMAT_ARGB4444 := 355602434,
	    SDL_PIXELFORMAT_ARGB1555 := 355667970,
	    SDL_PIXELFORMAT_RGBA4444 := 356651010,
	    SDL_PIXELFORMAT_RGBA5551 := 356782082,
	    SDL_PIXELFORMAT_BGR555 := 357764866,
	    SDL_PIXELFORMAT_BGR565 := 357896194,
	    SDL_PIXELFORMAT_ABGR4444 := 359796738,
	    SDL_PIXELFORMAT_ABGR1555 := 359862274,
	    SDL_PIXELFORMAT_BGRA4444 := 360845314,
	    SDL_PIXELFORMAT_BGRA5551 := 360976386,
	    SDL_PIXELFORMAT_RGB888 := 370546692,
	    SDL_PIXELFORMAT_RGBX8888 := 371595268,
	    SDL_PIXELFORMAT_ARGB8888 := 372645892,
	    SDL_PIXELFORMAT_ARGB2101010 := 372711428,
	    SDL_PIXELFORMAT_RGBA8888 := 373694468,
	    SDL_PIXELFORMAT_BGR888 := 374740996,
	    SDL_PIXELFORMAT_BGRX8888 := 375789572,
	    SDL_PIXELFORMAT_ABGR8888 := 376840196,
	    SDL_PIXELFORMAT_BGRA8888 := 377888772,
	    SDL_PIXELFORMAT_RGB24 := 386930691,
	    SDL_PIXELFORMAT_BGR24 := 390076419,
	    SDL_PIXELFORMAT_NV21 := 825382478,
	    SDL_PIXELFORMAT_NV12 := 842094158,
	    SDL_PIXELFORMAT_YV12 := 842094169,
	    SDL_PIXELFORMAT_YUY2 := 844715353,
	    SDL_PIXELFORMAT_YVYU := 1431918169,
	    SDL_PIXELFORMAT_IYUV := 1448433993,
	    SDL_PIXELFORMAT_UYVY := 1498831189
	}
	
	#~
	Hardware flags
	~#
	consts HardwareFlags {
		SDL_INIT_TIMER := 0x00000001,
		SDL_INIT_AUDIO := 0x00000010,
		SDL_INIT_VIDEO := 0x00000020,
		SDL_INIT_JOYSTICK := 0x00000200,
		SDL_INIT_HAPTIC := 0x00001000,
		SDL_INIT_GAMECONTROLLER := 0x00002000,
		SDL_INIT_EVENTS := 0x00004000
	}

	#~
	Hardware flags
	~#
	consts AudioFormat {
		SDL_AUDIO_U8 := 0x0008,
		SDL_AUDIO_S8 := 0x8008,
		SDL_AUDIO_U16LSB := 0x0010,
		SDL_AUDIO_S16LSB := 0x8010,
		SDL_AUDIO_U16MSB := 0x1010,
		SDL_AUDIO_S16MSB := 0x9010,
		SDL_AUDIO_U16 := 0x0010,
		SDL_AUDIO_S16 := 0x8010
	}

	#~
	Window flags
	~#
	consts WindowFlags {
		SDL_WINDOWPOS_UNDEFINED := 0x1FFF0000,
	    SDL_WINDOW_FULLSCREEN := 0x00000001,
	    SDL_WINDOW_OPENGL := 0x00000002,
	    SDL_WINDOW_SHOWN := 0x00000004,
	    SDL_WINDOW_HIDDEN := 0x00000008,
	    SDL_WINDOW_BORDERLESS := 0x00000010,
	    SDL_WINDOW_RESIZABLE := 0x00000020,
	    SDL_WINDOW_MINIMIZED := 0x00000040,
	    SDL_WINDOW_MAXIMIZED := 0x00000080,
	    SDL_WINDOW_INPUT_GRABBED := 0x00000100,
	    SDL_WINDOW_INPUT_FOCUS := 0x00000200,
	    SDL_WINDOW_MOUSE_FOCUS := 0x00000400,
	    SDL_WINDOW_FULLSCREEN_DESKTOP := 4097,
	    SDL_WINDOW_FOREIGN := 0x00000800,
	    SDL_WINDOW_ALLOW_HIGHDPI := 0x00002000,
	    SDL_WINDOW_MOUSE_CAPTURE := 0x00004000,
	    SDL_WINDOW_ALWAYS_ON_TOP := 0x00008000,
	    SDL_WINDOW_SKIP_TASKBAR := 0x00010000,
	    SDL_WINDOW_UTILITY := 0x00020000,
	    SDL_WINDOW_TOOLTIP := 0x00040000,
	    SDL_WINDOW_POPUP_MENU := 0x00080000,
	    SDL_WINDOW_VULKAN := 0x10000000
	}

	#~
	Event types
	~#
	consts EventType {
		SDL_QUERY := -1,
		SDL_IGNORE := 0,
		SDL_DISABLE := 0,
		SDL_ENABLE := 1,
		SDL_QUIT := 0x100,
		SDL_APP_TERMINATING := 0x101,
	    SDL_APP_LOWMEMORY := 0x102,
	    SDL_APP_WILLENTERBACKGROUND := 0x103,
	    SDL_APP_DIDENTERBACKGROUND := 0x104,
	    SDL_APP_WILLENTERFOREGROUND := 0x105,
	    SDL_APP_DIDENTERFOREGROUND := 0x106,
    	SDL_WINDOWEVENT := 0x200,
    	SDL_SYSWMEVENT := 0x201,
    	SDL_KEYDOWN := 0x300,
	    SDL_KEYUP := 0x301,
	    SDL_TEXTEDITING := 0x302,
	    SDL_TEXTINPUT := 0x303,
	    SDL_KEYMAPCHANGED := 0x304,
	    SDL_MOUSEMOTION := 0x400,
	    SDL_MOUSEBUTTONDOWN := 0x401,
	    SDL_MOUSEBUTTONUP := 0x402,
	    SDL_MOUSEWHEEL := 0x403,
	    SDL_JOYAXISMOTION := 0x600,
	    SDL_JOYBALLMOTION := 0x601,
	    SDL_JOYHATMOTION := 0x602,
	    SDL_JOYBUTTONDOWN := 0x603,
	    SDL_JOYBUTTONUP := 0x604,
	    SDL_JOYDEVICEADDED := 0x605,
	    SDL_JOYDEVICEREMOVED := 0x606,
	    SDL_CONTROLLERAXISMOTION := 0x650,
	    SDL_CONTROLLERBUTTONDOWN := 0x651,
	    SDL_CONTROLLERBUTTONUP := 0x652,
	    SDL_CONTROLLERDEVICEADDED := 0x653,
	    SDL_CONTROLLERDEVICEREMOVED := 0x654,
	    SDL_CONTROLLERDEVICEREMAPPED := 0x655,
	    SDL_FINGERDOWN := 0x700,
	    SDL_FINGERUP := 0x701,
	    SDL_FINGERMOTION := 0x702,
	    SDL_DOLLARGESTURE := 0x800,
	    SDL_DOLLARRECORD := 0x801,
	    SDL_MULTIGESTURE := 0x802,
	    SDL_CLIPBOARDUPDATE := 0x900,
	    SDL_DROPFILE := 0x1000,
	    SDL_DROPTEXT := 0x1001,
	    SDL_DROPBEGIN := 0x1002,
	    SDL_DROPCOMPLETE := 0x1003,
    	SDL_AUDIODEVICEADDED := 0x1100,
    	SDL_AUDIODEVICEREMOVED := 0x1101,
	    SDL_RENDER_TARGETS_RESET := 0x2000,
	    SDL_RENDER_DEVICE_RESET := 0x2000,
	    SDL_USEREVENT := 0x8000
	}
	
	#~
	Keyboard scan codes
	~#
	consts Scancode {
		SDL_SCANCODE_UNKNOWN := 0,
		SDL_SCANCODE_A := 4,
		SDL_SCANCODE_B := 5,
		SDL_SCANCODE_C := 6,
		SDL_SCANCODE_D := 7,
		SDL_SCANCODE_E := 8,
		SDL_SCANCODE_F := 9,
		SDL_SCANCODE_G := 10,
		SDL_SCANCODE_H := 11,
		SDL_SCANCODE_I := 12,
		SDL_SCANCODE_J := 13,
		SDL_SCANCODE_K := 14,
		SDL_SCANCODE_L := 15,
		SDL_SCANCODE_M := 16,
		SDL_SCANCODE_N := 17,
		SDL_SCANCODE_O := 18,
		SDL_SCANCODE_P := 19,
		SDL_SCANCODE_Q := 20,
		SDL_SCANCODE_R := 21,
		SDL_SCANCODE_S := 22,
		SDL_SCANCODE_T := 23,
		SDL_SCANCODE_U := 24,
		SDL_SCANCODE_V := 25,
		SDL_SCANCODE_W := 26,
		SDL_SCANCODE_X := 27,
		SDL_SCANCODE_Y := 28,
		SDL_SCANCODE_Z := 29,
		SDL_SCANCODE_1 := 30,
		SDL_SCANCODE_2 := 31,
		SDL_SCANCODE_3 := 32,
		SDL_SCANCODE_4 := 33,
		SDL_SCANCODE_5 := 34,
		SDL_SCANCODE_6 := 35,
		SDL_SCANCODE_7 := 36,
		SDL_SCANCODE_8 := 37,
		SDL_SCANCODE_9 := 38,
		SDL_SCANCODE_0 := 39,
		SDL_SCANCODE_RETURN := 40,
		SDL_SCANCODE_ESCAPE := 41,
		SDL_SCANCODE_BACKSPACE := 42,
		SDL_SCANCODE_TAB := 43,
		SDL_SCANCODE_SPACE := 44,
		SDL_SCANCODE_MINUS := 45,
		SDL_SCANCODE_EQUALS := 46,
		SDL_SCANCODE_LEFTBRACKET := 47,
		SDL_SCANCODE_RIGHTBRACKET := 48,
		SDL_SCANCODE_BACKSLASH := 49,
		SDL_SCANCODE_NONUSHASH := 50,
		SDL_SCANCODE_SEMICOLON := 51,
		SDL_SCANCODE_APOSTROPHE := 52,
		SDL_SCANCODE_GRAVE := 53,
		SDL_SCANCODE_COMMA := 54,
		SDL_SCANCODE_PERIOD := 55,
		SDL_SCANCODE_SLASH := 56,
		SDL_SCANCODE_CAPSLOCK := 57,
		SDL_SCANCODE_F1 := 58,
		SDL_SCANCODE_F2 := 59,
		SDL_SCANCODE_F3 := 60,
		SDL_SCANCODE_F4 := 61,
		SDL_SCANCODE_F5 := 62,
		SDL_SCANCODE_F6 := 63,
		SDL_SCANCODE_F7 := 64,
		SDL_SCANCODE_F8 := 65,
		SDL_SCANCODE_F9 := 66,
		SDL_SCANCODE_F10 := 67,
		SDL_SCANCODE_F11 := 68,
		SDL_SCANCODE_F12 := 69,
		SDL_SCANCODE_PRINTSCREEN := 70,
		SDL_SCANCODE_SCROLLLOCK := 71,
		SDL_SCANCODE_PAUSE := 72,
		SDL_SCANCODE_INSERT := 73,
		SDL_SCANCODE_HOME := 74,
		SDL_SCANCODE_PAGEUP := 75,
		SDL_SCANCODE_DELETE := 76,
		SDL_SCANCODE_END := 77,
		SDL_SCANCODE_PAGEDOWN := 78,
		SDL_SCANCODE_RIGHT := 79,
		SDL_SCANCODE_LEFT := 80,
		SDL_SCANCODE_DOWN := 81,
		SDL_SCANCODE_UP := 82,
		SDL_SCANCODE_NUMLOCKCLEAR := 83,
		SDL_SCANCODE_KP_DIVIDE := 84,
		SDL_SCANCODE_KP_MULTIPLY := 85,
		SDL_SCANCODE_KP_MINUS := 86,
		SDL_SCANCODE_KP_PLUS := 87,
		SDL_SCANCODE_KP_ENTER := 88,
		SDL_SCANCODE_KP_1 := 89,
		SDL_SCANCODE_KP_2 := 90,
		SDL_SCANCODE_KP_3 := 91,
		SDL_SCANCODE_KP_4 := 92,
		SDL_SCANCODE_KP_5 := 93,
		SDL_SCANCODE_KP_6 := 94,
		SDL_SCANCODE_KP_7 := 95,
		SDL_SCANCODE_KP_8 := 96,
		SDL_SCANCODE_KP_9 := 97,
		SDL_SCANCODE_KP_0 := 98,
		SDL_SCANCODE_KP_PERIOD := 99,
		SDL_SCANCODE_NONUSBACKSLASH := 100,
		SDL_SCANCODE_APPLICATION := 101,
		SDL_SCANCODE_POWER := 102,
		SDL_SCANCODE_KP_EQUALS := 103,
		SDL_SCANCODE_F13 := 104,
		SDL_SCANCODE_F14 := 105,
		SDL_SCANCODE_F15 := 106,
		SDL_SCANCODE_F16 := 107,
		SDL_SCANCODE_F17 := 108,
		SDL_SCANCODE_F18 := 109,
		SDL_SCANCODE_F19 := 110,
		SDL_SCANCODE_F20 := 111,
		SDL_SCANCODE_F21 := 112,
		SDL_SCANCODE_F22 := 113,
		SDL_SCANCODE_F23 := 114,
		SDL_SCANCODE_F24 := 115,
		SDL_SCANCODE_EXECUTE := 116,
		SDL_SCANCODE_HELP := 117,
		SDL_SCANCODE_MENU := 118,
		SDL_SCANCODE_SELECT := 119,
		SDL_SCANCODE_STOP := 120,
		SDL_SCANCODE_AGAIN := 121,
		SDL_SCANCODE_UNDO := 122,
		SDL_SCANCODE_CUT := 123,
		SDL_SCANCODE_COPY := 124,
		SDL_SCANCODE_PASTE := 125,
		SDL_SCANCODE_FIND := 126,
		SDL_SCANCODE_MUTE := 127,
		SDL_SCANCODE_VOLUMEUP := 128,
		SDL_SCANCODE_VOLUMEDOWN := 129,
		SDL_SCANCODE_KP_COMMA := 133,
		SDL_SCANCODE_KP_EQUALSAS400 := 134,
		SDL_SCANCODE_INTERNATIONAL1 := 135,
		SDL_SCANCODE_INTERNATIONAL2 := 136,
		SDL_SCANCODE_INTERNATIONAL3 := 137,
		SDL_SCANCODE_INTERNATIONAL4 := 138,
		SDL_SCANCODE_INTERNATIONAL5 := 139,
		SDL_SCANCODE_INTERNATIONAL6 := 140,
		SDL_SCANCODE_INTERNATIONAL7 := 141,
		SDL_SCANCODE_INTERNATIONAL8 := 142,
		SDL_SCANCODE_INTERNATIONAL9 := 143,
		SDL_SCANCODE_LANG1 := 144,
		SDL_SCANCODE_LANG2 := 145,
		SDL_SCANCODE_LANG3 := 146,
		SDL_SCANCODE_LANG4 := 147,
		SDL_SCANCODE_LANG5 := 148,
		SDL_SCANCODE_LANG6 := 149,
		SDL_SCANCODE_LANG7 := 150,
		SDL_SCANCODE_LANG8 := 151,
		SDL_SCANCODE_LANG9 := 152,
		SDL_SCANCODE_ALTERASE := 153,
		SDL_SCANCODE_SYSREQ := 154,
		SDL_SCANCODE_CANCEL := 155,
		SDL_SCANCODE_CLEAR := 156,
		SDL_SCANCODE_PRIOR := 157,
		SDL_SCANCODE_RETURN2 := 158,
		SDL_SCANCODE_SEPARATOR := 159,
		SDL_SCANCODE_OUT := 160,
		SDL_SCANCODE_OPER := 161,
		SDL_SCANCODE_CLEARAGAIN := 162,
		SDL_SCANCODE_CRSEL := 163,
		SDL_SCANCODE_EXSEL := 164,
		SDL_SCANCODE_KP_00 := 176,
		SDL_SCANCODE_KP_000 := 177,
		SDL_SCANCODE_THOUSANDSSEPARATOR := 178,
		SDL_SCANCODE_DECIMALSEPARATOR := 179,
		SDL_SCANCODE_CURRENCYUNIT := 180,
		SDL_SCANCODE_CURRENCYSUBUNIT := 181,
		SDL_SCANCODE_KP_LEFTPAREN := 182,
		SDL_SCANCODE_KP_RIGHTPAREN := 183,
		SDL_SCANCODE_KP_LEFTBRACE := 184,
		SDL_SCANCODE_KP_RIGHTBRACE := 185,
		SDL_SCANCODE_KP_TAB := 186,
		SDL_SCANCODE_KP_BACKSPACE := 187,
		SDL_SCANCODE_KP_A := 188,
		SDL_SCANCODE_KP_B := 189,
		SDL_SCANCODE_KP_C := 190,
		SDL_SCANCODE_KP_D := 191,
		SDL_SCANCODE_KP_E := 192,
		SDL_SCANCODE_KP_F := 193,
		SDL_SCANCODE_KP_XOR := 194,
		SDL_SCANCODE_KP_POWER := 195,
		SDL_SCANCODE_KP_PERCENT := 196,
		SDL_SCANCODE_KP_LESS := 197,
		SDL_SCANCODE_KP_GREATER := 198,
		SDL_SCANCODE_KP_AMPERSAND := 199,
		SDL_SCANCODE_KP_DBLAMPERSAND := 200,
		SDL_SCANCODE_KP_VERTICALBAR := 201,
		SDL_SCANCODE_KP_DBLVERTICALBAR := 202,
		SDL_SCANCODE_KP_COLON := 203,
		SDL_SCANCODE_KP_HASH := 204,
		SDL_SCANCODE_KP_SPACE := 205,
		SDL_SCANCODE_KP_AT := 206,
		SDL_SCANCODE_KP_EXCLAM := 207,
		SDL_SCANCODE_KP_MEMSTORE := 208,
		SDL_SCANCODE_KP_MEMRECALL := 209,
		SDL_SCANCODE_KP_MEMCLEAR := 210,
		SDL_SCANCODE_KP_MEMADD := 211,
		SDL_SCANCODE_KP_MEMSUBTRACT := 212,
		SDL_SCANCODE_KP_MEMMULTIPLY := 213,
		SDL_SCANCODE_KP_MEMDIVIDE := 214,
		SDL_SCANCODE_KP_PLUSMINUS := 215,
		SDL_SCANCODE_KP_CLEAR := 216,
		SDL_SCANCODE_KP_CLEARENTRY := 217,
		SDL_SCANCODE_KP_BINARY := 218,
		SDL_SCANCODE_KP_OCTAL := 219,
		SDL_SCANCODE_KP_DECIMAL := 220,
		SDL_SCANCODE_KP_HEXADECIMAL := 221,
		SDL_SCANCODE_LCTRL := 224,
		SDL_SCANCODE_LSHIFT := 225,
		SDL_SCANCODE_LALT := 226,
		SDL_SCANCODE_LGUI := 227,
		SDL_SCANCODE_RCTRL := 228,
		SDL_SCANCODE_RSHIFT := 229,
		SDL_SCANCODE_RALT := 230,
		SDL_SCANCODE_RGUI := 231,
		SDL_SCANCODE_MODE := 257,
		SDL_SCANCODE_AUDIONEXT := 258,
		SDL_SCANCODE_AUDIOPREV := 259,
		SDL_SCANCODE_AUDIOSTOP := 260,
		SDL_SCANCODE_AUDIOPLAY := 261,
		SDL_SCANCODE_AUDIOMUTE := 262,
		SDL_SCANCODE_MEDIASELECT := 263,
		SDL_SCANCODE_WWW := 264,
		SDL_SCANCODE_MAIL := 265,
		SDL_SCANCODE_CALCULATOR := 266,
		SDL_SCANCODE_COMPUTER := 267,
		SDL_SCANCODE_AC_SEARCH := 268,
		SDL_SCANCODE_AC_HOME := 269,
		SDL_SCANCODE_AC_BACK := 270,
		SDL_SCANCODE_AC_FORWARD := 271,
		SDL_SCANCODE_AC_STOP := 272,
		SDL_SCANCODE_AC_REFRESH := 273,
		SDL_SCANCODE_AC_BOOKMARKS := 274,
		SDL_SCANCODE_BRIGHTNESSDOWN := 275,
		SDL_SCANCODE_BRIGHTNESSUP := 276,
		SDL_SCANCODE_DISPLAYSWITCH := 277,
		SDL_SCANCODE_KBDILLUMTOGGLE := 278,
		SDL_SCANCODE_KBDILLUMDOWN := 279,
		SDL_SCANCODE_KBDILLUMUP := 280,
		SDL_SCANCODE_EJECT := 281,
		SDL_SCANCODE_SLEEP := 282,
		SDL_SCANCODE_APP1 := 283,
		SDL_SCANCODE_APP2 := 284
	}

	#~
	Keyboard modifier codes
	~#
	consts Keymod {
		KMOD_NONE := 0x0000,
	    KMOD_LSHIFT := 0x0001,
	    KMOD_RSHIFT := 0x0002,
	    KMOD_LCTRL := 0x0040,
	    KMOD_RCTRL := 0x0080,
	    KMOD_LALT := 0x0100,
	    KMOD_RALT := 0x0200,
	    KMOD_LGUI := 0x0400,
	    KMOD_RGUI := 0x0800,
	    KMOD_NUM := 0x1000,
	    KMOD_CAPS := 0x2000,
	    KMOD_MODE := 0x4000,
	    KMOD_RESERVED := 0x8000
	}

	#~
	Hint priorities
	~#
	consts HintPriority {
		SDL_HINT_DEFAULT := 0,
		SDL_HINT_NORMAL := 1,
		SDL_HINT_OVERRIDE := 2
	}

	#~
	Blend modes
	~#
	consts BlendMode {
		SDL_BLENDMODE_NONE := 0x00000000,
		SDL_BLENDMODE_BLEND := 0x00000001,
		SDL_BLENDMODE_ADD := 0x00000002,
		SDL_BLENDMODE_MOD := 0x00000004 
	}

	#~
	Image formats 
	~#
	consts ImageFlags {
	    IMG_INIT_JPG := 0x00000001,
	    IMG_INIT_PNG := 0x00000002,
	    IMG_INIT_TIF := 0x00000004,
	    IMG_INIT_WEBP := 0x00000008
	}

	#~
	Flip operations
	~#
	consts RendererFlip {
		SDL_FLIP_NONE := 0x00000000,
    	SDL_FLIP_HORIZONTAL := 0x00000001,
    	SDL_FLIP_VERTICAL := 0x00000002
	}

	#~
	Renderer flags
	~#
	consts RendererFlags {
	    SDL_RENDERER_SOFTWARE := 0x00000001,
	    SDL_RENDERER_ACCELERATED := 0x00000002,
	    SDL_RENDERER_PRESENTVSYNC := 0x00000004,
	    SDL_RENDERER_TARGETTEXTURE := 0x00000008
	}

	#~
	Video display 
	~#
	class Display {
		#~
		Get the number of video drivers compiled into SDL
		@return number >= 1 on success or a negative error code on failure
		~#
		function : GetNumVideoDrivers() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_num_video_drivers", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get the name of a built in video driver
		@param index the index of a video driver
		@return name of the video driver with the given index
		~#
		function : GetVideoDriver(index : Int) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(index);

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_video_driver", array_args);
			return array_args[0]->As(String);
		}

		#~
		Get the dots/pixels-per-inch for a display
		@param index index of the display from which DPI information should be queried
		@param ddpi pointer filled in with the diagonal DPI of the display; may be NULL
		@param hdpi pointer filled in with the horizontal DPI of the display; may be NULL
		@param vdpi pointer filled in with the vertical DPI of the display; may be NULL
		@return 0 on success or a negative error code on failure
		~#
		function : GetDPI(index : Int, ddpi : FloatRef, hdpi : FloatRef, vdpi : FloatRef) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(index);
			array_args[2] := ddpi;
			array_args[3] := hdpi;
			array_args[4] := vdpi;

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_display_dpi", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Initialize the video subsystem, optionally specifying a video driver
		@param driver_name name of a video driver to initialize, or Nil for the default driver
		@return 0 on success or a negative error code on failure
		~#
		function : VideoInit(driver_name : String) ~ Int {
			if(driver_name <> Nil) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := driver_name;

				Proxy->GetDllProxy()->CallFunction("sdl_display_video_init", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Shut down the video subsystem
		~#
		function : VideoQuit() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_display_video_quit", array_args);
		}
		
		#~
		Name of the currently initialized video driver
		@return name of the current video driver
		~#
		function : GetCurrentVideoDriver() ~ String {
			array_args := Base->New[1];
			array_args[0] := Nil;

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_current_video_driver", array_args);

			return array_args[0]->As(String);
		}
		
		#~
		Get the number of available video displays
		@return number >= 1 or a negative error code on failure
		~#
		function : GetNumVideoDisplays() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_num_video_displays", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get the name of a display in UTF-8 encoding
		@param displayIndex the index of display from which the name should be queried
		@return the name of a display
		~#
		function : GetDisplayName(displayIndex : Int) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(displayIndex);

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_display_name", array_args);

			return array_args[0];
		}
		
		#~
		Get the desktop area represented by a display, with the primary display located at 0,0
		@param displayIndex the index of the display to query
		@param rect the SDL_Rect structure filled in with the display bounds
		@return 0 on success or a negative error code on failure
		~#
		function : GetDisplayBounds(displayIndex : Int, rect : Rect) ~ Int {
			if(rect <> Nil) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(displayIndex);
				array_args[2] := rect;

				Proxy->GetDllProxy()->CallFunction("sdl_display_get_display_bounds", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Get the number of available display modes
		@param displayIndex the index of the display to query
		@return number >= 1 on success or a negative error code on failure
		~#
		function : GetNumDisplayModes(displayIndex : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(displayIndex);

			Proxy->GetDllProxy()->CallFunction("sdl_display_get_num_display_modes", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get information about a specific display mode
		@param displayIndex the index of the display to query
		@param modeIndex the index of the display mode to query
		@param mode an DisplayMode class filled in with the mode at modeIndex
		@return Returns 0 on success or a negative error code on failure
		~#
		function : GetDisplayMode(displayIndex : Int, modeIndex : Int, mode : DisplayMode) ~ Int {
			if(mode <> Nil) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(displayIndex);
				array_args[2] := IntRef->New(modeIndex);
				array_args[3] := mode;

				Proxy->GetDllProxy()->CallFunction("sdl_display_get_display_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Get information about the current display mode
		@param displayIndex the index of the display to query
		@param mode an DisplayMode class filled in with the current display mode
		@return Returns 0 on success or a negative error code on failure
		~#
		function : GetCurrentDisplayMode(displayIndex : Int, mode : DisplayMode) ~ Int {
			if(mode <> Nil) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(displayIndex);
				array_args[2] := mode;

				Proxy->GetDllProxy()->CallFunction("sdl_display_get_current_display_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Get the closest match to the requested display mode
		@param displayIndex the index of the display to query
		@param mode an SDL_DisplayMode structure containing the desired display mode
		@param closest an SDL_DisplayMode structure filled in with the closest match of the available display modes
		@return true of success, false otherwise 
		~#
		function : GetClosestDisplayMode(displayIndex : Int, mode : DisplayMode, closest : DisplayMode) ~ Bool {
			if(mode <> Nil & closest <> Nil) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(displayIndex);
				array_args[2] := mode;
				array_args[3] := closest;

				Proxy->GetDllProxy()->CallFunction("sdl_display_get_closest_display_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get() <> 0;
			};

			return false;
		}
	}
	
	#~
	SDL Window
	~#
	class Window {
		@window : Int;
		
		New(window : Int) {
			@window := window;
		}
		
		#~
		Creates a window with the specified position, dimensions, and flags
		@param title the title of the window, in UTF-8 encoding
		@param x the x position of the window, WindowFlags->SDL_WINDOWPOS_CENTERED, or WindowFlags->SDL_WINDOWPOS_UNDEFINED
		@param y the y position of the window, WindowFlags->SDL_WINDOWPOS_CENTERED, or WindowFlags->SDL_WINDOWPOS_UNDEFINED
		@param w the width of the window, in screen coordinates
		@param h the height of the window, in screen coordinates
		@param flags 0, or one or more WindowFlags OR'd together
		~#
		New(title : String, x : Int, y : Int, w : Int, h : Int, flags : Int) {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := title;
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(w);
			array_args[5] := IntRef->New(h);
			array_args[6] := IntRef->New(flags);

			Proxy->GetDllProxy()->CallFunction("sdl_window_create", array_args);

			value := array_args[0]->As(IntRef);
			@window := value->Get();
		}
		
		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @window = 0;
		}

		#~
		Get the window that currently has an input grab enabled
		@return window if input is grabbed or NULL otherwise
		~#
		function : GetGrabbedWindow() ~ Window {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_window_get_grabbed_window", array_args);

			value := array_args[0]->As(IntRef);
			return Window->New(value->Get());
		}

		#~
		Display a simple modal message box
		@param flags an SDL_MessageBoxFlags value
 		@param title UTF-8 title text
 		@param message UTF-8 message text
 		@param window the parent window, or NULL for no parent
 		@return 0 on success or a negative error code on failure
		~#
		function : ShowSimpleMessageBox(flags : Int, title : String, message : String, window : Window) ~ Int {
			array_args := Base->New[4];
			array_args[0] := IntRef->New(flags);
			array_args[1] := title;
			array_args[2] := message;
			array_args[3] := window;

			Proxy->GetDllProxy()->CallFunction("sdl_window_show_simple_messagebox", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the size of a window's underlying drawable in pixels (for use with glViewport).
		@param w a holder to variable for storing the width in pixels
		@param h a holder to variable for storing the height in pixels
		~#
		method : public : GLGetDrawableSize(w : IntRef, h : IntRef) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := w;
				array_args[2] := h;

				Proxy->GetDllProxy()->CallFunction("sdl_window_gl_get_drawable_size", array_args);
			};
		}
		
		#~
		Update a window with OpenGL rendering.
		~#
		method : public : GLSwap() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);
				Proxy->GetDllProxy()->CallFunction("sdl_window_gl_swap", array_args);
			};
		}
		
		#~
		Get the index of the display associated with a window
		@return index of the display containing the center of the window on success or a negative error code on failure
		~#
		method : public : GetDisplayIndex() ~ Int {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_display_index", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Set the display mode to use when a window is visible at full-screen
		@param mode the SDL_DisplayMode structure representing the mode to use, or NULL to use the window's dimensions and the desktop's format and refresh rate
		~#
		method : public : SetDisplayMode(mode : DisplayMode) ~ Int {
			if(@window <> 0 & mode <> Nil) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);
				array_args[2] := mode;

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_display_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the pixel format associated with the window
		@return pixel format of the window on success or SDL_PIXELFORMAT_UNKNOWN on failure
		~#
		method : public : GetPixelFormat() ~ Int {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_pixel_format", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the numeric ID of a window, for logging purposes
		@return the ID of the window on success or 0 on failure
		~#
		method : public : GetID() ~ Int {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_getid", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the numeric ID of a window, for logging purposes
		@param id window ID
		@return the ID of the window on success or 0 on failure
		~#
		method : public : GetFromID(id : Int) ~ Window {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(id);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_fromid", array_args);

				value := array_args[0]->As(IntRef);
				return Window->New(value->Get());
			};
			
			return Nil;
		}
		
		#~
		Get the window flags
		@return OR'd mask of the SDL_WindowFlags associated with window
		~#
		method : public : GetFlags() ~ Int {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_flags", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Set the title of a window
		@param title the desired window title in UTF-8 format
		~#
		method : public : SetTitle(title : String) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New(@window);
				array_args[1] := title;

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_title", array_args);
			};	
		}
		
		#~
		Set the icon for a window
		@param icon a Surface instance containing the icon for the window
		~#
		method : public : SetIcon(icon : Surface) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New(@window);
				array_args[1] := icon;

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_icon", array_args);
			};
		}
		
		#~
		Set the position of a window
		@param x the x coordinate of the window in screen coordinates, or WindowFlags->SDL_WINDOWPOS_CENTERED or WindowFlags->SDL_WINDOWPOS_UNDEFINED
		@param y the y coordinate of the window in screen coordinates, or WindowFlags->SDL_WINDOWPOS_CENTERED or WindowFlags->SDL_WINDOWPOS_UNDEFINED
		~#
		method : public : SetPosition(x : Int, y : Int) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := IntRef->New(x);
				array_args[2] := IntRef->New(y);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_position", array_args);
			};
		}
		
		#~
		Get the position of a window
		@param x pointer filled in with the x position of the window, in screen coordinates
		@param y pointer filled in with the y position of the window, in screen coordinates
		~#
		method : public : GetPosition(x : IntRef, y : IntRef) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := x;
				array_args[2] := y;

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_position", array_args);
			};
		}
		
		#~
		Set the size of a window's client area
		@param w width of the window in pixels, in screen coordinates, must be > 0
		@param h height of the window in pixels, in screen coordinates, must be > 0
		~#
		method : public : SetSize(w : Int, h : Int) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := IntRef->New(w);
				array_args[2] := IntRef->New(h);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_size", array_args);

			};
		}
		
		#~
		Get the size of a window's client area
		@param w pointer filled in with the width of the window, in screen coordinates
		@param h pointer filled in with the height of the window, in screen coordinates
		~#
		method : public : GetSize(w : IntRef, h : IntRef) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := w;
				array_args[2] := h;

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_size", array_args);
			};
		}
		
		#~
		Set the minimum size of a window's client area
		@param min_w the minimum width of the window in pixels
		@param min_h the minimum height of the window in pixels
		~#
		method : public : SetMinimumSize(min_w : Int, min_h : Int) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := IntRef->New(min_w);
				array_args[2] := IntRef->New(min_h);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_minimum_size", array_args);
			};
		}
		
		#~
		Get the minimum size of a window's client area
		@param w pointer filled in with the minimum width of the window
		@param h pointer filled in with the minimum height of the window
		~#
		method : public : GetMinimumSize(w : IntRef, h : IntRef) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := w;
				array_args[2] := h;

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_minimum_size", array_args);
			};
		}
		
		#~
		Set the maximum size of a window's client area
		@param max_w maximum width of the window in pixels
		@param max_h maximum height of the window in pixels
		~#
		method : public : SetMaximumSize(max_w : Int, max_h : Int) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := IntRef->New(max_w);
				array_args[2] := IntRef->New(max_h);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_maximum_size", array_args);
			};
		}
		
		#~
		Get the maximum size of a window's client area
		@param w pointer filled in with the maximum width of the window,
		@param h pointer filled in with the maximum height of the window
		~#
		method : public : GetMaximumSize(w : IntRef, h : IntRef) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New(@window);
				array_args[1] := w;
				array_args[2] := h;

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_maximum_size", array_args);
			};
		}
		
		#~
		Set the border state of a window
		@param bordered false to remove border, true to add border
		~#
		method : public : SetBordered(bordered : Bool) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New(@window);
				array_args[1] := IntRef->New(bordered ? 0 : 1);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_bordered", array_args);
			};
		}
		
		#~
		Show a window
		~#
		method : public : Show() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_show", array_args);
			};
		}
		
		#~
		Hide a window
		~#
		method : public : Hide() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_hide", array_args);
			};
		}
		
		#~
		Raise a window above other windows and set the input focus
		~#
		method : public : Raise() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_raise", array_args);
			};
		}
		
		#~
		Make a window as large as possible
		~#
		method : public : Maximize() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_maximize", array_args);
			};
		}
		
		#~
		Minimize a window to an iconic representation
		~#
		method : public : Minimize() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_minimize", array_args);
			};
		}
		
		#~
		Restore the size and position of a minimized or maximized window
		~#
		method : public : Restore() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_restore", array_args);

			};
		}
		
		#~
		Set a window's full-screen state
		@param flags WindowFlags->SDL_WINDOW_FULLSCREEN, WindowFlags->SDL_WINDOW_FULLSCREEN_DESKTOP or 0
		~#
		method : public : SetFullscreen(flags : Int) ~ Int {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);
				array_args[2] := IntRef->New(flags);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_fullscreen", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the SDL surface associated with the window
		@return surface associated with the window, or NULL on failure
		~#
		method : public : GetSurface() ~ Surface {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_surface", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};
			
			return Nil;
		}
		
		#~
		Use this function to copy the window surface to the screen
		~#
		method : public : UpdateSurface() ~ Int {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_update_surface", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
		
			return -1;
		}

		#~
		Set a window's input grab mode
		@param grabbed true to grab input or false to release input
		~#
		method : public : SetGrab(grabbed : Bool) ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New(@window);
				array_args[1] := IntRef->New(grabbed ? 0 : 1);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_grab", array_args);

			};
		}
		
		#~
		Get a window's input grab mode
		@return Returns true if input is grabbed, false otherwise
		~#
		method : public : GetGrab() ~ Bool {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_grab", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get() = 0 ? false : true;
			};
			
			return false;
		}
		
		#~
		Sets the brightness (gamma multiplier) for the display that owns a given window
		@param brightness the brightness (gamma multiplier) value to set where 0.0 is completely dark and 1.0 is normal brightness
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetBrightness(brightness : Float) ~ Int {
			if(@window <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);
				array_args[2] := FloatRef->New(brightness);

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_brightness", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Gets the brightness (gamma multiplier) for the display that owns a given window
		@return brightness for the display where 0.0 is completely dark and 1.0 is normal brightness
		~#
		method : public : GetBrightness() ~ Float {
			if(@window <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_brightness", array_args);

				value := array_args[0]->As(FloatRef);
				return value->Get();
			};
			
			return 0.0;
		}
		
		#~
		Sets the gamma ramp for the display that owns a given window
		@param red a 256 element array of 16-bit quantities representing the translation table for the red channel
		@param green a 256 element array of 16-bit quantities representing the translation table for the green channel
		@param blue a 256 element array of 16-bit quantities representing the translation table for the blue channel,
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetGammaRamp(red : IntRef, green : IntRef, blue : IntRef) ~ Int {
			if(@window <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);
				array_args[2] := red;
				array_args[3] := green;
				array_args[4] := blue;

				Proxy->GetDllProxy()->CallFunction("sdl_window_set_gamma_ramp", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Gets the gamma ramp for the display that owns a given window
		@param red a 256 element array of 16-bit quantities representing the translation table for the red channel
		@param green a 256 element array of 16-bit quantities representing the translation table for the green channel
		@param blue a 256 element array of 16-bit quantities representing the translation table for the blue channel,
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetGammaRamp(red : IntRef, green : IntRef, blue : IntRef) ~ Int {
			if(@window <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@window);
				array_args[2] := red;
				array_args[3] := green;
				array_args[4] := blue;

				Proxy->GetDllProxy()->CallFunction("sdl_window_get_gamma_ramp", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Destroy a window
		~#
		method : public : Destroy() ~ Nil {
			if(@window <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@window);
				Proxy->GetDllProxy()->CallFunction("sdl_window_destroy", array_args);
				@window := 0;
			};
		}
		
		#~
		Check whether the screensaver is currently enabled
		@return Returns true if the screensaver is enabled, false if it is disabled
		~#
		function : IsScreenSaverEnabled() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_window_is_screen_saver_enabled", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
		
		#~
		Allow the screen to be blanked by a screen saver
		~#
		function : EnableScreenSaver() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_window_enable_screen_saver", array_args);

		}
		
		#~
		Prevent the screen from being blanked by a screen saver
		~#
		function : DisableScreenSaver() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_window_disable_screen_saver", array_args);
		}
	}

	#~
	Key information used in key events
	~#
	class Keysym {
		@scancode : Scancode;
		@sym : Int;
		@mod : Int;
		
		New() {
		}
		
		#~
		Gets the scan code
		@return scan code 
		~#
		method : public : GetScancode() ~ Int {
			return @scancode;
		}
		
		#~
		Gets the symbol
		@return symbol
		~#
		method : public : GetSym() ~ Int {
			return @sym;
		}
		
		#~
		Gets the modifier
		@return modifier
		~#
		method : public : GetMod() ~ Int {
			return @mod;
		}
	}
	
	#~
	Keyboard event
	~#
	class KeyboardEvent {
		@type : Int;
		@timestamp : Int;
		@windowID : Int;
		@state : KeyState;
		@repeat : Int;
		@keysym : Keysym;
		
		New() {
			@keysym := Keysym->New();
		}
		
		#~
		Get the event type
		@return EventType->SDL_KEYDOWN or EventType->SDL_KEYUP
		~#
		method : public : GetType() ~ Int {
			return @type;
		}
		
		#~
		Get the event type
		@return EventType->SDL_KEYDOWN or EventType->SDL_KEYUP
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}
		
		#~
		Get the timestamp of the event
		@return timestamp of the event
		~#
		method : public : GetWindowID() ~ Int {
			return @windowID;
		}
		
		#~
		Get the state of the key
		@return KeyState->SDL_PRESSED or KeyState->SDL_RELEASED
		~#
		method : public : GetState() ~ KeyState {
			return @state;
		}
		
		#~
		Get key repeat
		@return non-zero if this is a key repeat
		~#
		method : public : GetRepeat() ~ Int {
			return @repeat;
		}
		
		#~
		The Keysym instance representing the key that was pressed or released
		@return key that was pressed or released
		~#
		method : public : GetKeysym() ~ Keysym {
			return @keysym;
		}
	}

	#~
	Handles keyboard operations
	~#
	class Keyboard {
		#~
		Get a snapshot of the current state of the keyboard
		@return pointer to an array of key states. A value 
		of 1 means that the key is pressed and a value of 0 
		means that it is not. Indexes into this array are 
		obtained by using SDL_Scancode values
		~#
		function : GetState() ~ Byte[] {
	        array_args := Base->New[1];
	        
	        Proxy->GetDllProxy()->CallFunction("sdl_keyboard_get_state", array_args);

	        value := array_args[0]->As(ByteArrayRef);
	        return value->Get();
		}

		#~
		Get the current key modifier state for the keyboard
		@return OR'd combination of the modifier keys for the keyboard
		~#
		function : GetModState() ~ Keymod {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_keyboard_get_mod_state", array_args);

			value := array_args[0]->As(IntRef);
	        return value->Get()->As(Keymod);
		}

		#~
		Start accepting Unicode text input events
		~#
		function : StartTextInput() ~ Nil {
			Proxy->GetDllProxy()->CallFunction("sdl_keyboard_start_text_input", Nil->As(Base[]));
		}

		#~
		Stop accepting Unicode text input events
		~#
		function : StopTextInput() ~ Nil {
			Proxy->GetDllProxy()->CallFunction("sdl_keyboard_stop_text_input", Nil->As(Base[]));
		}

		#~
		Set the rectangle used to type Unicode text inputs
		@param rect Rect structure representing the rectangle to receive text
		~#
		function : SetTextInputRect(rect : Rect) ~ Nil {
			array_args := Base->New[1];
		    array_args[0] := rect;
		    Proxy->GetDllProxy()->CallFunction("sdl_keyboard_set_text_input_rect", array_args);
		}
	}

	#~
	Clipboard handling
	~#
	class Clipboard {
		#~
		Put UTF-8 text into the clipboard.
		@param text the text to store in the clipboard
		@return 0 on success or a negative error code on failure
		~#
		function : SetClipboardText(text : String) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := text;

			Proxy->GetDllProxy()->CallFunction("sdl_power_set_clipboard_text", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get UTF-8 text from the clipboard
		@return clipboard text on success or NULL on failure
		~#
		function : GetClipboardText() ~ String {
			array_args := Base->New[1];
			array_args[0] := Nil;

			Proxy->GetDllProxy()->CallFunction("sdl_power_get_clipboard_text", array_args);

			return array_args[0]->As(String);
		}

		#~
		Flag indicating whether the clipboard exists and contains a text string that is non-empty
		@return true if the clipboard has text, or false if it does not
		~#
		function : HasClipboardText() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_power_has_clipboard_text", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
	}

	#~
	Handles inputs from joysticks
	~#
	class GameController {
		@gamecontroller : Int;

		#~
		Open a game controller for use.
		@param joystick_index the device_index
		~#
		New(joystick_index : Int) {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(joystick_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_open", array_args);

	        value := array_args[0]->As(IntRef);
	        @gamecontroller := value->Get();
		}

		#~
		Add support for controllers that SDL is unaware of or to cause an existing controller to have a different binding
		@param mapping_string the mapping string
		@return 1 if a new mapping is added, 0 if an existing mapping is updated, -1 on error
		~#
		function : AddMapping(mapping_string : String) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := mapping_string;

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_add_mapping", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the number of mappings installed
		@return the number of mappings
		~#
		function : NumMappings() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_num_mappings", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		function : MappingForIndex(mapping_index : Int) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(mapping_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_mapping_for_index", array_args);

			return array_args[0];
		}

		#~
		Get the current mapping of a Game Controller
		@return string that has the controller's mapping or NULL if no mapping is available
		~#
		method : public : Mapping() ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_mapping", array_args);

			return array_args[0];
		}

		#~
		Check if the given joystick is supported by the game controller interface
		@param joystick_index the device_index of a device
		@return joystick_index the device_index of a device
		~#
		function : IsController(joystick_index : Int) ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(joystick_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_sdl_is_game_controller", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Get the implementation dependent name for the game controller
		@param joystick_index the device_index of a device
		@return joystick_index the device_index of a device
		~#
		function : NameForIndex(joystick_index : Int) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(joystick_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_name_for_index", array_args);

			return array_args[0];
		}

		#~
		This function can be called before any controllers are opened
 		@param joystick_index the device_index of a device
		@return the implementation-dependent path for the game controller, or Nil
		
		function : PathForIndex(joystick_index : Int) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(joystick_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_path_for_index", array_args);

			return array_args[0];
		}
		
		Get the type of a game controller. This can be called before any controllers are opened.
 		@param joystick_index the device_index of a device
 		@return the controller type
		
		function : TypeForIndex(joystick_index : Int) ~ GameControllerType {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(joystick_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_type_for_index", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get()->As(GameControllerType);
		}
 		~#

		#~
		Get the SDL_GameController associated with an instance id
 		@param joyid the instance id to get the SDL_GameController for
 		@return an SDL_GameController on success or NULL on failure
 		~#
		function : FromInstanceID(joyid : Int) ~ GameController {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(joyid);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_from_instanceid", array_args);
			
			value := array_args[0]->As(IntRef);
			return GameController->New(value->Get());
		}

		#~
		Get the SDL_GameController associated with an instance id
 		@param player_index the player index, which is not the device index or the instance id!
 		@return an SDL_GameController on success or NULL on failure
 		
		method : public : FromPlayerIndex(player_index : Int) ~ GameController {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(player_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_from_player_index", array_args);

			value := array_args[0]->As(IntRef);
			return GameController->New(value->Get());
		}
		~#

		#~
		Get the SDL_GameController associated with an instance id
 		@param joyid the instance id to get the SDL_GameController for
 		@return an SDL_GameController on success or NULL on failure
 		~#
		method : public : Name() ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_name", array_args);

			return array_args[0];
		}
	
		#~
		Get the SDL_GameController associated with an instance id
		@param joyid the instance id to get the SDL_GameController for
		@return an SDL_GameController on success or NULL on failure
		
		method : public : Path() ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_path", array_args);

			return array_args[0];
		}
		
		Get the type of this currently opened controller
		@return the controller type.

		method : public : GetType() ~ GameControllerType {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_type", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get()->As(GameControllerType);
		}
		~#
	
		#~
		Get the player index of an opened game controller
		@return the player index for controller, or -1 if it's not available
		~#
		method : public : GetPlayerIndex() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_player_index", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the player index of an opened game controller
 		@param player_index Player index to assign to this controller, or -1 to clear the player index and turn off player LEDs.
		@return the player index for controller, or -1 if it's not available
		
		method : public : SetPlayerIndex(player_index : Int) ~ Nil {
			array_args := Base->New[2];
			array_args[0] := IntRef->New(@gamecontroller);
			array_args[1] := IntRef->New(player_index);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_set_player_index", array_args);
		}
		~#

		#~
		Get the USB vendor ID of an opened controller, if available
		@return the USB vendor ID, or zero if unavailable
		~#
		method : public : GetVendor() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_vendor", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the USB product ID of an opened controller, if available
		@return the USB product ID, or zero if unavailable
		~#
		method : public : GetProduct() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_product", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the product version of an opened controller, if available. 
		If the product version isn't available this function returns 0.
		@return the USB product version, or zero if unavailable
		~#
		method : public : GetProductVersion() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_product_version", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the firmware version of an opened controller, if available
		@return the controller firmware version, or zero if unavailable
		
		method : public : GetFirmwareVersion() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_firmware_version", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}


		Get the serial number of an opened controller, if available
		@return the serial number, or NULL if unavailable

		method : public : GetSerial() ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_serial", array_args);

			return array_args[0];
		}
		~#

		#~
		Check if a controller has been opened and is currently connected.
		@return true if the controller has been opened and is currently connected, or false if not
		~#
		method : public : GetAttached() ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_attached", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		This function will give you a SDL_Joystick object, which allows you to use the SDL_Joystick functions with a SDL_GameController object
		@return a Joystick object
		~#
		method : public : GetJoystick() ~ Joystick {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_joystick", array_args);

			value := array_args[0]->As(IntRef);
			return Joystick->New(value->Get());
		}


		#~
		Query or change current state of Game Controller events
		@param state can be one of 'SDL_QUERY', 'SDL_IGNORE', or 'SDL_ENABLE'
		@return the same value passed to the function, with exception to -1, which will return the current state
		~#
		function : EventState(state : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(state);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_event_state", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Manually pump game controller updates if not using the loop.
		~#
		function : Update() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_update", array_args);
		}

		#~
		Convert a string into SDL_GameControllerAxis enum
		@param str string representing a SDL_GameController axis
		@return the GameControllerAxis enum corresponding to the input string, or SDL_CONTROLLER_AXIS_INVALID if no match was found.
		~#
		function : GetAxisFromString(str : String) ~ GameControllerAxis {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := str;

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontorller_get_axis_from_string", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Convert from an SDL_GameControllerAxis enum to a string
		@param axis an enum value for a given GameControllerAxis
		@return string for the given axis, or Nil if an invalid axis is specified
		~#
		function : GetStringForAxis(axis : GameControllerAxis) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(axis);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_string_for_axis", array_args);

			return array_args[0];
		}

		#~
		Get the SDL joystick layer binding for a controller axis mapping
		@param axis an axis enum value (one of the SDL_GameControllerAxis values)
		@return SDL_GameControllerButtonBind describing the bind
		~#
		method : public : GetBindForAxis(axis : GameControllerAxis) ~ GameControllerButtonBind {
			array_args := Base->New[3];
			array_args[0] := GameControllerButtonBind->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(axis);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_bind_for_axis", array_args);

			return array_args[0];
		}

		#~
		Query whether a game controller has a given axis
		@param axis an axis enum value (an SDL_GameControllerAxis value)
 		@return true if the controller has this axis, false otherwise
 		
		method : public : HasAxis(axis : GameControllerAxis) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(axis);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_has_axis", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
		~#

		#~
		Get the current state of an axis control on a game controller
		@param axis an axis index (one of the SDL_GameControllerAxis values)
 		@return axis state (including 0) on success or 0 (also) on failure
 		~#
		method : public : GetAxis(axis : GameControllerAxis) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(axis);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_axis", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Convert a string into an SDL_GameControllerButton enum
		@param str string representing a SDL_GameController axis
 		@return the SDL_GameControllerButton enum corresponding to the input string
 		~#
		function : GetButtonFromString(str : String) ~ GameControllerButton {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := str;

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_button_from_string", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Convert from an SDL_GameControllerButton enum to a string
		@param button an enum value for a given GameControllerButton
 		@return a string for the given button
		~#
		function : GetStringForButton(button : GameControllerButton) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(button);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_string_for_button", array_args);

			return array_args[0];
		}

		#~
		Get the SDL joystick layer binding for a controller button mapping
		@param button an button enum value (an SDL_GameControllerButton value)
 		@return SDL_GameControllerButtonBind describing the bind
 		~#
		method : public : GetBindForButton(button : GameControllerButton) ~ GameControllerButtonBind {
			array_args := Base->New[3];
			array_args[0] := GameControllerButtonBind->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(button);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_bind_for_button", array_args);

			return array_args[0];
		}

		#~
		Query whether a game controller has a given button
		@param button a button enum value (an SDL_GameControllerButton value)
 		@return true if the controller has this button, false otherwise
 		
		method : public : HasButton(button : GameControllerButton) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(button);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_has_button", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
		~#

		#~
		Get the current state of a button on a game controller
		@param button a button index (one of the SDL_GameControllerButton values)
 		@return 1 for pressed state or 0 for not pressed state or error
 		~#
		method : public : GetButton(button : GameControllerButton) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(button);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_button", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get the number of touchpads on a game controller.
		~#
		method : public : GetNumTouchpads() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_num_touchpads", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the number of supported simultaneous fingers on a touchpad on a game controller.
		@param touchpad touchpad
		
		method : public : GetNumTouchpadFingers(touchpad : Int) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(touchpad);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_num_touchpad_fingers", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		
		Get the current state of a finger on a touchpad on a game controller.
		@param touchpad touchpad
		@param finger finger 
		@param state state
		@param x x
		@param y y
		@param pressure pressure
		@return 0 on success or a negative error code on failure
		
		method : public : GetTouchpadFinger(touchpad : Int, finger : Int, state : IntRef, x : FloatRef, y : FloatRef, pressure : FloatRef) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(touchpad);
			array_args[3] := IntRef->New(finger);
			array_args[4] := state;
			array_args[5] := x;
			array_args[6] := y;
			array_args[7] := pressure;

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_touchpad_finger", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		
		Return whether a game controller has a particular sensor.
		@param type The type of sensor to query
 		@return true if the sensor exists, false otherwise
 		
		method : public : HasSensor(type : SensorType) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(type);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_has_sensor", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		
		Set whether data reporting for a game controller sensor is enabled
		@param type The type of sensor to enable/disable
 		@param enabled Whether data reporting should be enabled
 		@return 0 or -1 if an error occurred
		
		method : public : SetSensorEnabled(type : SensorType, enabled : Bool) ~ Int {
			array_args := Base->New[4];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(type);
			array_args[3] := IntRef->New(enabled ? 0 : 1);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_set_sensor_enabled", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		
		Query whether sensor data reporting is enabled for a game controller.
		@param type The type of sensor to query
 		@return true if the sensor is enabled, false otherwise
 		
		method : public : IsSensorEnabled(type : SensorType) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(type);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_is_sensor_enabled", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		
		Get the data rate (number of events per second) of a game controller sensor
		@param type The type of sensor to query
 		@return the data rate, or 0.0f if the data rate is not available
		
		method : public : GetSensorDataRate(type : SensorType) ~ Float {
			array_args := Base->New[3];
			array_args[0] := FloatRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(type);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_sensor_data_rate", array_args);

			value := array_args[0]->As(FloatRef);
			return value->Get();
		}
		
		Get the current state of a game controller sensor
		@param type The type of sensor to query
		@param data A pointer filled with the current sensor state
		@param num_values The number of values to write to data
		@return 0 or -1 if an error occurred
		
		method : public : GetSensorData(type : SensorType, data : FloatRef, num_values : Int) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(type);
			array_args[3] := data;
			array_args[4] := IntRef->New(num_values);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_sensor_data", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		~#

		#~
		Start a rumble effect on a game controller
		@param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF
		@param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF
		@param duration_ms The duration of the rumble effect, in milliseconds
		@return 0, or -1 if rumble isn't supported on this controller
		~#
		method : public : Rumble(low_frequency_rumble : Int, high_frequency_rumble : Int, duration_ms : Int) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(low_frequency_rumble);
			array_args[3] := IntRef->New(high_frequency_rumble);
			array_args[4] := IntRef->New(duration_ms);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_rumble", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Start a rumble effect in the game controller's triggers
		@param left_rumble The intensity of the left trigger rumble motor, from 0 to 0xFFFF
		@param right_rumble The intensity of the right trigger rumble motor, from 0 to 0xFFFF
		@param duration_ms The duration of the rumble effect, in milliseconds
		@return 0, or -1 if trigger rumble isn't supported on this controller
		
		method : public : RumbleTriggers(left_rumble : Int, right_rumble : Int, duration_ms : Int) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(left_rumble);
			array_args[3] := IntRef->New(right_rumble);
			array_args[4] := IntRef->New(duration_ms);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_rumble_triggers", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		

		
		Query whether a game controller has an LED
		@return true, or false if this controller does not have a modifiable LED
		
		method : public : HasLED() ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_hasled", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		Query whether a game controller has rumble support
		@return true, or false if this controller does not have rumble support
		
		method : public : HasRumble() ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_has_rumble", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		
		Query whether a game controller has rumble support on triggers
		@return true, or false if this controller does not have trigger rumble support
		
		method : public : HasRumbleTriggers() ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_has_rumble_triggers", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		
		Update a game controller's LED color
		@param red The intensity of the red LED
		@param green The intensity of the green LED
		@param blue The intensity of the blue LED
		@return 0, or -1 if this controller does not have a modifiable LED
		
		method : public : SetLED(red : Int, green : Int, blue : Int) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(red);
			array_args[3] := IntRef->New(green);
			array_args[4] := IntRef->New(blue);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_setled", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		~#

		#~
		Close a game controller previously opened
		~#
		method : public : Close() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@gamecontroller);
			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_close", array_args);
		}

		#~
		Return the sfSymbolsName for a given button on a game controller on Apple platforms
		@param button a button on the game controller
		@return the sfSymbolsName or NULL if the name can't be found
		
		method : public : GetAppleSFSymbolsNameForButton(button : GameControllerButton) ~ String {
			array_args := Base->New[3];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(button);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_applesf_symbols_name_for_button", array_args);

			return array_args[0];
		}

		
		Return the sfSymbolsName for a given axis on a game controller on Apple platforms
		@param axis an axis on the game controller
		@return the sfSymbolsName or NULL if the name can't be found
		
		method : public : GetAppleSFSymbolsNameForAxis(axis : GameControllerAxis) ~ String {
			array_args := Base->New[3];
			array_args[0] := Nil;
			array_args[1] := IntRef->New(@gamecontroller);
			array_args[2] := IntRef->New(axis);

			Proxy->GetDllProxy()->CallFunction("sdl_gamecontroller_get_applesf_symbols_name_for_axis", array_args);

			return array_args[0];
		}
		~#
	}

	#~
	Handles inputs from joysticks
	~#
	class Joystick {
		@joystick : Int;

		#~
		Open a joystick for use
		@param device_index index of the joystick to query
		~#
		New(device_index : Int) {
			array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(device_index);

	        Proxy->GetDllProxy()->CallFunction("sdl_joystick_open", array_args);

	        value := array_args[0]->As(IntRef);
	        @joystick := value->Get();
		}

		#~
		Get the type of an opened joystick
		@return the JoystickType of the selected joystick
		~#
		method : public : GetType() ~ JoystickType {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@joystick);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_type", array_args);

			value := array_args[0]->As(IntRef);
	        return value->Get()->As(JoystickType);
		}

		#~
		Get the USB product ID of an opened joystick, if available
		@return the product version of the selected joystick, or 0 if unavailable.
		~#
		method : public : GetProduct() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@joystick);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_product", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the USB vendor ID of an opened joystick, if available
		@return the USB vendor ID of the selected joystick, or 0 if unavailable
		~#
		method : public : GetVendor() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@joystick);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_vendor", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the type of a joystick, if available
		@param device_index the index of the joystick to query (the N'th joystick on the system
		@return the SDL_JoystickType of the selected joystick. If called on an invalid index
		~#
		method : public : GetDeviceType(device_index : Int) ~ JoystickType {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(device_index);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_device_type", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get()->As(JoystickType);
		}

		#~
		Get the product version of a joystick, if available
		@param device_index the index of the joystick to query (the N'th joystick on the system
		@return the product version of the selected joystick. If called on an invalid index, this function returns zero
		~#
		function : GetDeviceProductVersion(device_index : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(device_index);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_device_product_version", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the USB product ID of a joystick, if available
		@param device_index the index of the joystick to query (the N'th joystick on the system
		@return the USB product ID of the selected joystick. If called on an invalid index, this function returns zero
		~#
		function : GetDeviceProduct(device_index : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(device_index);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_device_product", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the USB vendor ID of a joystick, if available
		@param device_index the index of the joystick to query (the N'th joystick on the system
		@return the USB vendor ID of the selected joystick. If called on an invalid index, this function returns zero
		~#
		method : public : GetDeviceVendor(device_index : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(device_index);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_device_vendor", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the instance ID of a joystick
		@param device_index the index of the joystick to query (the N'th joystick on the system
		@return the instance id of the selected joystick. If called on an invalid index, this function returns zero
		~#
		function : GetDeviceInstanceID(device_index : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(device_index);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_device_instanceid", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the product version of an opened joystick, if available
		@return the firmware version of the selected joystick, or 0 if unavailable
		~#
		method : public : GetProductVersion() ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@joystick);

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_product_version", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the initial state of an axis control on a joystick
		@param axis the axis to query; the axis indices start at index 0
		@param state Upon return, the initial value is supplied here
		@return true if this axis has any initial value, or false if not
		~#
		method : public : GetAxisInitialState(axis : Int, state : IntRef) ~ Bool {
			array_args := Base->New[4];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@joystick);
			array_args[2] := IntRef->New(axis);
			array_args[3] := state;

			Proxy->GetDllProxy()->CallFunction("sdl_joystick_sdl_joystick_get_axis_initial_state", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
	    Get the Joystick associated with an instance id.
	    @param instance_id the instance id to get the SDL_Joystick for
	    @return instance_id the instance id to get the SDL_Joystick for
	    ~#
	    function : FromInstanceID(instance_id : Int) ~ Joystick {
	        array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(instance_id);

	        Proxy->GetDllProxy()->CallFunction("sdl_joystick_from_instance_id", array_args);

	        value := array_args[0]->As(IntRef);
	        return Joystick->New(value->Get());
		}

		#~
	    Get the battery level of a joystick as JoystickPowerLevel
	    @return current battery level as JoystickPowerLevel on success or SDL_JOYSTICK_POWER_UNKNOWN
	    ~#
	    method : public : CurrentPowerLevel() ~ JoystickPowerLevel {
	    	if(@joystick <> 0) {
		        array_args := Base->New[2];
		        array_args[0] := IntRef->New();
		        array_args[1] := IntRef->New(@joystick);

		        Proxy->GetDllProxy()->CallFunction("sdl_joystick_current_power_level", array_args);

		        value := array_args[0]->As(IntRef);
		       	return value->Get();
		    };

		    return JoystickPowerLevel->SDL_JOYSTICK_POWER_UNKNOWN;
		}

		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @joystick = 0;
		}

		#~
		Close joystick previously opened
		~#
		method : public : Free() ~ Nil {
			if(@joystick <> 0) {
				array_args := Base->New[1];
		        array_args[0] := IntRef->New(@joystick);

				Proxy->GetDllProxy()->CallFunction("sdl_joystick_close", array_args);
				@joystick := 0;
			}; 
	    }

	    #~
	    Count of the number of joysticks attached to the system
	    @return number of attached joysticks on success or a negative error code on failure
	    ~#
	    function : Number() ~ Int {
	        array_args := Base->New[1];
	        array_args[0] := IntRef->New();

	        Proxy->GetDllProxy()->CallFunction("sdl_joystick_nums", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}

		#~
		Get the implementation dependent name of a joystick
		@return name of the selected joystick. If no name can be found, this function returns NULL,
		~#
		method : public : GetName() ~ String {
	        array_args := Base->New[2];
	        array_args[0] := Nil;
	        array_args[1] := IntRef->New(@joystick);

	        Proxy->GetDllProxy()->CallFunction("sdl_joystick_name", array_args);

	        return array_args[0];
		}
	}

	#~
	Joysticks axis event
	~#
	class JoyAxisEvent {
		@type : Int;
		@timestamp : Int;
		@which : Int;
		@axis : Int;
		@value : Int;

		New() {			
		}

		#~
		Event type
		@return EventType->SDL_JOYAXISMOTION
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Instance ID of the joystick that reported the event
		@return joystick ID
		~#
		method : public : GetWhich() ~ Int {
			return @which;
		}

		#~
		Index of the axis that changed
		@return axis index
		~#
		method : public : GetAxis() ~ Int {
			return @axis;
		}
		
		#~
		Current position of the axis (range: -32768 to 32767)
		@return axis position
		~#
		method : public : GetValue() ~ Int {
			return @value;
		}
	}

	#~
	Joysticks hat event
	~#
	class JoyHatEvent {
		@type : Int;
		@timestamp : Int;
		@which : Int;
		@hat : Int;
		@value : JoystickHatValue;

		New() {			
		}

		#~
		Event type
		@return EventType->SDL_JOYHATMOTION
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Instance ID of the joystick that reported the event
		@return joystick ID
		~#
		method : public : GetWhich() ~ Int {
			return @which;
		}

		#~
		Index of the hat that changed
		@return hat index
		~#
		method : public : GetHat() ~ Int {
			return @hat;
		}
		
		#~
		New position of the hat
		@return hat value
		~#
		method : public : GetValue() ~ JoystickHatValue {
			return @value;
		}
	}

	#~
	Joysticks button event
	~#
	class JoyButtonEvent {
		@type : Int;
    	@timestamp : Int;
    	@which : Int;
    	@button : Int;
    	@state : KeyState;

    	New() {			
		}

		#~
		Event type
		@return EventType->SDL_JOYBUTTONDOWN or EventType->SDL_JOYBUTTONUP
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Instance ID of the joystick that reported the event
		@return joystick ID
		~#
		method : public : GetWhich() ~ Int {
			return @which;
		}

		#~
		Index of the button that changed
		@return button index
		~#
		method : public : GetButton() ~ Int {
			return @button;
		}
		
		#~
		State of the button
		@return KeyState->SDL_PRESSED or KeyState->SDL_RELEASED
		~#
		method : public : GetState() ~ KeyState {
			return @state;
		}
	}

	#~
	Mouse motion event
	~#
	class MouseMotionEvent {
		@type : Int;
	    @timestamp : Int;
	    @windowID : Int;
	    @which : Int;
	    @state : Int;
	    @x : Int;
	    @y : Int;
	    @xrel : Int;
	    @yrel : Int;

	    New() {			
		}

		#~
		Event type
		@return EventType->SDL_MOUSEMOTION
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Window with mouse focus, if any
		@return window ID
		~#
		method : public : GetWindowID() ~ Int {
			return @windowID;
		}

		#~
		Mouse instance id or -1
		~#
		method : public : GetWhich() ~ Int {
			return @which;
		}

		#~
		State of the button
		@return button state
		~#
		method : public : GetState() ~ Int {
			return @state;
		}

		#~
		X coordinate, relative to window
		@return X coordinate
		~#
		method : public : GetX() ~ Int {
			return @x;
		}

		#~
		Y coordinate, relative to window
		@return Y coordinate
		~#
		method : public : GetY() ~ Int {
			return @y;
		}

		#~
		Relative motion in the X direction
		@return X direction
		~#
		method : public : GetRelX() ~ Int {
			return @xrel;
		}

		#~
		Relative motion in the Y direction
		@return Y direction
		~#
		method : public : GetRelY() ~ Int {
			return @yrel;
		}
	}

	#~
	Mouse button event
	~#
	class MouseButtonEvent {
		@type : Int;
	    @timestamp : Int;
	    @windowID : Int;
	    @which : MouseButtonValue;
	    @button : Int;
	    @state : KeyState;
	    @clicks : Int;
	    @x : Int;
	    @y : Int;

	    New() {			
		}

		#~
		Event type
		@return EventType->SDL_MOUSEBUTTONDOWN or EventType->SDL_MOUSEBUTTONUP
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Window with mouse focus, if any
		@return window ID
		~#
		method : public : GetWindowID() ~ Int {
			return @windowID;
		}

		#~
		Mouse instance id or -1
		~#
		method : public : GetWhich() ~ Int {
			return @which;
		}

		#~
		Button that changed
		@return changed button
		~#
		method : public : GetButton() ~ MouseButtonValue {
			return @button;
		}

		#~
		State of the button
		@return button state
		~#
		method : public : GetState() ~ KeyState {
			return @state;
		}

		#~
		Number of clicks
		@return 1 for single-click, 2 for double-click, etc.
		~#
		method : public : GetClicks() ~ Int {
			return @clicks;
		}

		#~
		X coordinate, relative to window
		@return X coordinate
		~#
		method : public : GetX() ~ Int {
			return @x;
		}

		#~
		Y coordinate, relative to window
		@return Y coordinate
		~#
		method : public : GetY() ~ Int {
			return @y;
		}
	}

	#~
	Mouse wheel event
	~#
	class MouseWheelEvent {
		@type : Int;
	    @timestamp : Int;
	    @windowID : Int;
	    @which : Int;
	    @x : Int;
	    @y : Int;
	    @direction : MouseWheelDirection;

	    New() {			
		}

		#~
		Event type
		@return EventType->SDL_MOUSEWHEEL
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Window with mouse focus, if any
		@return window ID
		~#
		method : public : GetWindowID() ~ Int {
			return @windowID;
		}

		#~
		Mouse instance id or -1
		~#
		method : public : GetWhich() ~ Int {
			return @which;
		}

		#~
		Amount scrolled horizontally, positive to the right and negative to the left
		@return horizontally scrolled value
		~#
		method : public : GetX() ~ Int {
			return @x;
		}

		#~
		Amount scrolled vertically, positive away from the user and negative toward the user
		@return vertically scrolled value
		~#
		method : public : GetY() ~ Int {
			return @y;
		}

		#~
		Mouse wheel scroll direction
		@return SDL_MOUSEWHEEL_NORMAL or SDL_MOUSEWHEEL_FLIPPED
		~#
		method : public : GetDirection() ~ MouseWheelDirection {
			return @direction;
		}		
	}
		
	#~
	Text input event
	~#
	class TextInputEvent {
		@type : Int;
	    @timestamp : Int;
	    @windowID : Int;
	    @text : String;

	    New() {			
		}

		#~
		Event type
		@return EventType->SDL_TEXTINPUT
		~#
		method : public : GetType() ~ Int {
			return @type;
		}

		#~
		Timestamp of the event
		@return event timestamp
		~#
		method : public : GetTimestamp() ~ Int {
			return @timestamp;
		}

		#~
		Window with mouse focus, if any
		@return window ID
		~#
		method : public : GetWindowID() ~ Int {
			return @windowID;
		}

		#~
		Get input text
		@return input text
		~#
		method : public : GetText() ~ String {
			return @text;
		}
	}

	#~
	SDL event
	~#
	class Event {
		@event : Int;
		@key : KeyboardEvent;
		@axis : JoyAxisEvent;
		@text : TextInputEvent;
		@hat : JoyHatEvent;
		@jbutton : JoyButtonEvent;
		@motion : MouseMotionEvent;
		@mbutton : MouseButtonEvent;
		@wheel : MouseWheelEvent;
		
		#~
		Create a new event instance
		~#
		New() {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();
			Proxy->GetDllProxy()->CallFunction("sdl_event_new", array_args);
			value := array_args[0]->As(IntRef);
			@event := value->Get();
		}
		

		New : private (events : Int) {
			@event := events;
		}

		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @event = 0;
		}
		
		#~
		Frees the event
		~#
		method : public : Free() ~ Nil {
			if(@event <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@event);
				Proxy->GetDllProxy()->CallFunction("sdl_event_free", array_args);
				@event := 0;
			};
		}
		
		#~
		Event type
		@return type
		~#
		method : public : GetType() ~ EventType {
			if(@event <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				
				Proxy->GetDllProxy()->CallFunction("sdl_event_type", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get()->As(EventType);
			};
			
			return -1;
		}
		
		#~
		Get keyboard event
		@return keyboard event
		~#
		method : public : GetKey() ~ KeyboardEvent {
			if(@event <> 0) {
				if(@key = Nil) {
					@key := KeyboardEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @key;
				
				Proxy->GetDllProxy()->CallFunction("sdl_event_key", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @key;
			};
			
			return Nil;
		}

		#~
		Get text input event
		@return text input event
		~#
		method : public : GetTextInput() ~ TextInputEvent {
			if(@event <> 0) {
				if(@text = Nil) {
					@text := TextInputEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @text;
				
				Proxy->GetDllProxy()->CallFunction("sdl_text_key", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @text;
			};
			
			return Nil;
		}

		#~
		Get mouse motion event
		@return mouse motion event
		~#
		method : public : GetMouseMotion() ~ MouseMotionEvent {
			if(@event <> 0) {
				if(@motion = Nil) {
					@motion := MouseMotionEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @motion;
				
				Proxy->GetDllProxy()->CallFunction("sdl_mouse_motion", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @motion;
			};
			
			return Nil;
		}

		#~
		Get mouse wheel event
		@return mouse wheel event
		~#
		method : public : GetMouseWheel() ~ MouseWheelEvent {
			if(@event <> 0) {
				if(@wheel = Nil) {
					@wheel := MouseWheelEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @wheel;
				
				Proxy->GetDllProxy()->CallFunction("sdl_mouse_wheel", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @wheel;
			};
			
			return Nil;
		}

		#~
		Get joystick axis event
		@return joystick axis event
		~#
		method : public : GetJAxis() ~ JoyAxisEvent {
			if(@event <> 0) {
				if(@axis = Nil) {
					@axis := JoyAxisEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @axis;
				
				Proxy->GetDllProxy()->CallFunction("sdl_axis_key", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @axis;
			};
			
			return Nil;
		}

		#~
		Get joystick button event
		@return joystick button event
		~#
		method : public : GetJButton() ~ JoyButtonEvent {
			if(@event <> 0) {
				if(@jbutton = Nil) {
					@jbutton := JoyButtonEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @jbutton;
				
				Proxy->GetDllProxy()->CallFunction("sdl_jbutton_key", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @jbutton;
			};
			
			return Nil;
		}

		#~
		Get joystick hat event
		@return joystick hat event
		~#
		method : public : GetJHat() ~ JoyHatEvent {
			if(@event <> 0) {
				if(@hat = Nil) {
					@hat := JoyHatEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @hat;
				
				Proxy->GetDllProxy()->CallFunction("sdl_hat_key", array_args);
				
				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @hat;
			};
			
			return Nil;
		}

		#~
		Get mouse button event
		@return mouse button event
		~#
		method : public : GetMButton() ~ MouseButtonEvent {
			if(@event <> 0) {
				if(@mbutton = Nil) {
					@mbutton := MouseButtonEvent->New();
				};
				
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := @mbutton;
				
				Proxy->GetDllProxy()->CallFunction("sdl_mbutton_key", array_args);

				value := array_args[0]->As(IntRef);
				if(value->Get() < 0) {
					return Nil;
				};

				return @mbutton;
			};
			
			return Nil;
		}
				
		#~
		Pump the event loop, gathering events from the input devices
		~#
		function : Pump() ~ Nil {
			Proxy->GetDllProxy()->CallFunction("sdl_event_pump", Nil->As(Base[]));
		}
		
		#~
		Check the event queue for messages and optionally return them
		@param vents destination buffer for the retrieved events
		@param numevents if action is SDL_ADDEVENT, the number of events to add back to the event queue; if action is SDL_PEEKEVENT or SDL_GETEVENT, the maximum number of events to retrieve
		@param action action to take; see Remarks for details
		@param minType minimum value of the event type to be considered; SDL_FIRSTEVENT is a safe choice
		@param maxType maximum value of the event type to be considered; SDL_LASTEVENT is a safe choice
		@return number of events actually stored or a negative error code on failure
		~#
		method : public : Peeps(numevents : Int, action : EventAction, minType : Int, maxType : Int) ~ Int {
			if(@event <> 0) {
				array_args := Base->New[6];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := IntRef->New(numevents);
				array_args[3] := IntRef->New(action->As(Int));
				array_args[4] := IntRef->New(minType);
				array_args[5] := IntRef->New(maxType);

				Proxy->GetDllProxy()->CallFunction("sdl_event_peeps", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Check for the existence of certain event types in the event queue
		@param type the type of event to be queried
		@return true if events matching type are present, false otherwise
		~# 
		function : Has(type : Int) ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(type);

			Proxy->GetDllProxy()->CallFunction("sdl_event_has", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
		
		#~
		Clear events from the event queue
		@param type the type of event to be cleared
		~#
		function : Flush(type : Int) ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(type);
			Proxy->GetDllProxy()->CallFunction("sdl_event_flush", array_args);
		}
		
		#~
		Poll for currently pending events
		~#
		method : public : Poll() ~ Int {
			if(@event <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);

				Proxy->GetDllProxy()->CallFunction("sdl_event_poll", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
		
			return -1;
		}
		
		#~
		Waits indefinitely for the next available event.
		@return 1, or 0 if there was an error while waiting for events
 		~#
		method : public : Wait() ~ Int {
			if(@event <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);

				Proxy->GetDllProxy()->CallFunction("sdl_event_wait", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Waits until the specified timeout (in milliseconds) for the next available event
		@param timeout The timeout (in milliseconds) to wait for next event
		@return 1, or 0 if there was an error while waiting for events
 		~#
		method : public : WaitTimeout(timeout : Int) ~ Int {
			if(@event <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);
				array_args[2] := IntRef->New(timeout);

				Proxy->GetDllProxy()->CallFunction("sdl_event_wait_timeout", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Add an event to the event queue
 		@return 1 on success, 0 if the event was filtered, or -1 if 
 		the event queue was full or there was some other error.
 		~#
		method : public : Push() ~ Int {
			if(@event <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@event);

				Proxy->GetDllProxy()->CallFunction("sdl_event_push", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
 		Allows you to set the state of processing certain events.
 		@param type the type of event; see SDL_EventType for details
		@param state how to process the event; see Remarks for details
		@return SDL_DISABLE or SDL_ENABLE, representing the 
		processing state of the event before this function makes any changes to it
 		~#
		function : State(type : Int, state : Int) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(type);
			array_args[2] := IntRef->New(state);

			Proxy->GetDllProxy()->CallFunction("sdl_event_state", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Allocate a set of user-defined events, and return the beginning 
		event number for that set of events
		@param numevents the number of events to be allocated
		~#
		function : Registers(numevents : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(numevents);

			Proxy->GetDllProxy()->CallFunction("sdl_event_registers", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
	}
	
	#~
	SDL core operations
	~#
	class Core {
		#~
		Initialize the SDL library. This must be called before using most other SDL functions.
		@param flags subsystem initialization flags
		~#
		function : Init(flags : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(flags);
			
			Proxy->GetDllProxy()->CallFunction("sdl_core_init", array_args);
			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Initialize specific SDL subsystems
		@param flags subsystem initialization flags
		~#
		function : InitSubSystem(flags : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(flags);
			
			Proxy->GetDllProxy()->CallFunction("sdl_core_init_sub_system", array_args);
			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Shut down specific SDL subsystems.
		@param flags subsystem initialization flags
		~#
		function : QuitSubSystem(flags : Int) ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(flags);
			
			Proxy->GetDllProxy()->CallFunction("sdl_core_quit_sub_system", array_args);
		}
		
		#~
		Mask of the specified subsystems which have previously been initialized
		@param flags subsystem initialization flags
		~#
		function : WasInit(flags : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(flags);
			
			Proxy->GetDllProxy()->CallFunction("sdl_core_was_init", array_args);
			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Clean up all initialized subsystems. You should call it upon all exit conditions.
		~#
		function : Quit() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_core_quit", array_args);
		}
		
		#~
		dynamically load an OpenGL library
		@param path the platform dependent OpenGL library name, 
			or Nil to open the default OpenGL library
		~#
		function : GLLoadLibrary(path : String) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := path;

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_load_library", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Unload the OpenGL library previously loaded
		~#
		function : GLUnloadLibrary() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_unload_library", array_args);
		}
		
		#~
		Check if an OpenGL extension is supported for the current context
		@param extension the name of the extension to check
		@return true if the extension is supported, false otherwise
		~#
		function : GLExtensionSupported(extension : String) ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := extension;

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_extension_supported", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
		
		#~
		Reset all previously set OpenGL context attributes to their default values
		~#
		function : GLResetAttributes() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_reset_attributes", array_args);
		}
		
		#~
		Set an OpenGL window attribute before window creation
		@param attr the OpenGL attribute to set; see Remarks for details
		@param value the desired value for the attribute
		@return 0 on success or a negative error code on failure
		~#
		function : GLSetAttribute(attr : GLattr, value : Int) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(attr->As(Int));
			array_args[2] := IntRef->New(value);

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_set_attribute", array_args);

			rtrn_value := array_args[0]->As(IntRef);
			return rtrn_value->Get();
		}
		
		#~
		Get the actual value for an attribute from the current context
		@param attr the SDL_GLattr structure to query
		@param value pointer filled in with the current value of attr
		@return 0 on success or a negative error code on failure
		~#
		function : GLGetAttribute(attr : GLattr, value : IntRef) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(attr->As(Int));
			array_args[2] := value;

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_get_attribute", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get the currently active OpenGL window
		@return active window
		~#
		function : GLGetCurrentWindow() ~ Window {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_get_current", array_args);

			value := array_args[0]->As(IntRef);
			return Window->New(value->Get());
		}
		
		#~
		Set the swap interval for the current OpenGL context
		@param interval 0 for immediate updates, 1 for updates 
		synchronized with the vertical retrace, -1 for adaptive vsync
		@return 0 on success or -1 if setting the swap interval is not supported
		~#
		function : GLSetSwapInterval(interval : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(interval);

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_set_swap_interval", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get the swap interval for the current OpenGL context
		@return 0 if there is no vertical retrace synchronization, 
		1 if the buffer swap is synchronized with the vertical retrace, 
		and -1 if late swaps happen immediately instead of waiting for 
		the next retrace;
		~#
		function : GLGetSwapInterval() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_core_gl_get_swap_interval", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Retrieve a message about the last error that occurred
		@return message with information about the specific error that occurred
		~#
		function : GetError() ~ String {
			array_args := Base->New[1];
			array_args[0] := Nil;

			Proxy->GetDllProxy()->CallFunction("sdl_core_get_error", array_args);
			
			return array_args[0]->As(String);
		}

		#~
		Clear any previous error message
		~#
		function : ClearError() ~ Nil {
			Proxy->GetDllProxy()->CallFunction("sdl_core_clear_error", Nil->As(Base[]));
		}
	}
		
	#~
	Configuration management 
	~#
	class Hints {
		#~
		Set a hint with a specific priority
		@param name the hint to set; see the list of hints on CategoryHints for details
		@param value the value of the hint variable
		@param priority the SDL_HintPriority level for the hint
		@return true if the hint was set, false otherwise
		~#
		function : public : SetWithPriority(name : String, value : String, priority : HintPriority) ~ Bool {
			array_args := Base->New[4];
			array_args[0] := IntRef->New();
			array_args[1] := name;
			array_args[2] := value;
			array_args[3] := IntRef->New(priority->As(Int));
			Proxy->GetDllProxy()->CallFunction("sdl_hints_set_hint_with_priority", array_args);
			
			rvalue := array_args[0]->As(IntRef);
			return rvalue->Get() = 0 ? false : true;
		}
		
		#~
		Set a hint with normal priority.
		@param name the hint to set; see the list of hints on CategoryHints for details
		@param value the value of the hint variable
		@return true if the hint was set, false otherwise
		~#
		function : Set(name : String, value : String) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := name;
			array_args[2] := value;

			Proxy->GetDllProxy()->CallFunction("sdl_hints_set_hint", array_args);

			rvalue := array_args[0]->As(IntRef);
			return rvalue->Get() = 0 ? false : true;
		}
		
		#~
		Get the value of a hint.
		@param name the hint to query
		@return the string value of a hint
		~#
		function : Get(name : String) ~ String {
			array_args := Base->New[2];
			array_args[0] := Nil;
			array_args[1] := name;
			
			Proxy->GetDllProxy()->CallFunction("sdl_hints_get_hint", array_args);

			return array_args[0]->As(String);
		}

		#~
		Get the boolean value of a hint variable
		@param name the hint to query
		@param value the value to return if the hint does not exist
		@return the boolean value of a hint or the provided default value if the hint does not exist
		~#
		function : Get(name : String, value : Bool) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := name;
			array_args[2] := IntRef->New(value ? 1 : 0);
			
			Proxy->GetDllProxy()->CallFunction("sdl_hints_get_hint_boolean", array_args);

			rvalue := array_args[0]->As(IntRef);
			return rvalue->Get() = 0 ? false : true;
		}

		#~
		Clear all hints
		~#
		function : Clear() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_hints_clear", array_args);
		}
	}
		
	#~
	Structure that represents a color
	~#
	class Color {
		@r : Int;
		@g : Int;
		@b : Int;
		@a : Int;
		
		#~
		Default black color
		~#
		New() {
			@r := 0;
			@g := 0;
			@b := 0;
			@a := 255;
		}

		#~
		RGB Color with alpha set to 255
		@param r red
		@param g green
		@param b blue
		~#
		New(r : Int, g : Int, b : Int) {
			@r := r;
			@g := g;
			@b := b;
			@a := 255;
		}

		#~
		RGBA color
		@param r red
		@param g green
		@param b blue
		@param a alpha
		~#
		New(r : Int, g : Int, b : Int, a : Int) {
			@r := r;
			@g := g;
			@b := b;
			@a := a;
		}

		#~
		Get red
		@return red
		~#
		method : public : GetR() ~ Int {
			return @r;
		}
		
		#~
		Set red
		@param r red
		~#
		method : public : SetR(r : Int) ~ Nil {
			@r := r;
		}

		#~
		Get green
		@return green
		~#
		method : public : GetG() ~ Int {
			return @g;
		}
		
		#~
		Set green
		@param g green
		~#
		method : public : SetG(g : Int) ~ Nil {
			@g := g;
		}

		#~
		Get blue
		@return blue
		~#
		method : public : GetB() ~ Int {
			return @b;
		}
		
		#~
		Set blue
		@param b blue
		~#
		method : public : SetB(b : Int) ~ Nil {
			@b := b;
		}

		#~
		Get alpha
		@return alpha
		~#
		method : public : GetA() ~ Int {
			return @a;
		}
		
		#~
		Set alpha
		@param a alpha
		~#
		method : public : SetA(a : Int) ~ Nil {
			@a := a;
		}

		#~
		String RGBA representation
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "#{$@r}, #{$@g}, #{$@b}, #{$@a}";
		}
	}
	
	#~
	Contains the description of a display mode
	~#
	class DisplayMode {
		@format : Int;
	    @w : Int;
	    @h : Int;
	    @refresh_rate : Int;
		
	    New() {
	    }

	    #~
	    Constructor
		@param format one of the SDL_PixelFormatEnum values; see Remarks for details
		@param w width, in screen coordinates
		@param h height, in screen coordinates
		@param refresh_rate refresh rate (in Hz), or 0 for unspecified
		@param driverdata driver-specific data, initialize to 0
		~#
		New(format : Int, w : Int, h : Int, refresh_rate : Int) {
			@format := format;
			@w := w;
			@w := w;
			@refresh_rate := refresh_rate;
		}

		#~
		Get the format
		@return format
		~#
		method : public : GetFormat() ~ Int {
			return @format;
		}

		#~
		Set the format
		@param format format
		~#
		method : public : SetFormat(format : Int) ~ Nil {
			@format := format;
		}

		#~
		Get width
		@return width
		~#
		method : public : GetW() ~ Int {
			return @w;
		}

		#~
		Set width
		@param w width
		~#
		method : public : SetW(w : Int) ~ Nil {
			@w := w;
		}

		#~
		Get height
		@return height
		~#
		method : public : GetH() ~ Int {
			return @h;
		}

		#~
		Set height
		@param h height
		~#
		method : public : SetH(h : Int) ~ Nil {
			@h := h;
		}

		#~
		Get refresh rate
		@return refresh rate
		~#
		method : public : GetRefreshRate() ~ Int {
			return @refresh_rate;
		}

		#~
		Set refresh rate
		@param refresh_rate refresh rate
		~#
		method : public : SetRefreshRate(refresh_rate : Int) ~ Nil {
			@refresh_rate := refresh_rate;
		}
	}
	
	#~
	Defines a two dimensional point
	~#
	class Point {
		@x : Int;
		@y : Int;
		
		#~
		Constructor
		@param x x position
		@param y y position
		~#		
		New(x : Int, y : Int) {
			@x := x;
			@y := y;
		}

		#~
		Constructor set x and y to 0
		~#
		New() {
			@x := 0;
			@y := 0;
		}
		
		#~
		Get x
		@return x position
		~#
		method : public : GetX() ~ Int {
			return @x;
		}
		
		#~
		Get y
		@return y position
		~#
		method : public : GetY() ~ Int {
			return @y;
		}
		
		#~
		Set x
		@param x x position
		~#
		method : public : SetX(x : Int) ~ Nil {
			@x := x;
		}
		
		#~
		Set y
		@param y y position
		~#
		method : public : SetY(y : Int) ~ Nil {
			@y := y;
		}

		#~
		String representation of point
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "[{$@x}, {$@y}]";
		}
	}

	#~
	SDL joystick layer binding for this controller button/axis mapping
	~#
	class GameControllerButtonBind {
		@bind_type : GameControllerBindType;
		@button : Int;
        @axis : Int;
        @hat : Int;
        @hat_mask : Int;

        New() {}

        #~
		Get bind type
		@return bind type
		~#
		method : public : GetBindType() ~ Int {
			return @bind_type;
		}

		#~
		Get button
		@return button
		~#
		method : public : GetButton() ~ Int {
			return @button;
		}

		#~
		Get axis
		@return axis
		~#
		method : public : GetAxis() ~ Int {
			return @axis;
		}

		#~
		Get hat mask
		@return hat mask
		~#
		method : public : GetHatMast() ~ Int {
			return @hat_mask;
		}

		#~
		Get hat
		@return hat
		~#
		method : public : GetHat() ~ Int {
			return @hat;
		}
	}

	#~
	Definition of a rectangle, with the origin at the upper left.
	~#
	class Rect {
		@x : Int;
		@y : Int;
		@w : Int;
		@h : Int;
		
		#~
		Creates a new rectangle
		~#
		New() {
		}
		
		#~
		Creates a new rectangle
		@param w width
		@param h height
		~#
		New(w : Int, h : Int) {
			@x := 0;
			@y := 0;
			@w := w;
			@h := h;
		}

		#~
		Creates a new rectangle
		@param x x-location
		@param y y-location
		@param w width
		@param h height
		~#
		New(x : Int, y : Int, w : Int, h : Int) {
			@x := x;
			@y := y;
			@w := w;
			@h := h;
		}

		#~
		Creates a new rectangle
		@param rect rect to copy
		~#
		New(rect : Rect) {
			@x := rect->GetX();
			@y := rect->GetY();
			@w := rect->GetW();
			@h := rect->GetH();
		}
		
		#~
		Get X
		@return x-position
		~#
		method : public : GetX() ~ Int {
			return @x;
		}
		
		#~
		Get Y
		@return y-position
		~#
		method : public : GetY() ~ Int {
			return @y;
		}
		
		#~
		Get height
		@return height
		~#
		method : public : GetH() ~ Int {
			return @h;
		}
		
		#~
		Get width
		@return width
		~#
		method : public : GetW() ~ Int {
			return @w;
		}
		
		#~
		Set x-position
		@param x x-position
		~#
		method : public : SetX(x : Int) ~ Nil {
			@x := x;
		}
		
		#~
		Set y-position
		@param y y-position
		~#
		method : public : SetY(y : Int) ~ Nil {
			@y := y;
		}
		
		#~
		Set height 
		@param h height
		~#
		method : public : SetH(h : Int) ~ Nil {
			@h := h;
		}
		
		#~
		Set width 
		@param w width
		~#
		method : public : SetW(w : Int) ~ Nil {
			@w := w;
		}

		#~
		Add to current x position
		@param x value to add
		~#
		method : public : AddX(x : Int) ~ Nil {
			@x += x;
		}
		
		#~
		Add to current y position
		@param y value to add
		~#
		method : public : AddY(y : Int) ~ Nil {
			@y += y;
		}
		
		#~
		Add to current height
		@param h value to add
		~#
		method : public : AddH(h : Int) ~ Nil {
			@h += h;
		}
		
		#~
		Add to current width
		@param w value to add
		~#
		method : public : AddW(w : Int) ~ Nil {
			@w += w;
		}

		#~
		Subtracts from current x position
		@param x value to subtract
		~#
		method : public : SubX(x : Int) ~ Nil {
			@x -= x;
		}
		
		#~
		Subtracts from current y position
		@param y value to subtract
		~#
		method : public : SubY(y : Int) ~ Nil {
			@y -= y;
		}
		
		#~
		Subtracts from current height 
		@param h value to subtract
		~#
		method : public : SubH(h : Int) ~ Nil {
			@h -= h;
		}
		
		#~
		Subtracts from current width 
		@param w value to subtract
		~#
		method : public : SubW(w : Int) ~ Nil {
			@w -= w;
		}
		
		#~
		String representation of rect
		@return string representation
		~#
		method : public : ToString() ~ String {
			return "[{$@x}, {$@y}, {$@w}, {$@h}]";
		}
		
		#~
		Determines if two rectangles intersects
		@param B rectangle to compare
		@return true if intersection
		~#
		method : public : HasIntersection(B : Rect) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := @self;
			array_args[2] := B;

			Proxy->GetDllProxy()->CallFunction("sdl_rect_has_intersection", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
		
		#~
		Calculate the intersection of two rectangles
		@param B rectangle to compare
		@param result Rect filled in with the intersection of rectangles A and B
		@return Returns true if there is an intersection, false otherwise.
		~#
		method : public : Intersect(B : Rect, result : Rect) ~ Bool {
			array_args := Base->New[4];
			array_args[0] := IntRef->New();
			array_args[1] := @self;
			array_args[2] := B;
			array_args[3] := result;

			Proxy->GetDllProxy()->CallFunction("sdl_rect_intersect", array_args);
			
			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Calculate the union of two rectangles
		@param B rectangle to compare
		@param result Rect filled in with the union of rectangles A and B
		@return Returns true if there is an union, false otherwise.
		~#
		method : public : Union(B : Rect, result : Rect) ~ Nil {
			array_args := Base->New[3];
			array_args[0] := @self;
			array_args[1] := B;
			array_args[2] := result;

			Proxy->GetDllProxy()->CallFunction("sdl_rect_union", array_args);
		}
		
		#~
		Calculate the intersection of a rectangle and line segment
		@param X1 a holder to the starting X-coordinate of the line
		@param Y1 a holder to the starting Y-coordinate of the line
		@param X2 a holder to the ending X-coordinate of the line
		@param Y2 a holder to the ending Y-coordinate of the line
		@return true if there is an intersection, false otherwise
		~#
		method : public : IntersectAndLine(X1 : IntRef, Y1 :IntRef, X2 : IntRef, Y2 : IntRef) ~ Bool {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := @self;
			array_args[2] := X1;
			array_args[3] := Y1;
			array_args[4] := X2;
			array_args[5] := Y2;

			Proxy->GetDllProxy()->CallFunction("sdl_rect_intersect_and_line", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Check if a point resides inside a rectangle
		@param p an SDL_Point which is the point
		@return true if there is an intersection, false otherwise
		~#
		method : public : PointIn(p : Point) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := @self;
			array_args[2] := p;

			Proxy->GetDllProxy()->CallFunction("sdl_rect_point_in_rect", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
	}
	
	#~
	PixelFormat class
	~#
	class PixelFormat {
		@format : PixelValue;
		@palette : Int;
		@bits_per_pixel : Int;
		@bytes_per_pixel : Int;
		@r_mask : Int;
		@g_mask : Int;
		@b_mask : Int;
		@a_mask : Int;
		@r_loss : Int;
	    @g_loss : Int;
	    @b_loss : Int;
	    @a_loss : Int;
	    @r_shift : Int;
	    @g_shift : Int;
	    @b_shift : Int;
	    @a_shift : Int;

	    New() {
	    }

		New(format : Int) {
			array_args := Base->New[2];
			array_args[0] := @self;
			array_args[1] := IntRef->New(format);

			Proxy->GetDllProxy()->CallFunction("sdl_pixelformat_alloc", array_args);
		}

		#~
		Map an RGB triple to an opaque pixel value for a given pixel format
		@param r the red component of the pixel in the range 0-255
		@param g the green component of the pixel in the range 0-255
		@param b the blue component of the pixel in the range 0-255
		@return returns a pixel value
		~#
		method : public : MapRGB(r : Int, g : Int, b : Int) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := @self;
			array_args[2] := IntRef->New(r);
			array_args[3] := IntRef->New(g);
			array_args[4] := IntRef->New(b);

			Proxy->GetDllProxy()->CallFunction("sdl_pixelformat_maprgb", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Map an RGBA quadruple to a pixel value for a given pixel format
		@param r the red component of the pixel in the range 0-255
		@param g the green component of the pixel in the range 0-255
		@param b the blue component of the pixel in the range 0-255
		@param a the alpha component of the pixel in the range 0-255
		@return returns a pixel value
		~#
		method : public : MapRGBA(r : Int, g : Int, b : Int, a : Int) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := @self;
			array_args[2] := IntRef->New(r);
			array_args[3] := IntRef->New(g);
			array_args[4] := IntRef->New(b);
			array_args[5] := IntRef->New(a);

			Proxy->GetDllProxy()->CallFunction("sdl_pixelformat_maprgba", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Get pixel format
		@return pixel format
		~#
		method : public : GetFormat() ~ PixelValue {
			return @format;
		}
		
		#~
		Set pixel format
		@param format pixel format
		~#
		method : public : SetFormat(format : Int) ~ Nil {
			@format := format;
		}
		
		#~
		Get the number of significant bits in a pixel value
		@return bits per pixel
		~#
		method : public : GetBitsPerPixel() ~ Int {
			return @bits_per_pixel;
		}
		
		#~
		Set bits per pixel
		@param bits_per_pixel bits per pixel
		~#
		method : public : SetBitsPerPixel(bits_per_pixel : Int) ~ Nil {
			@bits_per_pixel := bits_per_pixel;
		}
		
		#~
		Get the number of bytes required to hold a pixel value
		@return bytes per pixel
		~#
		method : public : GetBytesPerPixel() ~ Int {
			return @bytes_per_pixel;
		}
		
		#~
		Set bytes per pixel
		@param bytes_per_pixel bytes per pixel
		~#
		method : public : SetBytesPerPixel(bytes_per_pixel : Int) ~ Nil {
			@bytes_per_pixel := bytes_per_pixel;
		}
		
		#~
		Get mask representing the location of the red component of the pixel
		@return pixel mask
		~#
		method : public : GetRmask() ~ Int {
			return @r_mask;
		}
		
		#~
		Set red mask
		@param r_mask red mask
		~#
		method : public : SetRmask(r_mask : Int) ~ Nil {
			@r_mask := r_mask;
		}
		
		#~
		Get mask representing the location of the green component of the pixel
		@return pixel mask
		~#
		method : public : GetGmask() ~ Int {
			return @g_mask;
		}
		
		#~
		Set green mask
		@param g_mask green mask
		~#
		method : public : SetGmask(g_mask : Int) ~ Nil {
			@g_mask := g_mask;
		}
		
		#~
		Get mask representing the location of the blue component of the pixel
		@return pixel mask
		~#
		method : public : GetBmask() ~ Int {
			return @b_mask;
		}
		
		#~
		Set blue mask
		@param b_mask blue mask
		~#
		method : public : SetBmask(b_mask : Int) ~ Nil {
			@b_mask := b_mask;
		}
		
		#~
		Get mask representing the location of the alpha component of the 
		pixel or 0 if the pixel format doesn't have any alpha information
		@return pixel mask
		~#
		method : public : GetAmask() ~ Int {
			return @a_mask;
		}
		
		#~
		Set alpha mask
		@param a_mask alpha mask
		~#
		method : public : SetAmask(a_mask : Int) ~ Nil {
			@a_mask := a_mask;
		}
	}

	#~
	Core class
	~#
	class Surface {
		@surface : Int;
		
		New(surface : Int) {
			@surface := surface;
		}
		
		#~
		Creates new RGB surface
		@param flags the flags are unused and should be set to 0
		@param width the width of the surface
		@param height the height of the surface
		@param depth the depth of the surface in bits; see Remarks for details
		@param Rmask the red mask for the pixels
		@param Gmask the green mask for the pixels
		@param Bmask the blue mask for the pixels
		@param Amask the alpha mask for the pixels
		~#
		New(flags : Int, width : Int, height : Int, depth : Int, Rmask : Int, Gmask : Int, Bmask : Int, Amask : Int) {
			array_args := Base->New[9];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(flags);
			array_args[2] := IntRef->New(width);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(depth);
			array_args[5] := IntRef->New(Rmask);
			array_args[6] := IntRef->New(Gmask);
			array_args[7] := IntRef->New(Bmask);
			array_args[8] := IntRef->New(Amask);

			Proxy->GetDllProxy()->CallFunction("sdl_surface_creatergb", array_args);
			value := array_args[0]->As(IntRef);
			@surface := value->Get();
		}

		#~
		Creates new RGB surface
		@param flags the flags are unused and should be set to 0
		@param width the width of the surface
		@param height the height of the surface
		@param depth the depth of the surface in bits; see Remarks for details
		@param format the PixelFormatValue for the new surface's pixel format
		~#
		New(flags : Int, width : Int, height : Int, depth : Int, format : Int) {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(flags);
			array_args[2] := IntRef->New(width);
			array_args[3] := IntRef->New(height);
			array_args[4] := IntRef->New(depth);
			array_args[5] := IntRef->New(format);

			Proxy->GetDllProxy()->CallFunction("sdl_surface_creatergb_with_format", array_args);
			value := array_args[0]->As(IntRef);
			@surface := value->Get();
		}
		
		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @surface = 0;
		}

		#~
		Frees the event
		~#
		method : public : Free() ~ Nil {
			if(@surface <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_free", array_args);
				@surface := 0;
			};
		}

		#~
		Creates a new surface identical to the existing surface
		@return a copy of the surface, or NULL on failure
		~#
		method : public : Duplicate() ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_duplicate", array_args);
				
				value := array_args[0]->As(IntRef);
				if(value->Get() <> 0) {
					return Surface->New(value->Get());
				};
			};

			return Nil;
		}
		
		#~
		Get pixel format
		@return pixel format
		~#
		method : public : GetPixelFormat() ~ PixelFormat {
			if(@surface <> 0) {
				pixel_format := PixelFormat->New();

				array_args := Base->New[2];
				array_args[0] := pixel_format;
				array_args[1] := IntRef->New(@surface);
		
				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_pixel_format", array_args);

				return pixel_format;
			};

			return Nil;
		}

		#~
		Get width
		@return width
		~#
		method : public : GetW() ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_w", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}

		#~
		Get height
		@return height
		~#
		method : public : GetH() ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_h", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}

		#~
		Get length of a row of pixels in bytes
		@return pitch
		~#
		method : public : GetPitch() ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_pitch", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}

		#~
		Get raw pixels
		@return raw pixels
		~#
		method : public : GetPixels() ~ PixelData {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := Nil;
				array_args[1] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_pixels", array_args);

				return array_args[0]->As(PixelData);
			};

			return Nil;
		}
		
		#~
		Set up a surface for directly accessing the pixels
		~#
		method : public : Lock() ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_lock", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Release a surface after directly accessing the pixels
		~#
		method : public : Unlock() ~ Nil {
			if(@surface <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@surface);
				Proxy->GetDllProxy()->CallFunction("sdl_surface_unlock", array_args);
			};
		}

		#~
		Create a texture from an existing surface
		@param renderer the rendering context
		@return newly created texture
		~#
		method : public : CreateTexture(renderer : Renderer) ~ Texture {
			if(@surface <> 0 & renderer <> Nil) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := renderer;
				
				Proxy->GetDllProxy()->CallFunction("sdl_surface_create_texture", array_args);

				value := array_args[0]->As(IntRef);
				return Texture->New(value->Get());
			};

			return Nil;
		}
		
		#~
		Load a surface from a BMP file.
		@param file the file containing a BMP image
		@return newly created texture
		~#
		function : LoadBMP(file : String) ~ Surface {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := file;

			Proxy->GetDllProxy()->CallFunction("sdl_surface_loadbmp", array_args);
			value := array_args[0]->As(IntRef);
			return Surface->New(value->Get());
		}
		
		#~
		save a surface to a BMP file
		@param surface Surface instance containing the image to be saved
		@param file file to be saved to
		@return 0 on success or a negative error code on failure
		~#
		function : SaveBMP(surface : Surface, file : String) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := surface;
			array_args[2] := file;

			@lib_proxy := Proxy->GetDllProxy();
			@lib_proxy->CallFunction("sdl_surface_savebmp", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Set the RLE acceleration hint for a surface
		@param flag 0 to disable, non-zero to enable RLE acceleration
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetRLE(flag : Int) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(flag);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_setrle", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Set the color key (transparent pixel) in a surface
		@param flag true to enable color key, false to disable color key
		@param key the transparent pixel
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetColorKey(flag : Bool, key : Int) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(flag ? 1 : 0);
				array_args[3] := IntRef->New(key);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_set_color_key", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the color key (transparent pixel) for a surface
		@param key a holder filled in with the transparent pixel
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetColorKey(key : IntRef) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := key;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_color_key", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Set an additional color value multiplied into blit operation
		@param r the red color value multiplied into blit operations
		@param g the green color value multiplied into blit operations
		@param b the blue color value multiplied into blit operations
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetColorMod(r : Int, g : Int, b : Int) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(r);
				array_args[3] := IntRef->New(g);
				array_args[4] := IntRef->New(b);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_set_color_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the additional color value multiplied into blit operations
		@param r pointer filled in with the current red color value
		@param g pointer filled in with the current green color value
		@param b pointer filled in with the current blue color value
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetColorMod(r : IntRef, g : IntRef, b : IntRef) ~ Int {
			if(@surface <> 0) {		
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := r;
				array_args[3] := g;
				array_args[4] := b;

				@lib_proxy := Proxy->GetDllProxy();
				@lib_proxy->CallFunction("sdl_surface_get_color_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Set an additional alpha value used in blit operations
		@param alpha alpha value multiplied into blit operations
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetAlphaMod(alpha : Int) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(alpha);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_set_alpha_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Get the additional alpha value used in blit operations
		@param alpha holder filled in with the current alpha value
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetAlphaMod(alpha : IntRef) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := alpha;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_alpha_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		set the blend mode used for blit operations
		@param blendMode BlendMode to use for blit blending
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetBlendMode(blendMode : BlendMode) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(blendMode->As(Int));

				Proxy->GetDllProxy()->CallFunction("sdl_surface_set_blend_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		get the blend mode used for blit operations
		@param blendMode pointer filled in with the current BlendMode
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetBlendMode(blendMode : IntRef) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := blendMode;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_blend_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}

		#~
		Get the clipping rectangle for a surface
		@param rect Rect filled in with the clipping rectangle for the surface
		~#
		method : public : GetClipRect(rect : Rect) ~ Nil {
			if(@surface <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New(@surface);
				array_args[1] := rect;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_get_clip_rect", array_args);
			};
		}
		
		#~
		Set the clipping rectangle for a surface
		@param rect Rect structure representing the clipping rectangle, or 
		Nil to disable clipping
		@return Returns true if the rectangle intersects the surface, 
		otherwise false and blits will be completely clipped
		~#
		method : public : SetClipRect(rect : Rect) ~ Bool {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := rect;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_set_clip_rect", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get() = 0 ? false : true;
			};
			
			return false;
		}
		
		#~
		Copy an existing surface into a new one that is optimized for blitting 
		to a surface of a specified pixel format
		@param fmt PixelFormat structure that the new surface is optimized for
		@param flags flags are unused and should be set to 0
		@return new SDL_Surface structure that is created
		~#
		method : public : Convert(fmt : PixelFormat, flags : Int) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := fmt;
				array_args[3] := IntRef->New(flags);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_convert", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};
			
			return Nil;
		}

		#~
		Copy an existing surface to a new surface of the specified format
		@param format one of the enumerated values in SDL_PixelFormatEnum; see Remarks for details
		@param flags the flags are unused and should be set to 0
		@return the new surface
		~#
		method : public : ConvertFormat(format : Int, flags : Int) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(format);
				array_args[3] := IntRef->New(flags);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_convert_format", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};
			
			return Nil;
		}

		#~
		perform a fast fill of a rectangle with a specific color
		@param rect Rect structure representing the rectangle to fill, or Nil 
		to fill the entire surface
		@param color color to fill with
		@return 0 on success or a negative error code on failure
		~#
		method : public : FillRect(rect : Rect, color : Int) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := rect;
				array_args[3] := IntRef->New(color);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_fill_rect", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};
			
			return -1;
		}
		
		#~
		Perform a fast surface copy to a destination surface
		@param srcrect the SDL_Rect structure representing the rectangle to be copied, or NULL 
		to copy the entire surface
		@param dst the SDL_Surface structure that is the blit target
		@param dstrect the SDL_Rect structure representing the rectangle that is copied into
		@return 0 if the blit is successful or a negative error code on failure
		~#
		method : public : Blit(srcrect : Rect, dst : Surface, dstrect : Rect) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := srcrect;
				array_args[3] := dst;
				array_args[4] := dstrect;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_upper_blit", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Perform low-level surface blitting only
		@param srcrect the SDL_Rect structure representing the rectangle to be copied, or NULL 
		to copy the entire surface
		@param dst the SDL_Surface structure that is the blit target
		@param dstrect the SDL_Rect structure representing the rectangle that is copied into
		@return 0 if the blit is successful or a negative error code on failure
		~#
		method : public : LowerBlit(srcrect : Rect, dst : Surface, dstrect : Rect) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := srcrect;
				array_args[3] := dst;
				array_args[4] := dstrect;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_lower_blit", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Scaled surface copy to a destination surface
		@param srcrect the SDL_Rect structure representing the rectangle to be copied, or NULL 
		to copy the entire surface
		@param dst the SDL_Surface structure that is the blit target
		@param dstrect the SDL_Rect structure representing the rectangle that is copied into
		@return 0 if the blit is successful or a negative error code on failure
		~#
		method : public : BlitScaled(srcrect : Rect, dst : Surface, dstrect : Rect) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := srcrect;
				array_args[3] := dst;
				array_args[4] := dstrect;

				@lib_proxy := Proxy->GetDllProxy();
				@lib_proxy->CallFunction("sdl_surface_blit_scaled", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Perform low-level surface scaled blitting only
		@param srcrect the SDL_Rect structure representing the rectangle to be copied, or NULL 
		to copy the entire surface
		@param dst the SDL_Surface structure that is the blit target
		@param dstrect the SDL_Rect structure representing the rectangle that is copied into
		@return 0 if the blit is successful or a negative error code on failure
		~#
		method : public : LowerBlitScaled(srcrect : Rect, dst : Surface, dstrect : Rect) ~ Int {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := srcrect;
				array_args[3] := dst;
				array_args[4] := dstrect;

				Proxy->GetDllProxy()->CallFunction("sdl_surface_lower_blit_scaled", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Rotates and zooms a surface and optional anti-aliasing.
		@param angle The angle to rotate in degrees.
		@param zoom The scaling factor.
		@param smooth Antialiasing flag; set to true to enable.
		@return newly modified surface
		~#
		method : public : RotoZoom(angle : Float, zoom : Float, smooth : Bool) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := FloatRef->New(angle);
				array_args[3] := FloatRef->New(zoom);
				array_args[4] := IntRef->New(smooth ? 1 : 0);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_rotozoom", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};

			return Nil;
		}

		#~
		Rotates and zooms a surface with different horizontal and vertival scaling factors and optional anti-aliasing.
		@param angle The angle to rotate in degrees.
		@param zoomx The horizontal scaling factor.
		@param zoomy The vertical scaling factor.
		@param smooth Antialiasing flag; set to true to enable.
		@return newly modified surface
		~#
		method : public : RotoZoomXY(angle : Float, zoomx : Float, zoomy : Float, smooth : Bool) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[6];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := FloatRef->New(angle);
				array_args[3] := FloatRef->New(zoomx);
				array_args[4] := FloatRef->New(zoomy);
				array_args[5] := IntRef->New(smooth ? 1 : 0);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_rotozoom_xy", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};

			return Nil;
		}

		#~
		Returns the size of the resulting target surface for a RotoZoom() call.
		@param width The source surface width.
		@param height The source surface height.
		@param angle The angle to rotate in degrees.
		@param zoom The scaling factor.
		@param dstwidth The calculated width of the rotozoomed destination surface.
		@param dstheight The calculated height of the rotozoomed destination surface.
		~#
		function : RotoZoomSize(width : Int, height : Int, angle : Float, zoom : Float, dstwidth : IntRef, dstheight : IntRef) ~ Nil {
			array_args := Base->New[6];
			array_args[0] := IntRef->New(width);
			array_args[1] := IntRef->New(height);
			array_args[2] := FloatRef->New(angle);
			array_args[3] := FloatRef->New(zoom);
			array_args[4] := dstwidth;
			array_args[5] := dstheight;

			Proxy->GetDllProxy()->CallFunction("sdl_surface_rotozoom_size", array_args);
		}

		#~
		Returns the size of the resulting target surface for a RotoZoomXY() call.
		@param width The source surface width.
		@param height The source surface height.
		@param angle The angle to rotate in degrees.
		@param zoomx The horizontal scaling factor.
		@param zoomy The vertical scaling factor.
		@param dstwidth The calculated width of the rotozoomed destination surface.
		@param dstheight The calculated height of the rotozoomed destination surface.
		~#
		function : RotoZoomSizeXY(width : Int, height : Int, angle : Float, zoomx : Float, zoomy : Float, dstwidth : IntRef, dstheight : IntRef) ~ Nil {
			array_args := Base->New[7];
			array_args[0] := IntRef->New(width);
			array_args[1] := IntRef->New(height);
			array_args[2] := FloatRef->New(angle);
			array_args[3] := FloatRef->New(zoomx);
			array_args[4] := FloatRef->New(zoomy);
			array_args[5] := dstwidth;
			array_args[6] := dstheight;

			Proxy->GetDllProxy()->CallFunction("sdl_surface_rotozoom_size_xy", array_args);
		}

		#~
		Returns the size of the resulting target surface for a Zoom() call.
		@param width The source surface width.
		@param height The source surface height.
		@param zoomx The horizontal scaling factor.
		@param zoomy The vertical scaling factor.
		@param dstwidth The calculated width of the rotozoomed destination surface.
		@param dstheight The calculated height of the rotozoomed destination surface.
		~#
		function : ZoomSize(width : Int, height : Int, zoomx : Float, zoomy : Float, dstwidth : IntRef, dstheight : IntRef) ~ Nil {
			array_args := Base->New[6];
			array_args[0] := IntRef->New(width);
			array_args[1] := IntRef->New(height);
			array_args[2] := FloatRef->New(zoomx);
			array_args[3] := FloatRef->New(zoomy);
			array_args[4] := dstwidth;
			array_args[5] := dstheight;

			Proxy->GetDllProxy()->CallFunction("sdl_surface_zoom_size", array_args);
		}


		#~
		Zoom a surface by independent horizontal and vertical factors with optional smoothing.
		@param angle The angle to rotate in degrees.
		@param zoomx The horizontal scaling factor.
		@param zoomy The vertical scaling factor.
		@param smooth Antialiasing flag; set to true to enable.
		@return newly modified surface
		~#
		method : public : Zoom(zoomx : Float, zoomy : Float, smooth : Bool) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := FloatRef->New(zoomx);
				array_args[3] := FloatRef->New(zoomy);
				array_args[4] := IntRef->New(smooth ? 1 : 0);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_zoom", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};

			return Nil;
		}

		#~
		Shrink a surface by an integer ratio using averaging.
		@param factorx The horizontal shrinking ratio.
		@param factory The vertical shrinking ratio.
		@return newly modified surface
		~#
		method : public : Shrink(factorx : Int, factory : Int) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(factorx);
				array_args[3] := IntRef->New(factory);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_shrink", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};

			return Nil;
		}

		#~
		Rotates a 8/16/24/32 bit surface in increments of 90 degrees.
		@param numClockwiseTurns Number of clockwise 90 degree turns to apply to the source.
		@return newly modified surface
		~#
		method : public : Rotate90Degrees(numClockwiseTurns : Int) ~ Surface {
			if(@surface <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@surface);
				array_args[2] := IntRef->New(numClockwiseTurns);

				Proxy->GetDllProxy()->CallFunction("sdl_surface_rotate_90degrees", array_args);

				value := array_args[0]->As(IntRef);
				return Surface->New(value->Get());
			};

			return Nil;
		}
	}

	#~
	Image loading operations
	~#
	class Image {
		#~ 
		Initialize by loading support as indicated by the flags
		@param flags OR'd values ImageFlags->IMG_INIT_JPG, ImageFlags->IMG_INIT_PNG and ImageFlags->IMG_INIT_TIF
		@return status code
		~#
		function : Init(flags : Int) ~ Int {
	        array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(flags);

	        Proxy->GetDllProxy()->CallFunction("sdl_image_init", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}
	
		#~ 
		Uninitialize image library
		~#
		function : Quit() ~ Nil {
			Proxy->GetDllProxy()->CallFunction("sdl_image_quit", Nil->As(Base[]));
		}

		#~ 
		Load image into surface
		@param file file path to image
		@return loaded surface
		~#
		function : Load(file : String) ~ Surface {
	        array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := file;

	        Proxy->GetDllProxy()->CallFunction("sdl_image_load", array_args);

	        value := array_args[0]->As(IntRef);
			return Surface->New(value->Get());
		}
	}

	#~
	Rendering state
	~#
	class Renderer {
		@renderer : Int;

		New(renderer : Int) {
			@renderer := renderer;
		}

		#~
		Create a 2D rendering context for a window
		@param window window context
		@param index the index of the rendering driver to initialize, 
		or -1 to initialize the first one supporting the requested flags
		@param flags 0, or one or more SDL_RendererFlags OR'd together
		@return rendering context
		~#
		New(window : Window, index : Int, flags : Int) {
	        array_args := Base->New[4];
	        array_args[0] := IntRef->New();
	        array_args[1] := window;
	        array_args[2] := IntRef->New(index);
	        array_args[3] := IntRef->New(flags);

	        Proxy->GetDllProxy()->CallFunction("sdl_renderer_create", array_args);

	        value := array_args[0]->As(IntRef);
			@renderer := value->Get();
		}

		#~
		Destroy the rendering context for a window and free associated textures
		~#
		method : public : Destroy() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@renderer);

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_destroy", array_args);

		}

		#~
		Set whether to force integer scales for resolution-independent rendering
		@param enable enable or disable the integer scaling for rendering
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetIntegerScale(enable : Bool) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(enable ? 1 : 0);

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_set_integer_scale", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @renderer = 0;
		}

		#~
		Get the number of 2D rendering drivers available for the current display
		@return a number >= 0 on success or a negative error code on failure
		~#
		function : GetNumRenderDrivers() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_get_num_render_drivers", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Set a texture as the current rendering target.
		@param texture the targeted texture, which must be created 
		with the SDL_TEXTUREACCESS_TARGET flag, or Nil for the default render target
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetTarget(texture : Texture) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := texture;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_set_target", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Get the current render target.
		@return current target
		~#
		method : public : GetTarget() ~ Texture {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_get_target", array_args);

			value := array_args[0]->As(IntRef);
			return Texture->New(value->Get());
		}

		#~
		Get whether clipping is enabled on the given renderer
		@return Returns true if clipping is enabled or false if not
		~#
		method : public : IsClipEnabled() ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_is_clip_enabled", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Fill a rectangle on the current rendering target with the drawing color
		@param rect Rect representing the rectangle to fill, or NULL for the 
		entire rendering target
		@return 0 on success or a negative error code on failure
		~#
		method : public : FillRect(rect : Rect) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := rect;

				Proxy->GetDllProxy()->CallFunction("sdl_renderer_render_fill_rect", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Get information about a specific 2D rendering driver for the current display
		@param index index of the driver to query information about
		@param info RendererInfo to be filled with information on the rendering driver
		@return 0 on success or a negative error code on failure
		~#
		function : GetRenderDriverInfo(index : Int, info : RendererInfo) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(index);
			array_args[2] := info;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_get_render_driver_info", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Create a 2D software rendering context for a surface
		@param surface Surface representing the surface where rendering is done
		@return valid rendering context
		~#
		function : CreateSoftwareRenderer(surface : Surface) ~ Renderer {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := surface;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_create_software", array_args);

			value := array_args[0]->As(IntRef);
	        return Renderer->New(value->Get());
		}

		#~
		Get the renderer associated with a window
		@param window the window to query
		~#
		function : Get(window : Window) ~ Renderer {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := window;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_get", array_args);

			value := array_args[0]->As(IntRef);
	        return Renderer->New(value->Get());
		}

		#~
		Set the color used for drawing operations (Rect, Line and Clear)
		@param r the red value used to draw on the rendering target
		@param g the green value used to draw on the rendering target
		@param b the blue value used to draw on the rendering target
		@param a the alpha value used to draw on the rendering target
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetDrawColor(r : Int, g : Int, b : Int, a : Int) ~ Int {
			if(@renderer <> 0) {
		        array_args := Base->New[6];
		        array_args[0] := IntRef->New();
		        array_args[1] := IntRef->New(@renderer);
		        array_args[2] := IntRef->New(r);
		        array_args[3] := IntRef->New(g);
		        array_args[4] := IntRef->New(b);
		        array_args[5] := IntRef->New(a);

		        Proxy->GetDllProxy()->CallFunction("sdl_renderer_set_render_draw_color", array_args);

		        value := array_args[0]->As(IntRef);
		        return value->Get();
		    };

		    return -1;
		}

		#~
		Create a texture for a rendering context
		@param format one of the enumerated values in PixelFormatEnum
		@param access one of the enumerated values in TextureAccess
		@param w the width of the texture in pixels
		@param h the height of the texture in pixels
		@return created texture
		~#
		method : public : CreateTexture(format : Int, access : Int, w : Int, h : Int) ~ Texture {
			if(@renderer <> 0) {
		        array_args := Base->New[6];
		        array_args[0] := IntRef->New();
		        array_args[1] := IntRef->New(@renderer);
		        array_args[2] := IntRef->New(format);
		        array_args[3] := IntRef->New(access);
		        array_args[4] := IntRef->New(w);
		        array_args[5] := IntRef->New(h);

		        Proxy->GetDllProxy()->CallFunction("sdl_renderer_create_texture", array_args);

		        value := array_args[0]->As(IntRef);
		        return Texture->New(value->Get());
		    };

		    return Nil;
		}

		#~
		Get the color used for drawing operations (Rect, Line and Clear)
		@param r pointer filled in with the red value used to draw on the rendering target
		@param g pointer filled in with the green value used to draw on the rendering target
		@param b pointer filled in with the blue value used to draw on the rendering target
		@param a holder filled in with the alpha value used to draw on the rendering target
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetRenderDrawColor(r : IntRef, g : IntRef, b : IntRef, a : IntRef) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := r;
			array_args[3] := g;
			array_args[4] := b;
			array_args[5] := a;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_get_render_draw_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw a point on the current rendering target
		@param x the x coordinate of the point
		@param y the y coordinate of the point
		@return 0 on success or a negative error code on failure
		~#
		method : public : DrawPoint(x : Int, y : Int) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := IntRef->New(x);
				array_args[3] := IntRef->New(y);

				Proxy->GetDllProxy()->CallFunction("sdl_renderer_render_draw_point", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Draw a line on the current rendering target
		@param x1 the x coordinate of the start point
		@param y1 the y coordinate of the start point
		@param x2 the x coordinate of the end point
		@param y2 the y coordinate of the end point
		@return 0 on success or a negative error code on failure
		~#
		method : public : DrawLine(x1 : Int, y1 : Int, x2 : Int, y2 : Int) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[6];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := IntRef->New(x1);
				array_args[3] := IntRef->New(y1);
				array_args[4] := IntRef->New(x2);
				array_args[5] := IntRef->New(y2);

				Proxy->GetDllProxy()->CallFunction("sdl_renderer_render_draw_line", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Draw a rectangle on the current rendering target
		@param rect Rect representing the rectangle to draw, 
		or Nil to outline the entire rendering target
		@return 0 on success or a negative error code on failure
		~#
		method : public : DrawRect(rect : Rect) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := rect;

				@lib_proxy := Proxy->GetDllProxy();
				@lib_proxy->CallFunction("sdl_renderer_render_draw_rect", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Get the drawing area for the current target
		@param rect Rect filled in with the current drawing area
		~#
		method : public : GetViewport(rect : Rect) ~ Nil {
			if(@renderer <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New(@renderer);
				array_args[1] := rect;

				@lib_proxy := Proxy->GetDllProxy();
				@lib_proxy->CallFunction("sdl_renderer_render_get_viewport", array_args);
			};
		}

		#~
		set the drawing area for rendering on the current target
		@param rect Rect representing the drawing area, or Nil to 
		set the viewport to the entire target
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetViewport(rect : Rect) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := rect;

				@lib_proxy := Proxy->GetDllProxy();
				@lib_proxy->CallFunction("sdl_renderer_render_set_viewport", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Get information about a rendering context
		@param info an RendererInfo filled with information about 
		the current renderer
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetInfo(info : RendererInfo) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := info;

				Proxy->GetDllProxy()->CallFunction("sdl_renderer_get_info", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Clear the current rendering target with the drawing color
		~#
		method : public : Clear() ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[2];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);

				Proxy->GetDllProxy()->CallFunction("sdl_renderer_render_clear", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Copy a portion of the texture to the current rendering target
		@param texture the source texture; see Remarks for details
		@param srcrect the source SDL_Rect structure or Nil for the entire texture
		@param dstrect the destination SDL_Rect structure or Nil for the entire 
		rendering target; the texture will be stretched to fill the given rectangle
		@return 0 on success or a negative error code on failure
		~#
		method : public : Copy(texture : Texture, srcrect : Rect, dstrect : Rect) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := texture;
				array_args[3] := srcrect;
				array_args[4] := dstrect;

				Proxy->GetDllProxy()->CallFunction("sdl_renderer_render_copy", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Copy a portion of the texture to the current rendering target, optionally rotating it by angle 
		around the given center and also flipping it top-bottom and/or left-right
		@param texture the source texture; see Remarks for details
		@param srcrect the source SDL_Rect structure or Nil for the entire texture
		@param dstrect the destination SDL_Rect structure or Nil for the entire rendering target
		@param angle an angle in degrees that indicates the rotation that will be applied to dstrect, 
		rotating it in a clockwise direction
		@param center a holder to a point indicating the point around which dstrect will be rotated 
		(if Nil, rotation will be done around dstrect.w/2, dstrect.h/2)
		@param flip a SDL_RendererFlip value stating which flipping actions should be performed on the texture
		@return 0 on success or a negative error code on failure
		~#
		method : public : CopyEx(texture : Texture, srcrect : Rect, dstrect : Rect, angle : Float, center : Point, flip : RendererFlip) ~ Int {
			if(@renderer <> 0) {
				array_args := Base->New[8];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@renderer);
				array_args[2] := texture;
				array_args[3] := srcrect;
				array_args[4] := dstrect;
				array_args[5] := FloatRef->New(angle);
				array_args[6] := center;
				array_args[7] := IntRef->New(flip->As(Int));

				@lib_proxy := Proxy->GetDllProxy();
				@lib_proxy->CallFunction("sdl_renderer_render_copy_ex", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Update the screen with any rendering performed since the previous call
		~#
		method : public : Present() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@renderer);

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_render_present", array_args);
		}

		#~
		Draw pixel with blending enabled if a<255. 
		@param x x-position
		@param y y-position
		@param color color
		@return 0 on success, -1 on failure
		~#
		method : public : PixelColor(x : Int, y : Int, color : Color) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_pixel_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw horizontal line with blending
		@param x1 X coordinate of the first point (i.e. left) of the line.
		@param x2 X coordinate of the second point (i.e. right) of the line.
		@param y Y coordinate of the points of the line.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : HLineColor(x1 : Int, x2 : Int, y : Int, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(x2);
			array_args[4] := IntRef->New(y);
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_hline_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw vertical line with blending
		@param x X coordinate of the points of the line.
		@param y1 Y coordinate of the first point (i.e. top) of the line.
		@param y2 Y coordinate of the second point (i.e. bottom) of the line.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : VlineColor(x : Int, y1 : Int, y2 : Int, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(y2);
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_vline_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw rectangle with blending
		@param x1 X coordinate of the first point (i.e. from left) of the rectangle.
		@param y1 Y coordinate of the first point (i.e. from top) of the rectangle.
		@param x2 X coordinate of the second point (i.e. from left) of the rectangle.
		@param y2 Y coordinate of the second point (i.e. from top) of the rectangle.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : RectangleColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_rectangle_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw rounded-corner rectangle with blending
		@param x1 X coordinate of the first point (i.e. top right) of the rectangle.
		@param y1 Y coordinate of the first point (i.e. top right) of the rectangle.
		@param x2 X coordinate of the second point (i.e. bottom left) of the rectangle.
		@param y2 Y coordinate of the second point (i.e. bottom left) of the rectangle.
		@param rad The radius of the corner arc.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : RoundedRectangleColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, rad : Int, color : Color) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := IntRef->New(rad);
			array_args[7] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_rounded_rectangle_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw box (filled rectangle) with blending
		@param x1 X coordinate of the first point (i.e. top right) of the box.
		@param y1 Y coordinate of the first point (i.e. top right) of the box.
		@param x2 X coordinate of the second point (i.e. bottom left) of the box.
		@param y2 Y coordinate of the second point (i.e. bottom left) of the box.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : BoxColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_box_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw rounded-corner box (filled rectangle) with blending
		@param x1 X coordinate of the first point (i.e. top right) of the box.
		@param y1 Y coordinate of the first point (i.e. top right) of the box.
		@param x2 X coordinate of the second point (i.e. bottom left) of the box.
		@param y2 Y coordinate of the second point (i.e. bottom left) of the box.
		@param rad The radius of the corner arcs of the box.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : RoundedBoxColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, rad : Int, color : Color) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := IntRef->New(rad);
			array_args[7] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_rounded_box_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw line with alpha blending
		@param x1 X coordinate of the first point of the line.
		@param y1 Y coordinate of the first point of the line.
		@param x2 X coordinate of the second point of the line.
		@param y2 Y coordinate of the seond point of the line.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : LineColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_line_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw anti-aliased line with alpha blending.
		@param x1 X coordinate of the first point of the aa-line.
		@param y1 Y coordinate of the first point of the aa-line.
		@param x2 X coordinate of the second point of the aa-line.
		@param y2 Y coordinate of the second point of the aa-line.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : AALineColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_aaline_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw a thick line with alpha blending.
		@param x1 X coordinate of the first point of the line.
		@param y1 Y coordinate of the first point of the line.
		@param x2 X coordinate of the second point of the line.
		@param y2 Y coordinate of the second point of the line.
		@param width Width of the line in pixels. Must be >0.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : ThickLineColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, width : Int, color : Color) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := IntRef->New(width);
			array_args[7] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_thick_line_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw circle with blending.
		@param x X coordinate of the center of the circle.
		@param y Y coordinate of the center of the circle.
		@param rad Radius in pixels of the circle.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : CircleColor(x : Int, y : Int, rad : Int, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rad);
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_circle_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Arc with blending.
		@param x X coordinate of the center of the arc.
		@param y Y coordinate of the center of the arc.
		@param rad Radius in pixels of the arc.
		@param start Starting radius in degrees of the arc. 0 degrees is down, increasing counterclockwise.
		@param end Ending radius in degrees of the arc. 0 degrees is down, increasing counterclockwise.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : ArcColor(x : Int, y : Int, rad : Int, start : Int, end : Int, color : Color) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rad);
			array_args[5] := IntRef->New(start);
			array_args[6] := IntRef->New(end);
			array_args[7] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_arc_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
	
		#~
		Raw anti-aliased circle with blending.
		@param x X coordinate of the center of the aa-circle.
		@param y Y coordinate of the center of the aa-circle.
		@param rad Radius in pixels of the aa-circle.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : AACircleColor(x : Int, y : Int, rad : Int, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rad);
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_aacircle_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw filled circle with blending.
		@param x X coordinate of the center of the filled circle.
		@param y Y coordinate of the center of the filled circle.
		@param r Radius in pixels of the filled circle.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : FilledCircleColor(x : Int, y : Int, r : Int, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(r);
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_filled_circle_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw ellipse with blending.
		@param x X coordinate of the center of the ellipse.
		@param y Y coordinate of the center of the ellipse.
		@param rx Horizontal radius in pixels of the ellipse.
		@param ry Vertical radius in pixels of the ellipse.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : EllipseColor(x : Int, y : Int, rx : Int, ry : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rx);
			array_args[5] := IntRef->New(ry);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_ellipse_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw ellipse with blending.
		@param x X coordinate of the center of the ellipse.
		@param y Y coordinate of the center of the ellipse.
		@param rx Horizontal radius in pixels of the ellipse.
		@param ry Vertical radius in pixels of the ellipse.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : AAEllipseColor(x : Int, y : Int, rx : Int, ry : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rx);
			array_args[5] := IntRef->New(ry);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_aaellipse_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw filled ellipse with blending.
		@param x X coordinate of the center of the filled ellipse.
		@param y Y coordinate of the center of the filled ellipse.
		@param rx Horizontal radius in pixels of the filled ellipse.
		@param ry Vertical radius in pixels of the filled ellipse.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : FilledEllipseColor(x : Int, y : Int, rx : Int, ry : Int, color : Color) ~ Int {
			array_args := Base->New[7];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rx);
			array_args[5] := IntRef->New(ry);
			array_args[6] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_filled_ellipse_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw pie (outline) with alpha blending.
		@param x X coordinate of the center of the pie.
		@param y Y coordinate of the center of the pie.
		@param rad Radius in pixels of the pie.
		@param start Starting radius in degrees of the pie.
		@param end Ending radius in degrees of the pie.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : PieColor(x : Int, y : Int, rad : Int, start : Int, end : Int, color : Color) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rad);
			array_args[5] := IntRef->New(start);
			array_args[6] := IntRef->New(end);
			array_args[7] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_pie_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw filled pie with alpha blending.
		@param x X coordinate of the center of the filled pie.
		@param y Y coordinate of the center of the filled pie.
		@param rad Radius in pixels of the filled pie.
		@param start Starting radius in degrees of the filled pie.
		@param end Ending radius in degrees of the filled pie.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : FilledPieColor(x : Int, y : Int, rad : Int, start : Int, end : Int, color : Color) ~ Int {
			array_args := Base->New[8];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(rad);
			array_args[5] := IntRef->New(start);
			array_args[6] := IntRef->New(end);
			array_args[7] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_filled_pie_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw trigon (triangle outline) with alpha blending.
		@param x1 X coordinate of the first point of the trigon.
		@param y1 Y coordinate of the first point of the trigon.
		@param x2 X coordinate of the second point of the trigon.
		@param y2 Y coordinate of the second point of the trigon.
		@param x3 X coordinate of the third point of the trigon.
		@param y3 Y coordinate of the third point of the trigon.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : TrigonColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, x3 : Int, y3 : Int, color : Color) ~ Int {
			array_args := Base->New[9];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := IntRef->New(x3);
			array_args[7] := IntRef->New(y3);
			array_args[8] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_trigon_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw anti-aliased trigon (triangle outline) with alpha blending. 
		Note: Creates vertex array and uses aapolygon routine to render.
		@param x1 X coordinate of the first point of the aa-trigon.
		@param y1 Y coordinate of the first point of the aa-trigon.
		@param x2 X coordinate of the second point of the aa-trigon.
		@param y2 Y coordinate of the second point of the aa-trigon.
		@param x3 X coordinate of the third point of the aa-trigon.
		@param y3 Y coordinate of the third point of the aa-trigon.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : AAtrigonColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, x3 : Int, y3 : Int, color : Color) ~ Int {
			array_args := Base->New[9];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := IntRef->New(x3);
			array_args[7] := IntRef->New(y3);
			array_args[8] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_aatrigon_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw filled trigon (triangle) with alpha blending.
		Note: Creates vertex array and uses aapolygon routine to render.
		@param x1 X coordinate of the first point of the filled trigon.
		@param y1 Y coordinate of the first point of the filled trigon.
		@param x2 X coordinate of the second point of the filled trigon.
		@param y2 Y coordinate of the second point of the filled trigon.
		@param x3 X coordinate of the third point of the filled trigon.
		@param y3 Y coordinate of the third point of the filled trigon.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : FilledTrigonColor(x1 : Int, y1 : Int, x2 : Int, y2 : Int, x3 : Int, y3 : Int, color : Color) ~ Int {
			array_args := Base->New[9];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x1);
			array_args[3] := IntRef->New(y1);
			array_args[4] := IntRef->New(x2);
			array_args[5] := IntRef->New(y2);
			array_args[6] := IntRef->New(x3);
			array_args[7] := IntRef->New(y3);
			array_args[8] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_filled_trigon_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw a character of the currently set font.
		@param x X (horizontal) coordinate of the upper left corner of the character.
		@param y Y (vertical) coordinate of the upper left corner of the character.
		@param c The character to draw.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : CharacterColor(x : Int, y : Int, c : Char, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := IntRef->New(c);
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_character_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
	
		#~
		Draw a string in the currently set font.
		@param x X (horizontal) coordinate of the upper left corner of the string.
		@param y Y (vertical) coordinate of the upper left corner of the string.
		@param s The string to draw.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : StringColor(x : Int, y : Int, s : String, color : Color) ~ Int {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntRef->New(x);
			array_args[3] := IntRef->New(y);
			array_args[4] := s;
			array_args[5] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_string_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Draw polygon with alpha blending.
		@param vx Vertex array containing X coordinates of the points of the polygon.
		@param vy Vertex array containing Y coordinates of the points of the polygon.
		@param n Number of points in the vertex array. Minimum number is 3.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : PolygonColor(vx : Int[], vy : Int[], color : Color) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntArrayRef->New(vx);
			array_args[3] := IntArrayRef->New(vy);
			array_args[4] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_polygon_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
		
		#~
		Draw anti-aliased polygon with alpha blending.
		@param vx Vertex array containing X coordinates of the points of the polygon.
		@param vy Vertex array containing Y coordinates of the points of the polygon.
		@param n Number of points in the vertex array. Minimum number is 3.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : AAPolygonColor(vx : Int[], vy : Int[], color : Color) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntArrayRef->New(vx);
			array_args[3] := IntArrayRef->New(vy);
			array_args[4] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_aapolygon_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Draw filled pie with alpha blending.
		@param vx Vertex array containing X coordinates of the points of the polygon.
		@param vy Vertex array containing Y coordinates of the points of the polygon.
		@param n Number of points in the vertex array. Minimum number is 3.
		@param color color value
		@return 0 on success, -1 on failure
		~#
		method : public : FilledPolygonColor(vx : Int[], vy : Int[], color : Color) ~ Int {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(@renderer);
			array_args[2] := IntArrayRef->New(vx);
			array_args[3] := IntArrayRef->New(vy);
			array_args[4] := color;

			Proxy->GetDllProxy()->CallFunction("sdl_renderer_filled_polygon_color", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
	}

	#~
	Contains information on the capabilities of a render driver or the current render context
	~#
	class RendererInfo {
		@name : String;
	    @flags : Int;
	    @num_texture_formats : Int;
	    @texture_formats : Int[];
	    @max_texture_width : Int;
	    @max_texture_height : Int;
		
		New() {
			@texture_formats := Int->New[16];
		}

		#~
		Get the name of the renderer
		@return renderer name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get a mask of supported renderer flags
		@return renderer flags
		~#
		method : public : GetFlags() ~ Int {
			return @flags;
		}

		#~
		Get the number of available texture formats
		@return texture format number
		~#
		method : public : GetNumTextureFormats() ~ Int {
			return @num_texture_formats;
		}

		#~
		Get the available texture formats
		@return texture formats
		~#
		method : public : GetTextureFormats() ~ Int[] {
			return @texture_formats;
		}

		#~
		Get the the maximum texture width
		@return maximum texture width
		~#
		method : public : GetMaxTextureWidth() ~ Int {
			return @max_texture_width;
		}

		#~
		Get the the maximum texture height
		@return maximum texture height
		~#
		method : public : GetMaxTextureHeight() ~ Int {
			return @max_texture_height;
		}
	}

	#~
	Raw pixel data for surfaces and textures
	~#
	class PixelData {
		@data : Int;
		@pitch : Int;
		@height : Int;

		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @data = 0;
		}

		#~
		Get pixel value for index
		@param index index to get
		@return pixel value for index
		~#
		method : public : Get(index : Int) ~ Int {
			if(@data <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := @self;
				array_args[2] := IntRef->New(index);

				Proxy->GetDllProxy()->CallFunction("sdl_pixeldata_get", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
		
		#~
		Get pixel value for x and y offset
		@param x x-offset
		@param y y-offset
		@return pixel value for index
		~#
		method : public : Get(x : Int, y : Int) ~ Int {
			return Get((y * (@pitch / 4)) + x);
		}

		#~
		Set pixel value for index
		@param index index to set
		@param value value to set
		@return true if set, false otherwise
		~#
		method : public : Set(index : Int, value : Int) ~ Bool {
			if(@data <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := @self;
				array_args[2] := IntRef->New(index);
				array_args[3] := IntRef->New(value);

				Proxy->GetDllProxy()->CallFunction("sdl_pixeldata_set", array_args);

				return_value := array_args[0]->As(IntRef);
				return return_value->Get() = 0 ? false : true;
			};

			return false;
		}

		#~
		Copies raw pixel data
		@param data data to copy
		@return true if copied, false otherwise
		~#
		method : public : Copy(data : PixelData) ~ Bool {
			if(@data <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := @self;
				array_args[2] := data;

				Proxy->GetDllProxy()->CallFunction("sdl_pixeldata_copy", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get() = 0 ? false : true;
			};

			return false;
		}

		#~
		Gets the pitch
		@return pitch value
		~#
		method : public : GetPitch() ~ Int {
			return @pitch;
		}

		#~
		Gets the height
		@return height value
		~#
		method : public : GetHeight() ~ Int {
			return @height;
		}
	}

	#~
	Efficient, driver-specific representation of pixel data.
	~#
	class Texture {
		@texture : Int;

		New(texture : Int) {
			@texture := texture;
		}

		#~
		Create a texture for a rendering context
		@param renderer the rendering context
		@param format one of the enumerated values in SDL_PixelFormatEnum; see Remarks for details
		@param access one of the enumerated values in SDL_TextureAccess; see Remarks for details
		@param w the width of the texture in pixels
		@param h the height of the texture in pixels
		@return created texture
		~#
		New(renderer : Renderer, format : Int, access : Int, w : Int, h : Int) {
			array_args := Base->New[6];
			array_args[0] := IntRef->New();
			array_args[1] := renderer;
			array_args[2] := IntRef->New(format);
			array_args[3] := IntRef->New(access);
			array_args[4] := IntRef->New(w);
			array_args[5] := IntRef->New(h);

			Proxy->GetDllProxy()->CallFunction("sdl_texture_create", array_args);

			value := array_args[0]->As(IntRef);
			@texture := value->Get();
		}

		#~
		Destroy the specified texture
		~#
		method : public : Destroy() ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(@texture);

			Proxy->GetDllProxy()->CallFunction("sdl_texture_destroy", array_args);
		}
		
		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @texture = 0;
		}

		#~
		Query the attributes of a texture
		@param format a holder filled in with the raw format of the texture
		@param access a holder filled in with the actual access to the texture (one of the SDL_TextureAccess values)
		@param w a holder filled in with the width of the texture in pixels
		@param h a holder filled in with the height of the texture in pixels
		@return 0 on success or a negative error code on failure
		~#
		method : public : Query(format : IntRef, access : IntRef, w : IntRef, h : IntRef) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[6];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := format;
				array_args[3] := access;
				array_args[4] := w;
				array_args[5] := h;

				Proxy->GetDllProxy()->CallFunction("sdl_texture_query", array_args);
			
				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Lock a portion of the texture for write-only pixel access
		@param rect an SDL_Rect structure representing the area to lock for access; NULL to lock the entire texture
		@return access to raw pixel data
		~#
		method : public : Lock(rect : Rect) ~ PixelData {
			if(@texture <> 0) {
				array_args := Base->New[3];
				array_args[0] := Nil;
				array_args[1] := IntRef->New(@texture);
				array_args[2] := rect;

				Proxy->GetDllProxy()->CallFunction("sdl_texture_lock", array_args);

				return array_args[0]->As(PixelData);
			};

			return Nil;
		}

		#~
		Unlock a texture, uploading the changes to video memory, if needed.
		~#
		method : public : Unlock() ~ Nil {
			if(@texture <> 0) {
				array_args := Base->New[1];
				array_args[0] := IntRef->New(@texture);

				Proxy->GetDllProxy()->CallFunction("sdl_texture_unlock", array_args);
			};
		}

		#~
		set an additional color value multiplied into render copy operations
		@param r the red color value multiplied into copy operations
		@param g the green color value multiplied into copy operations
		@param b the blue color value multiplied into copy operations
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetColorMod(r : Int, g : Int, b : Int) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := IntRef->New(r);
				array_args[3] := IntRef->New(g);
				array_args[4] := IntRef->New(b);

				Proxy->GetDllProxy()->CallFunction("sdl_texture_set_color_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Get the additional color value multiplied into render copy operations.
		@param r a holder filled in with the current red color value
		@param g a holder filled in with the current green color value
		@param b a holder filled in with the current blue color value
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetColorMod(r : IntRef, g : IntRef, b : IntRef) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := r;
				array_args[3] := g;
				array_args[4] := b;

				Proxy->GetDllProxy()->CallFunction("sdl_texture_get_color_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Set an additional alpha value multiplied into render copy operations.
		@param alpha the source alpha value multiplied into copy operations
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetAlphaMod(alpha : Int) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := IntRef->New(alpha);

				Proxy->GetDllProxy()->CallFunction("sdl_texture_set_alpha_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Get the additional alpha value multiplied into render copy operations.
		@param alpha a holder filled in with the current alpha value
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetAlphaMod(alpha : IntRef) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := alpha;

				Proxy->GetDllProxy()->CallFunction("sdl_texture_get_alpha_mod", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Set the blend mode for a texture
		@param blendMode the BlendMode to use for texture blending
		@return 0 on success or a negative error code on failure
		~#
		method : public : SetBlendMode(blendMode : BlendMode) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := IntRef->New(blendMode->As(Int));

				Proxy->GetDllProxy()->CallFunction("sdl_texture_set_blend_mode", array_args);
				
				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		get the blend mode used for texture copy operations
		@param blendMode a holder filled in with the current BlendMode
		@return 0 on success or a negative error code on failure
		~#
		method : public : GetBlendMode(blendMode : IntRef) ~ Int {
			if(@texture <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@texture);
				array_args[2] := blendMode;

				Proxy->GetDllProxy()->CallFunction("sdl_texture_get_blend_mode", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}
	}
	
	#~
	SDL time management routines
	~#
	class Timer {
		#~
		Get the number of milliseconds since the SDL library initialization
		@return value representing the number of milliseconds since the SDL library initialized
		~#
		function : GetTicks() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();
			
			Proxy->GetDllProxy()->CallFunction("sdl_timer_get_ticks", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Wait a specified number of milliseconds before returning
		@param ms number of milliseconds to delay
		~#
		function : Delay(ms : Int) ~ Nil {
			array_args := Base->New[1];
			array_args[0] := IntRef->New(ms);
			
			Proxy->GetDllProxy()->CallFunction("sdl_timer_delay", array_args);
		}

		#~
		Compares SDL ticks values
		@param a the first ticks values
		@param b the second ticks values
		@return true if A has passed B, false otherwise
		~#
		function : Passed(a : Int, b : Int) ~ Bool {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(a);
			array_args[2] := IntRef->New(b);
			
			Proxy->GetDllProxy()->CallFunction("sdl_ticks_passed", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}
	}

	#~
	TrueType font rendering
	~#
	class Font {
		@font : Int;

		#~
		Initialize the TrueType font APIs
		~#
		function : Init() ~ Int {
			array_args := Base->New[1];
	        array_args[0] := IntRef->New();

	        Proxy->GetDllProxy()->CallFunction("sdl_font_init", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}

		#~
		Shutdown and cleanup the TrueType font APIs
		~#
		function : Quit() ~ Nil {
        	array_args := Base->New[0];
        	Proxy->GetDllProxy()->CallFunction("sdl_font_quit", array_args);
		}
		
		#~
		Load file for use as a font, this can load TTF and FON files.
		@param file file name to load font from.
		@param ptsize Point size (based on 72DPI) to load font as
		~#
		New(file : String, ptsize : Int) {
	        array_args := Base->New[3];
	        array_args[0] := IntRef->New();
	        array_args[1] := file;
	        array_args[2] := IntRef->New(ptsize);

	        Proxy->GetDllProxy()->CallFunction("sdl_font_open", array_args);

	        value := array_args[0]->As(IntRef);
	        @font := value->Get();
		}

		#~
		Load file for use as a font, this can load TTF and FON files.
		@param file file name to load font from.
		@param ptsize Point size (based on 72DPI) to load font as
		@param index choose a font face from a file containing multiple 
		font faces. The first face is always index 0.
		~#
		New(file : String, ptsize : Int, index : Int) {
	        array_args := Base->New[4];
	        array_args[0] := IntRef->New();
	        array_args[1] := file;
	        array_args[2] := IntRef->New(ptsize);
	        array_args[3] := IntRef->New(index);

	        Proxy->GetDllProxy()->CallFunction("sdl_font_open_index", array_args);

	        value := array_args[0]->As(IntRef);
	        @font := value->Get();        
		}

		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @font = 0;
		}

		#~
		Render the LATIN1 encoded text blended
		@param text the LATIN1 null terminated string to render.
		@param fg the color to render the text in. This becomes colormap index 1.
		@return Surface instance, caller responsible for freeing
		~#
		method : public : RenderTextSolid(text : String, fg : Color) ~ Surface {
	        array_args := Base->New[4];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(@font);
	        array_args[2] := text;
	        array_args[3] := fg;

	        Proxy->GetDllProxy()->CallFunction("sdl_font_render_utf8_solid", array_args);

	        value := array_args[0]->As(IntRef);
	        return Surface->New(value->Get());
		}

		#~
		Render the UTF8 encoded text blended
		@param text the LATIN1 null terminated string to render.
		@param fg the color to render the text in. This becomes colormap index 1.
		@return Surface instance, caller responsible for freeing
		~#
		method : public : RenderUTF8Solid(text : String, fg : Color) ~ Surface {
	        array_args := Base->New[4];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(@font);
	        array_args[2] := text;
	        array_args[3] := fg;

	        Proxy->GetDllProxy()->CallFunction("sdl_font_render_utf8_blended", array_args);

	        value := array_args[0]->As(IntRef);
	        return Surface->New(value->Get());
		}














		#~
		Render the LATIN1 encoded text blended
		@param text the LATIN1 null terminated string to render.
		@param fg the color to render the text in. This becomes colormap index 1.
		@return Surface instance, caller responsible for freeing
		~#
		method : public : RenderTextBlended(text : String, fg : Color) ~ Surface {
	        array_args := Base->New[4];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(@font);
	        array_args[2] := text;
	        array_args[3] := fg;

	        Proxy->GetDllProxy()->CallFunction("sdl_font_render_text_blended", array_args);

	        value := array_args[0]->As(IntRef);
	        return Surface->New(value->Get());
		}

		#~
		Render the UTF8 encoded text blended
		@param text the LATIN1 null terminated string to render.
		@param fg the color to render the text in. This becomes colormap index 1.
		@return Surface instance, caller responsible for freeing
		~#
		method : public : RenderUTF8Blended(text : String, fg : Color) ~ Surface {
	        array_args := Base->New[4];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(@font);
	        array_args[2] := text;
	        array_args[3] := fg;

	        Proxy->GetDllProxy()->CallFunction("sdl_font_render_utf8_blended", array_args);

	        value := array_args[0]->As(IntRef);
	        return Surface->New(value->Get());
		}

		#~
		Render the LATIN1 encoded text shaded
		@param text the LATIN1 null terminated string to render.
		@param fg the color to render the text in. This becomes colormap index 1.
		@param bg the color to render the background box in. This becomes colormap index 0.
		@return Surface instance, caller responsible for freeing
		~#
		method : public : RenderTextShaded(text : String, fg : Color, bg : Color) ~ Surface {
	        array_args := Base->New[5];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(@font);
	        array_args[2] := text;
	        array_args[3] := fg;
	        array_args[4] := fg;

	        Proxy->GetDllProxy()->CallFunction("sdl_font_render_text_shaded", array_args);

	        value := array_args[0]->As(IntRef);
	        return Surface->New(value->Get());
		}

		#~
		Render the UTF8 encoded text shaded
		@param text the LATIN1 null terminated string to render.
		@param fg the color to render the text in. This becomes colormap index 1.
		@param bg the color to render the background box in. This becomes colormap index 0.
		@return Surface instance, caller responsible for freeing
		~#
		method : public : RenderUTF8Shaded(text : String, fg : Color, bg : Color) ~ Surface {
	        array_args := Base->New[5];
	        array_args[0] := IntRef->New();
	        array_args[1] := IntRef->New(@font);
	        array_args[2] := text;
	        array_args[3] := fg;
	        array_args[4] := bg;

	        Proxy->GetDllProxy()->CallFunction("sdl_font_render_utf8_shaded", array_args);

	        value := array_args[0]->As(IntRef);
	        return Surface->New(value->Get());
		}
	}

	#~
	Mouse cursor operations
	~#
	class Cursor {
		#~
		Capture the mouse and to track input outside an SDL window
		@param enabled true to enable capturing, false to disable.
		@return 0 on success or -1 if not supported
		~#
		function : CaptureMouse(enabled : Bool) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(enabled ? 1 : 0);

			Proxy->GetDllProxy()->CallFunction("sdl_cursor_capture_mouse", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Move the mouse to the given position in global screen space
		@param x x coordinate
		@param y y coordinate
		@return 0 on success or a negative error code on failure
		~#
		function : WarpMouseGlobal(x : Int, y : Int) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(x);
			array_args[2] := IntRef->New(y);

			Proxy->GetDllProxy()->CallFunction("sdl_cursor_warp_mouse_global", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Retrieve the current state of the mouse
		@param x coordinate of the mouse cursor position relative to the focus window
		@param y coordinate of the mouse cursor position relative to the focus window
		@return current button state as a bitmask
		~#
		function : GetMouseState(x : IntRef, y : IntRef) ~ Int {
	        array_args := Base->New[3];
	        array_args[0] := IntRef->New();
	        array_args[1] := x;
			array_args[2] := y;

	        Proxy->GetDllProxy()->CallFunction("sdl_cursor_get_mouse_state", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}

		#~
		Retrieve the current state of the mouse
		@param p x and y coordinates of the mouse cursor position relative to the focus window
		@return current button state as a bitmask
		~#
		function : GetMouseState(p : Point) ~ Int {
	        array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := p;

	        Proxy->GetDllProxy()->CallFunction("sdl_cursor_get_mouse_state_pt", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}

		#~
		Retrieve the current global state of the mouse
		@param x coordinate of the mouse cursor position relative to the focus window
		@param y coordinate of the mouse cursor position relative to the focus window
		@return current button state as a bitmask
		~#
		function : GetGlobalMouseState(x : IntRef, y : IntRef) ~ Int {
	        array_args := Base->New[3];
	        array_args[0] := IntRef->New();
	        array_args[1] := x;
			array_args[2] := y;

	        Proxy->GetDllProxy()->CallFunction("sdl_cursor_get_global_mouse_state", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}

		#~
		Retrieve the current global state of the mouse
		@param p x and y coordinates of the mouse cursor position relative to the focus window
		@return current button state as a bitmask
		~#
		function : GetGlobalMouseState(p : Point) ~ Int {
	        array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := p;

	        Proxy->GetDllProxy()->CallFunction("sdl_cursor_get_global_mouse_state_pt", array_args);

	        value := array_args[0]->As(IntRef);
	        return value->Get();
		}
	}

	#~
	Portable sound mixing library
	~#
	class Mixer {
		consts Flags {
			MIX_DEFAULT_FORMAT := 0x8010,
			MIX_DEFAULT_CHANNELS := 2,
			MIX_MAX_VOLUME := 128
		}

		#~
		Initialize the mixer API
		@param frequency output sampling frequency in samples per second (Hz).
		you might use MIX_DEFAULT_FREQUENCY(22050) since that is a good value for most games.
		@param format output sample format.
		@param channels Number of sound channels in output.
		Set to 2 for stereo, 1 for mono. This has nothing to do with mixing channels.
		@param chunksize bytes used per output sample.
		@return 0 on success, -1 on errors
		~#
		function : OpenAudio(frequency : Int, format : Int, channels : Int, chunksize : Int) ~ Bool {
			array_args := Base->New[5];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(frequency);
			array_args[2] := IntRef->New(format);
			array_args[3] := IntRef->New(channels);
			array_args[4] := IntRef->New(chunksize);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_open_audio", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0;
		}

		#~
		Shutdown and cleanup the mixer API
		~#
		function : Quit() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_mix_quit", array_args);
		}

		#~
		Gradually fade out which channel over ms milliseconds starting from now.
		@param which channel to fade out, or -1 to fade all channels out.
		@param ms milliseconds of time that the fade-out effect should take to go to silence, starting now.
		@return the number of channels set to fade out
		~#
		function : FadeOutChannel(which : Int, ms : Int) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(which);
			array_args[2] := IntRef->New(ms);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_fade_out_channel", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Halt channel playback, or all channels
		@param channel to stop playing, or -1 for all channels
		@return always returns zero
		~#
		function : HaltChannel(channel : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(channel);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_halt_channel", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Tells you if music is actively playing, or not
		@param channel music channel
		@return true if music is playing, false otherwise
		~#
		function : Playing(channel : Int) ~ Bool {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(channel);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_playing", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() <> 0;
		}

		#~
		Gets the current volume
		@param channel Channel to set mix volume for. -1 will set the volume for all allocated channels.
		@return current volume of the channel
		~#
		function : GetVolume(channel : Int) ~ Int {
			return Volume(channel, -1);
		}

		#~
		Sets the current volume
		@param channel Channel to set mix volume for. -1 will set the volume for all allocated channels.
		@param volume the volume to use from 0 to 128
		@return current volume of the channel
		~#
		function : Volume(channel : Int, volume : Int) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(channel);
			array_args[2] := IntRef->New(volume);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_volume", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
	}

	#~
	Format for an audio chunk
	~#
	class MixChunk {
	    @mix_chunk : Int;

	    #~
	    Load file for use as a sample
	    @param file file name to load sample from
	    ~#
	    New(file : String) {
	    	array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := file;

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_load_wav", array_args);

			value := array_args[0]->As(IntRef);
			@mix_chunk := value->Get();
	    }

	    #~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
	    method : public : IsNull() ~ Bool {
			return @mix_chunk = 0;
		}

		#~
	    Play a PCM audio file
	    @param file file name to play
	    @param sample_rate playback sample rate
	    @param audio_format playback audio format see, AudioFormat
	    @param channels number of playback channels
	    ~#
	    function : PlayPcm(file : String, sample_rate : Int, audio_format : Int, channels : Int) ~ Bool {
	    	array_args := Base->New[5];
	    	array_args[0] := IntRef->New();
			array_args[1] := file;
			array_args[2] := IntRef->New(sample_rate);
			array_args[3] := IntRef->New(audio_format);
			array_args[4] := IntRef->New(channels);

"--- 0 ---"->PrintLine();
			Proxy->GetDllProxy()->CallFunction("sdl_mixer_play_pcm", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 1;
	    }

		#~
		Play chunk on channel
		@param channel to play on, or -1 for the first free unreserved channel.
		@param loops number of loops, -1 is infinite loops. Passing one here 
		plays the sample twice
		@return the channel the sample is played on
		~#
	    method : public : PlayChannel(channel : Int, loops : Int) ~ Int {
	    	return PlayChannelTimed(channel, loops, -1);
	    }

		#~
		Play chunk on channel
		@param channel to play on, or -1 for the first free unreserved channel.
		@param loops Number of loops, -1 is infinite loops
		@param ticks millisecond limit to play sample, at most
		@return the channel the sample is played on
		~#
	    method : public : PlayChannelTimed(channel : Int, loops : Int, ticks : Int) ~ Int {
	    	if(@mix_chunk <> 0) {
				array_args := Base->New[5];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(channel);
				array_args[2] := IntRef->New(@mix_chunk);
				array_args[3] := IntRef->New(loops);
				array_args[4] := IntRef->New(ticks);

				Proxy->GetDllProxy()->CallFunction("sdl_mixer_play_channel_timed", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Fade in sample
		@param channel channel to play on, or -1 for the first free unreserved channel.
		@param loops number of loops, -1 is infinite loops.
		Passing one here plays the sample twice (1 loop).
		@param ms milliseconds of time that the fade-in effect should take to go from 
		silence to full volume.
		@return channel the sample is played on
		~#
		method : public : FadeInChannel(channel : Int, loops : Int, ms : Int) ~ Int {
			return FadeInChannelTimed(channel, loops, ms, -1);
		}
		
		#~
		Fade in sample
		@param channel channel to play on, or -1 for the first free unreserved channel.
		@param loops number of loops, -1 is infinite loops.
		Passing one here plays the sample twice (1 loop).
		@param ms milliseconds of time that the fade-in effect should take to go from 
		silence to full volume.
		@param ticks millisecond limit to play sample, at most
		@return channel the sample is played on
		~#
		method : public : FadeInChannelTimed(channel : Int, loops : Int, ms : Int, ticks : Int) ~ Int {
			if(@mix_chunk <> 0) {
				array_args := Base->New[6];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(channel);
				array_args[2] := IntRef->New(@mix_chunk);
				array_args[3] := IntRef->New(loops);
				array_args[4] := IntRef->New(ms);
				array_args[5] := IntRef->New(ticks);

				Proxy->GetDllProxy()->CallFunction("sdl_mixer_fade_in_channel_timed", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Free the memory used in chunk, and free chunk itself as well.
		~#
	    method : public : Free() ~ Nil {
	    	if(@mix_chunk <> 0) {
				array_args := Base->New[1];
		        array_args[0] := IntRef->New(@mix_chunk);

		        Proxy->GetDllProxy()->CallFunction("sdl_mixer_free_wav", array_args);
		        @mix_chunk := 0;
		    };
		}
	}

	#~
	Music operations
	~#
	class MixMusic {
		@mix_music : Int;

		New(file : String) {
			array_args := Base->New[2];
	        array_args[0] := IntRef->New();
	        array_args[1] := file;

	        Proxy->GetDllProxy()->CallFunction("sdl_mixer_load_mus", array_args);

	        value := array_args[0]->As(IntRef);
			@mix_music := value->Get();
		}

		#~
		Determines if the underlying SDL C-struct is NULL
		@return true if NULL, false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @mix_music = 0;
		}

		#~
		Plays music
		@return true on success, false otherwise
		~#
		function : Playing() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_playing_music", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 1;
		}

		#~
		Pauses music
		@return true on success, false otherwise
		~#
		function : Paused() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();
			
			Proxy->GetDllProxy()->CallFunction("sdl_mixer_paused_music", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 1;
		}

		#~
		Resumes music
		~#
		function : Resume() ~ Nil {
			array_args := Base->New[0];			
			Proxy->GetDllProxy()->CallFunction("sdl_mixer_resume_music", array_args);
		}

		#~
		Pauses music
		~#
		function : Pause() ~ Nil {
			array_args := Base->New[0];			
			Proxy->GetDllProxy()->CallFunction("sdl_mixer_pause_music", array_args);
		}

		#~
		Halts music
		~#
		function : Halt() ~ Nil {
			array_args := Base->New[0];
			Proxy->GetDllProxy()->CallFunction("sdl_mixer_halt_music", array_args);
		}

		#~
		Gets music volume between 0 - 128
		~#
		function : GetVolumeMusic() ~ Int {
			return VolumeMusic(-1);
		}

		#~
		Sets music volume 
		@param volume volume between 0 - 128
		@return set volume
		~#
		function : VolumeMusic(volume : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(volume);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_volume_music", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Plays music
		@param loops number of loops to play or -1 for infinite 
		@return channel music is playing on
		~#
		method : public : PlayMusic(loops : Int) ~ Int {
			if(@mix_music <> 0) {
				array_args := Base->New[3];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@mix_music);
				array_args[2] := IntRef->New(loops);
				
				Proxy->GetDllProxy()->CallFunction("sdl_mixer_play_music", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Fades in music
		@param loops number of loops to play or -1 for infinite 
		@param ms millisecond delay
		@return channel music is playing on
		~#
		method : public : FadeInMusic(loops : Int, ms : Int) ~ Int {
			if(@mix_music <> 0) {
				array_args := Base->New[4];
				array_args[0] := IntRef->New();
				array_args[1] := IntRef->New(@mix_music);
				array_args[2] := IntRef->New(loops);
				array_args[3] := IntRef->New(ms);

				Proxy->GetDllProxy()->CallFunction("sdl_mixer_fade_in_music", array_args);

				value := array_args[0]->As(IntRef);
				return value->Get();
			};

			return -1;
		}

		#~
		Fades out music
		@param ms millisecond delay
		@return number of channels fading out
		~#
		function : FadeOutMusic(ms : Int) ~ Int {
			array_args := Base->New[2];
			array_args[0] := IntRef->New();
			array_args[1] := IntRef->New(ms);

			Proxy->GetDllProxy()->CallFunction("sdl_mixer_fade_out_music", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Free the memory used in chunk, and free chunk itself as well.
		~#
		method : public : Free() ~ Nil {
			if(@mix_music <> 0) {
				array_args := Base->New[1];
		        array_args[0] := IntRef->New(@mix_music);

		        Proxy->GetDllProxy()->CallFunction("sdl_mixer_free_mus", array_args);
		        @mix_music := 0;
		    };
		}
	}

	#~
	Platform specific queries
	~#
	class Platform {
		#~
		Get the name of the platform
		@return platform name
		~#
		function : Get() ~ String {
			array_args := Base->New[1];
			array_args[0] := Nil;

			Proxy->GetDllProxy()->CallFunction("sdl_platform_get", array_args);

			return array_args[0]->As(String);
		}
	}
	
	#~
	Operations for gathering information about the processor's features
	~#
	class CPU {
		#~
		Get the number of CPU cores available
		@return the total number of logical CPU cores
		~#
		function : GetCount() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_get_count", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Determine the L1 cache line size of the CPU
		@return L1 cache line size of the CPU, in bytes.
		~#
		function : GetCacheLineSize() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_get_cache_line_size", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}

		#~
		Determine whether the CPU has the RDTSC instruction
		@return true if the CPU has the RDTSC instruction or false if not
		~#
		function : HasRDTSC() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hasrdtsc", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has AltiVec features
		@return true if present, false otherwise
		~#
		function : HasAltiVec() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_has_alti_vec", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has MMX features
		@return true if present, false otherwise
		~#
		function : HasMMX() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hasmmx", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has 3DNow! features
		@return true if present, false otherwise
		~#
		function : Has3DNow() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_has3d_now", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has SSE features
		@return true if present, false otherwise
		~#
		function : HasSSE() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hassse", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has SSE2 features
		@return true if present, false otherwise
		~#
		function : HasSSE2() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hassse2", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has SSE3 features
		@return true if present, false otherwise
		~#
		function : HasSSE3() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hassse3", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		function : HasSSE41() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hassse41", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has SSE 4.2 features
		@return true if present, false otherwise
		~#
		function : HasSSE42() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hassse42", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has AVX features
		@return true if present, false otherwise
		~#
		function : HasAVX() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hasavx", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Determine whether the CPU has AVX2 features
		@return true if present, false otherwise
		~#
		function : HasAVX2() ~ Bool {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_hasavx2", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get() = 0 ? false : true;
		}

		#~
		Get the amount of RAM configured in the system
		@return amount of RAM in MB
		~#
		function : GetSystemRAM() ~ Int {
			array_args := Base->New[1];
			array_args[0] := IntRef->New();

			Proxy->GetDllProxy()->CallFunction("sdl_cpu_get_systemram", array_args);

			value := array_args[0]->As(IntRef);
			return value->Get();
		}
	}
	
	#~
	Filesystem helper functions
	~#
	class Filesystem {
		#~
		Get the directory where the application was run from. This is where the application data directory is.
		@return an absolute path in UTF-8 encoding to the application data directory
		~#
		function : GetBasePath() ~ String {
			array_args := Base->New[1];
			array_args[0] := Nil;

			Proxy->GetDllProxy()->CallFunction("sdl_filesystem_get_base_path", array_args);

			return array_args[0]->As(String);
		}

		#~
		Use this function to get the "pref dir". This is meant to be where the application 
		can write personal files (Preferences and save games, etc.) that are specific to 
		the application. This directory is unique per user and per application.
		@param org the name of your organization
		@param app the name of your application
		@return UTF-8 string of the user directory in platform-dependent notation
		~#
		function : GetPrefPath(org : String, app : String) ~ String {
			array_args := Base->New[3];
			array_args[0] := Nil;
			array_args[1] := org;
			array_args[2] := app;

			Proxy->GetDllProxy()->CallFunction("sdl_filesystem_get_pref_path", array_args);

			return array_args[0]->As(String);
		}
	}

	#~
	Power management routines
	~#
	class Power {
		#~
		Get the current power supply details.
		@param secs seconds of battery life left
		@param pct percentage of battery life left, between 0 and 100
		@return state of the battery, if any
		~#
		function : GetInfo(secs : IntRef, pct : IntRef) ~ Int {
			array_args := Base->New[3];
			array_args[0] := IntRef->New();
			array_args[1] := secs;
			array_args[2] := pct;

			Proxy->GetDllProxy()->CallFunction("sdl_power_get_info", array_args);

			value := array_args[0]->As(IntRef);
			return value->As(IntRef)->Get();
		}
	}
}
