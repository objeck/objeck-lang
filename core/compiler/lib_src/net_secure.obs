#~~
Copyright (c) 2024 Randy Hollines
~~#

use System.IO.Net, Collection;

#~
Web client support (-lib net)
~#
bundle Web.HTTP {
	#~
	HTTPS client

	```
html := HttpsClient->QuickGet(Web.HTTP.Url->New("https://www.nasa.gov")->ToString();
if(html <> Nil) {
   html->PrintLine();
};
	```
	~#
	class HttpsClient {
		enum Task {
			GET,
			DELETE,
			POST,
			PUT
		}

		# https client support
		@request_headers : Hash<String, String>;
		@response_headers : Hash<String, String>;
		@cookies_enabled : Bool;
		@cookies : Vector<Cookie>;
		@cert_issuer : String;
		@cert_subject : String;
		
		#~
		Default constructor
		@param cookies_enabled true if cookies are enabled, false otherwise		
		~#
		New(cookies_enabled : Bool := false) {
			@request_headers := Hash->New()<String, String>;
			@request_headers->Insert("Cache-Control"->ToLower(), "max-age=0");
			@request_headers->Insert("User-Agent"->ToLower(), "Objeck/1.0");
			
			@response_headers := Hash->New()<String, String>;

			@cookies_enabled := cookies_enabled;
			@cookies := Vector->New()<Cookie>;
		}
		
		#~
		Gets the HTTPS request headers
		@return HTTPS request headers
		~#
		method : public : GetRequestHeaders() ~ Hash<String, String> {
			return @request_headers;
		}

		#~
		Gets the HTTPS response headers
		@return HTTPS response headers
		~#
		method : public : GetResponseHeaders() ~ Hash<String, String> {
			return @response_headers;
		}

		#~
		Adds a HTTPS request header
		@param name header name
		@param value header value
		~#
		method : public : AddHeader(name : String, value : String) ~  Nil {
			@request_headers->Insert(name->ToLower(), value);
		}

		#~
		Removes a HTTPS request header
		@param name header name
		~#
		method : public : RemoveHeader(name : String) ~  Nil {
			@request_headers->Remove(name->ToLower());
		}
		
		#~
		Sets cookie support
		@param cookies_enabled true if cookies are enabled, false otherwise
		~#
		method : public : EnableCookies(cookies_enabled : Bool) ~ Nil {
			@cookies_enabled := cookies_enabled;
		}	
		
		#~
		Gets the cookies
		@return vector of cookies
		~#
		method : public : GetCookies() ~ Vector<Cookie> {
			return @cookies;
		}

		#~
		Get a cookie
		@param name cookie name
		@return found cookie, Nil otherwise
		~#
		method : public : GetCookie(name : String) ~ Cookie {
			each(cookie in @cookies) {
				if(cookie->GetName()->EqualsIgnoreCase(name)) {
					return cookie;
				};
			};

			return Nil;
		}

		#~
		Checks for a cookie
		@param name cookie name
		@return true if found cookie, false otherwise
		~#
		method : public : HasCookie(name : String) ~ Bool {
			return GetCookie(name) <> Nil;
		}
		
		#~
		Sets a cookie
		@param cookie cookie
		~#
		method : public : SetCookie(cookie : Cookie) ~ Nil {
			@cookies->AddBack(cookie);
		}

		#~
		Gets the socket's X.509 certificate issuer name
		@return certificate issuer name
		~#
		method : public : GetIssuer() ~ String {
			return @cert_issuer;
		}

		#~
		Gets the socket's X.509 certificate subject name
		@return certificate subject name
		~#
		method : public : GetSubject() ~ String {
			return @cert_subject;
		}

		method : GetContentType() ~ String {
			value := @response_headers->Find("content-type");
			if(value <> Nil) {
				return value;
			};

			return "text/plain";
		}

		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@return read strings
		~#
		function : QuickPost(url : Web.HTTP.Url, data : Byte[]) ~ Web.HTTP.Response {
			return HttpsClient->New()->Post(url, data);
		}

		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@param content_type content type
		@return read strings
		~#
		function : QuickPost(url : Web.HTTP.Url, data : Byte[], content_type : String) ~ Web.HTTP.Response {
			return QuickPost(url, data, content_type, Nil);
		}
		
		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@param content_type content type
		@param headers key/value headers
		@return read strings
		~#
		function : QuickPost(url : Web.HTTP.Url, data : Byte[], content_type : String, headers : Map<String, String>) ~ Web.HTTP.Response {			
			client := HttpsClient->New();
			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					client->AddHeader(key, value);
				};
			};

			return client->Post(url, data, content_type);
		}		

		#~
		Performs a HTTP POST
		@param url URL
		@param data data to oper
		@return read strings
		~#
		function : QuickPut(url : Web.HTTP.Url, data : Byte[]) ~ Web.HTTP.Response {
			return HttpsClient->New()->Put(url, data);
		}
		
		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@param content_type content type
		@return read strings
		~#
		function : QuickPut(url : Web.HTTP.Url, data : Byte[], content_type : String) ~ Web.HTTP.Response {
			return QuickPut(url, data, content_type, Nil);
		}

		#~
		Performs a HTTP POST
		@param url URL
		@param data data to oper
		@param content_type content type
		@param headers key/value headers
		@return read strings
		~#
		function : QuickPut(url : Web.HTTP.Url, data : Byte[], content_type : String, headers : Map<String, String>) ~ Web.HTTP.Response {			
			client := HttpsClient->New();

			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					client->AddHeader(key, value);
				};
			};

			return client->Put(url, data, content_type);
		}

		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@param content_type content type
		@return string read
		~#
		method : public : Post(url : Web.HTTP.Url, data : Byte[], content_type : String) ~ Web.HTTP.Response {
			return PushPullOperation(url, data, content_type, HttpsClient->Task->POST, Nil);
		}

		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@param content_type content type
		@param pem the Privacy Enhanced Mail file
		@return string read
		~#
		method : public : Post(url : Web.HTTP.Url, data : Byte[], content_type : String, pem : String) ~ Web.HTTP.Response {
			return PushPullOperation(url, data, content_type, HttpsClient->Task->POST, pem);
		}

		#~
		Performs a HTTPS POST
		@param url URL
		@param data data to oper
		@return string read
		~#
		method : public : Post(url : Web.HTTP.Url, data : Byte[]) ~ Web.HTTP.Response {
			return PushPullOperation(url, data, "text/plain", HttpsClient->Task->POST, Nil);
		}

		#~
		Performs a HTTPS PUT
		@param url URL
		@param data data to oper
		@param content_type content type
		@return string read
		~#
		method : public : Put(url : Web.HTTP.Url, data : Byte[], content_type : String) ~ Web.HTTP.Response {
			return PushPullOperation(url, data, content_type, HttpsClient->Task->PUT, Nil);
		}

		#~
		Performs a HTTPS PUT
		@param url URL
		@param data data to oper
		@param content_type content type
		@param pem the Privacy Enhanced Mail file
		@return string read
		~#
		method : public : Put(url : Web.HTTP.Url, data : Byte[], content_type : String, pem : String) ~ Web.HTTP.Response {
			return PushPullOperation(url, data, content_type, HttpsClient->Task->PUT, pem);
		}

		#~
		Performs a HTTPS PUT
		@param url URL
		@param data data to oper
		@return string read
		~#
		method : public : Put(url : Web.HTTP.Url, data : Byte[]) ~ Web.HTTP.Response {
			return PushPullOperation(url, data, "text/plain", HttpsClient->Task->PUT, Nil);
		}

		method : PushPullOperation(url : Web.HTTP.Url, data : Byte[], content_type : String, task : HttpsClient->Task, pem : String) ~ Web.HTTP.Response {
			content : ByteBuffer;
			status_code := 500;

			if(url->GetScheme()->Equals("https")) {
				address := url->GetHost();
				
				location := url->GetPath();
				if(location = Nil) {
					location := "/";
				};

				query := url->GetQuery();
				if(query <> Nil) {
					location += '?';
					location += query;
				};

				frag := url->GetFragment();
				if(frag <> Nil) {
					location += '#';
					location += frag;
				};

				port := url->GetPort();
				if(port < 0) {
					port := 443;
				};
				# "### address='{$address}', port={$port}, location='{$location}'"->PrintLine();

				socket := TCPSecureSocket->New(address, port, pem);
				if(socket->IsOpen()) {
					@response_headers->Empty();

					oper : String;
					
					if(task = HttpsClient->Task->POST) {
						oper := "POST ";
					}
					else {
						oper := "PUT ";
					};

					oper->Append(location);
					oper->Append(" HTTP/1.1\r\nHost: ");
					oper->Append(address);
					oper->Append(':');
					oper->Append(port);
					oper->Append("\r\nContent-Type: ");
					oper->Append(content_type);
					oper->Append("\r\nContent-Length: ");
					oper->Append(data->Size()->ToString());
					oper->Append("\r\n");

					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						oper->Append(request_key);
						oper->Append(": ");
						oper->Append(request_value);
						oper->Append("\r\n");
					};

					if(@cookies_enabled & @cookies->Size() > 0) {
						oper->Append("Cookie: ");
						each(i : @cookies) {
							oper->Append(@cookies->Get(i)->ToShortString());
							if(i + 1 < @cookies->Size()) {
								oper->Append("; ");
							};
						};
						oper->Append("\r\n");
					};
					oper->Append("\r\n");					
					socket->WriteString(oper);
					socket->WriteBuffer(data);
					
					# IO.Console->Print("Post: |")->Print(oper)->PrintLine("|");

					status_line := socket->ReadLine();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					
					# status_line->PrintLine();
					
					if(status_code <> 500) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									@cookies->AddBack(Cookie->New(value));
									# IO.Console->Print("cookie=")->PrintLine(value);
								}
								else {
									@response_headers->Insert(name->ToLower(), value);
								};
							};
						}
						while(line->Size() > 0);
						
						# IO.Console->Print("cookies: size=")->PrintLine(@cookies->Size());
						
						# permanently moved
						if(status_code = 301 | status_code = 302) {
							moved_location := @response_headers->Find("location");
							if(moved_location <> Nil) {
								moved_url_str : String;
								if(moved_location->StartsWith("https://")) {
									moved_url_str := moved_location;
									if(moved_url_str->EndsWith('/')) {
										moved_url_str->Pop();
										moved_url_str += ':';
										moved_url_str += port;
										moved_url_str += '/';
									}
									else {
										moved_url_str += ':';
										moved_url_str += port;
									};
								}
								else {
									moved_url_str := "https://";
									moved_url_str += address;
									if(moved_url_str->EndsWith('/')) {
										moved_url_str->Pop();
										moved_url_str += ':';
										moved_url_str += port;
										moved_url_str += '/';
									}
									else {
										moved_url_str += ':';
										moved_url_str += port;
									};
									moved_url_str += moved_location;
								};

								# IO.Console->Print("permanently moved: ")->PrintLine(moved_url_str);
								return Post(Url->New(moved_url_str), data, content_type);
							};
						};

						# look for chunked blocks
						encoding : String := @response_headers->Find("transfer-encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							# "chunked"->PrintLine();							
							content := WebCommon->ReadChunked(socket);
						}
						else {
							# "Content-Length"->PrintLine();							
							length_header : String := @response_headers->Find("content-length");
							if(length_header <> Nil) {
								content := WebCommon->ReadLength(length_header->ToInt(), socket);
							};
						};
					};
					socket->Close();
				};
			};
			
			if(content = Nil) {
				return Web.HTTP.Response->New(status_code);
			};

			content_type := GetContentType();
			return Web.HTTP.Response->New(content->ToByteArray(), status_code, content_type);
		}
		
		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@return output buffer
		~#
		function : QuickGet(url : Web.HTTP.Url) ~ Web.HTTP.Response {
			return QuickGet(url, "text/plain", Nil);
		}

		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@param headers key/value headers
		@return output buffer
		~#
		function : QuickGet(url : Web.HTTP.Url, headers : Map<String, String>) ~ Web.HTTP.Response {
			return QuickGet(url, "text/plain", headers);
		}

		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@param content_type content type
		@return output buffer
		~#
		function : QuickGet(url : Web.HTTP.Url, content_type : String) ~ Web.HTTP.Response {
			return QuickGet(url, content_type, Nil);
		}
		
		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@param content_type content type
		@param headers key/value headers
		@return output buffer
		~#
		function : QuickGet(url : Web.HTTP.Url, content_type : String, headers : Map<String, String>) ~ Web.HTTP.Response {			
			client := HttpsClient->New();
			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					
					if(value->IsEmpty()) {
						client->RemoveHeader(key);
					}
					else {
						client->AddHeader(key, value);
					};
				};
			};

			return client->Get(url, content_type);
		}

		#~
		Performs a HTTPS GET and returns results as a String
		@param url URL
		@param content_type content type
		@param headers key/value headers
		@param pem the Privacy Enhanced Mail file		
		@return output buffer
		~#
		function : QuickGet(url : Web.HTTP.Url, content_type : String, headers : Map<String, String>, pem : String) ~ Web.HTTP.Response {		
			client := HttpsClient->New();

			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					
					if(value->IsEmpty()) {
						client->RemoveHeader(key);
					}
					else {
						client->AddHeader(key, value);
					};
				};
			};

			return client->Get(url, content_type, pem);
		}

		#~
		Performs a HTTPS GET
		@param url URL
		@return string read
		~#
		method : public : Get(url : Web.HTTP.Url) ~ Web.HTTP.Response {
			return Get(url, "text/plain");
		}

		#~
		Performs a HTTPS GET
		@param url URL
		@param content_type content type
		@return string read
		~#
		method : public : Get(url : Web.HTTP.Url, content_type : String) ~ Web.HTTP.Response {
			return PullOperation(url, content_type, HttpsClient->Task->GET, Nil);
		}

		#~
		Performs a HTTPS GET
		@param url URL
		@param content_type content type
		@return string read
		~#
		method : public : Get(url : Web.HTTP.Url, content_type : String, pem : String) ~ Web.HTTP.Response {
			return PullOperation(url, content_type, HttpsClient->Task->GET, pem);
		}

		#~
		Performs a HTTPS DELETE and returns results as a String
		@param url URL
		@return output buffer
		~#
		function : QuickDelete(url : Web.HTTP.Url) ~ Web.HTTP.Response {
			return QuickDelete(url, "text/plain", Nil);
		}

		#~
		Performs a HTTPS DELETE and returns results as a String
		@param url URL
		@param headers key/value headers
		@return output buffer
		~#
		function : QuickDelete(url : Web.HTTP.Url, headers : Map<String, String>) ~ Web.HTTP.Response {
			return QuickDelete(url, "text/plain", headers);
		}

		#~
		Performs a HTTPS DELETE and returns results as a String
		@param url URL
		@param content_type content type
		@return output buffer
		~#
		function : QuickDelete(url : Web.HTTP.Url, content_type : String) ~ Web.HTTP.Response {
			return QuickDelete(url, content_type, Nil);
		}
		
		#~
		Performs a HTTPS DELETE and returns results as a String
		@param url URL
		@param content_type content type
		@param headers key/value headers
		@return output buffer
		~#
		function : QuickDelete(url : Web.HTTP.Url, content_type : String, headers : Map<String, String>) ~ Web.HTTP.Response {			
			client := HttpsClient->New();
			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					
					if(value->IsEmpty()) {
						client->RemoveHeader(key);
					}
					else {
						client->AddHeader(key, value);
					};
				};
			};

			return client->Delete(url, content_type);
		}

		#~
		Performs a HTTPS DELETE and returns results as a String
		@param url URL
		@param content_type content type
		@param headers key/value headers
		@param pem the Privacy Enhanced Mail file
		@return output buffer
		~#
		function : QuickDelete(url : Web.HTTP.Url, content_type : String, headers : Map<String, String>, pem : String) ~ Web.HTTP.Response {			
			client := HttpsClient->New();
			if(headers <> Nil) {
				header_key_values := headers->GetKeyValues()<Pair<String, String>>;
				each(i : header_key_values) {
					key_value := header_key_values->Get(i);
					key := key_value->GetFirst();
					value := key_value->GetSecond();
					
					if(value->IsEmpty()) {
						client->RemoveHeader(key);
					}
					else {
						client->AddHeader(key, value);
					};
				};
			};

			return client->Delete(url, content_type);
		}

		#~
		Performs a HTTPS DELETE
		@param url URL
		@param content_type content type
		@return string read
		~#
		method : public : Delete(url : Web.HTTP.Url, content_type : String) ~ Web.HTTP.Response {
			return PullOperation(url, content_type, HttpsClient->Task->DELETE, Nil);
		}

		method : PullOperation(url : Web.HTTP.Url, content_type : String, task : HttpsClient->Task, pem : String) ~ Web.HTTP.Response {
			content : ByteBuffer;
			status_code := 500;

			if(url->GetScheme()->Equals("https")) {
				address := url->GetHost();
				
				location := url->GetPath();
				if(location = Nil) {
					location := "/";
				};

				query := url->GetQuery();
				if(query <> Nil) {
					location += '?';
					location += query;
				};

				frag := url->GetFragment();
				if(frag <> Nil) {
					location += '#';
					location += frag;
				};

				port := url->GetPort();
				if(port < 0) {
					port := 443;
				};
				# "### address='{$address}', port={$port}, location='{$location}'"->PrintLine();

				socket := TCPSecureSocket->New(address, port, pem);
				if(socket->IsOpen()) {
					@response_headers->Empty();

					oper : String;

					if(task = HttpsClient->Task->GET) {
						oper := "GET ";
					}
					else {
						oper := "DELETE ";
					};
					
					oper->Append(location);
					oper->Append(" HTTP/1.1\r\nHost: ");
					oper->Append(address);
					oper->Append(':');
					oper->Append(port);
					oper->Append("\r\n");

					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						oper->Append(request_key);
						oper->Append(": ");
						oper->Append(request_value);
						oper->Append("\r\n");
					};
					
					if(@cookies_enabled & @cookies->Size() > 0) {
						oper->Append("Cookie: ");
						each(i : @cookies) {
							oper->Append(@cookies->Get(i)->ToShortString());
							if(i + 1 < @cookies->Size()) {
								oper->Append("; ");
							};
						};
						oper->Append("\r\n");
					};					
					oper->Append("\r\n");		
					
					# IO.Console->Print("Get: |")->Print(oper)->PrintLine("|");
					
					socket->WriteString(oper);
					
					status_line := socket->ReadLine();
					# status_line->PrintLine();

					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, 
							status_line->Size() - "HTTP/1."->Size() - 2);
						index := status_line->Find(' ');
						status_code := status_line->SubString(index)->ToInt();
					};
					# status_code->PrintLine();					

					if(status_code <> 500) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								
								# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									@cookies->AddBack(Cookie->New(value));
									# IO.Console->Print("cookie=")->PrintLine(value);
								}
								else {
									@response_headers->Insert(name->ToLower(), value);
								};
							};
						}
						while(line->Size() > 0);						
						# IO.Console->Print("cookies: size=")->PrintLine(@cookies->Size());
						
						# permanently moved
						if(status_code = 301 | status_code = 302) {
							moved_location := @response_headers->Find("location");
							if(moved_location <> Nil) {
								moved_url_str : String;
								if(moved_location->StartsWith("https://")) {
									moved_url_str := moved_location;
									if(moved_url_str->EndsWith('/')) {
										moved_url_str->Pop();
										moved_url_str += ':';
										moved_url_str += port;
										moved_url_str += '/';
									}
									else {
										moved_url_str += ':';
										moved_url_str += port;
									};
								}
								else {
									moved_url_str := "https://";
									moved_url_str += address;
									if(moved_url_str->EndsWith('/')) {
										moved_url_str->Pop();
										moved_url_str += ':';
										moved_url_str += port;
										moved_url_str += '/';
									}
									else {
										moved_url_str += ':';
										moved_url_str += port;
									};
									moved_url_str += moved_location;
								};
								@response_headers->Empty();

								# IO.Console->Print("permanently moved: ")->PrintLine(moved_url_str);
								return Get(Url->New(moved_url_str), content_type);
							};
						};

						# look for chunked blocks
						encoding : String := @response_headers->Find("transfer-encoding");
						if(encoding <> Nil & encoding->Equals("chunked")) {
							# "chunked"->PrintLine();							
							content := WebCommon->ReadChunked(socket);
						}
						else {
							# "Content-Length"->PrintLine();							
							length_header : String := @response_headers->Find("content-length");
							if(length_header <> Nil) {
								content := WebCommon->ReadLength(length_header->ToInt(), socket);
							};
						};
						@cert_issuer := socket->GetIssuer();
						@cert_subject := socket->GetSubject();
					};
					socket->Close();
				}
				else {
					return Nil;
				};
			}
			
			if(content = Nil) {
				return Web.HTTP.Response->New(status_code);
			};

			content_type := GetContentType();
			return Web.HTTP.Response->New(content->ToByteArray(), status_code, content_type);
		}
	}

	#~
	Secure web socket client

	```
client := SecureWebSocket->New(Url->New("wss://echo.websocket.org"));
if(client->Connect()) {
  client->ReadSocketText()->PrintLine();
  
  client->WriteTextSocket("Hello World!");
  client->ReadSocketText()->PrintLine();
  
  client->CloseSocket();
};
	```
	~#
	class SecureWebSocket {
		# web socket support
		@socket : TCPSecureSocket;
		@header : Byte[];
		@url : Web.HTTP.Url;

		@status_code : Int;
		@status_msg : String;

		# https client support
		@request_headers : Hash<String, String>;
		@response_headers : Hash<String, String>;
		@cookies_enabled : Bool;
		@cookies : Vector<Cookie>;
		@cert_issuer : String;
		@cert_subject : String;

		@is_debug : Bool;

		#~
		Constructor
		@param url URL
		@param cookies_enabled true if cookies are enabled, false otherwise		
		~#
		New(url : Web.HTTP.Url, cookies_enabled : Bool) {
			@url := url;

			@request_headers := Hash->New()<String, String>;
			@request_headers->Insert("Cache-Control"->ToLower(), "max-age=0");
			@request_headers->Insert("User-Agent"->ToLower(), "Objeck/1.0");
			
			@response_headers := Hash->New()<String, String>;

			@cookies_enabled := cookies_enabled;
			@cookies := Vector->New()<Cookie>;

			# @is_debug := true;git pu
		}

		#~
		Constructor
		@param url URL
		~#
		New(url : Web.HTTP.Url) {
			@url := url;

			@request_headers := Hash->New()<String, String>;
			@request_headers->Insert("Cache-Control"->ToLower(), "max-age=0");
			@request_headers->Insert("User-Agent"->ToLower(), "Objeck/1.0");
			
			@response_headers := Hash->New()<String, String>;

			# @is_debug := true;
		}

		#~
		Opens a connection to a web socket
		@return true if connected, false otherwise
		~#
		method : public : Connect() ~ Bool {
			if(@url->GetScheme()->Equals("wss")) {
				address := @url->GetHost();
				
				location := @url->GetPath();
				if(location = Nil) {
					location := "/";
				};

				query := @url->GetQuery();
				if(query <> Nil) {
					location += '?';
					location += query;
				};

				frag := @url->GetFragment();
				if(frag <> Nil) {
					location += '#';
					location += frag;
				};

				port := @url->GetPort();
				if(port < 0) {
					port := 443;
				};
				# "### address='{$address}', port={$port}, location='{$location}'"->PrintLine();

				socket := TCPSecureSocket->New(address, port);
				if(socket->IsOpen()) {
					@response_headers->Empty();

					oper := "GET ";
					
					oper->Append(location);
					oper->Append(" HTTP/1.1\r\nHost: ");
					oper->Append(address);
					oper->Append(':');
					oper->Append(port);
					oper->Append("\r\n");
					
					request_keys := @request_headers->GetKeys()<String>;
					each(i : request_keys) {		
						request_key := request_keys->Get(i);
						request_value := @request_headers->Find(request_key);					
						oper->Append(request_key);
						oper->Append(": ");
						oper->Append(request_value);
						oper->Append("\r\n");
					};

					oper->Append("Connection: Upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: ");

					nonce := Byte->New[16];
					each(i : nonce) {
						nonce[i] := Int->Random(255);
					};
					key := Cipher.Encrypt->Base64(nonce);

					oper->Append(key);
					oper->Append("\r\n\r\n");		
					
					# IO.Console->Print("Get: |")->Print(oper)->PrintLine("|");
					
					socket->WriteString(oper);
					
					status_line := socket->ReadLine();
					if(status_line->StartsWith("HTTP/1.")) {
						status_line := status_line->SubString("HTTP/1."->Size() + 2, status_line->Size() - "HTTP/1."->Size() - 2);
					};

					if(status_line->StartsWith("101 Switching")) {
						# get request headers
						do {
							line := socket->ReadLine();
							if(line->Size() > 0) {
								index := line->Find(':');
								name := line->SubString(index);
								value := line->SubString(index + 1, line->Size() - index - 1)->Trim();
								
								# IO.Console->Print("|")->Print(name)->Print("|, |")->Print(value)->PrintLine("|");
								if(@cookies_enabled & name->Equals("Set-Cookie")) {
									@cookies->AddBack(Cookie->New(value));
									# IO.Console->Print("cookie=")->PrintLine(value);
								}
								else {
									@response_headers->Insert(name->ToLower(), value);
								};
							};
						}
						while(line->Size() > 0);
						
						nonce_hash := @response_headers->Find("sec-websocket-accept");
						# TODO: validate hash response '258EAFA5-E914-47DA-95CA-C5AB0DC85B11' base64 encoded
						if(nonce_hash <> Nil) {
							@socket := socket;
							@header := Byte->New[2];
							return true;
						}
					};
				}
			};	

			return false;
		}

		#~
		Writes binary output to the web socket
		@param data binary payload
		@param fragment true if fragmented, false otherwise
		@return true if successful, false otherwise
		~#
		method : public : WriteSocket(data : Byte[], fragment : Bool := false) ~ Bool {
			chunk_size := 4096;
			data_size := data->Size();
						
			if(fragment & data_size > chunk_size) {
				i := 0;

				if(@is_debug) {
					"0: write - off={$i}, len={$chunk_size}"->PrintLine();
				};
				WriteFrame(data, i, chunk_size, 0, true);

				for(i := chunk_size; chunk_size + i  < data_size; i += chunk_size) {
					if(@is_debug) {
						"1: write - off={$i}, len={$chunk_size}"->PrintLine();
					};

					WriteFrame(data, i, chunk_size, 0, true);
				};	

				# finish frame
				if(data_size - i <> 0) {
					rest := data_size - i;					
					if(@is_debug) {
						"2: write - off={$i}, len={$rest}"->PrintLine();
					};
					
					WriteFrame(data, i, rest, 0, false);
				};
		
				return true;
			}
			else {
				return WriteFrame(data, 0, data->Size(), 1, false);
			};
		}

		#~
		Writes text to the web socket
		@param message message
		@param fragment true if fragmented, false otherwise
		@return true if successful, false otherwise
		~#
		method : public : WriteSocket(message : String, fragment : Bool := false) ~ Bool {
			chunk_size := 5;

			data := message->ToByteArray();
			data_size := data->Size();
			
			if(fragment & data_size > chunk_size) {
				i := 0;

				if(@is_debug) {
					"0: write - off={$i}, len={$chunk_size}"->PrintLine();
				};
				WriteFrame(data, i, chunk_size, 1, true);

				for(i := chunk_size; chunk_size + i  < data_size; i += chunk_size) {
					if(@is_debug) {
						"1: write - off={$i}, len={$chunk_size}"->PrintLine();
					};

					WriteFrame(data, i, chunk_size, 0, true);
				};	

				# finish frame
				if(data_size - i <> 0) {
					rest := data_size - i;					
					if(@is_debug) {
						"2: write - off={$i}, len={$rest}"->PrintLine();
					};
					
					WriteFrame(data, i, rest, 0, false);
				};
		
				return true;
			}
			else {
				return WriteFrame(data, 0, message->Size(), 1, false);
			};
		}

		#~
		Reads binary input from the web socket
		@return binary input read, Nil otherwise
		~#
		method : public : ReadSocketBinary() ~ Byte[] {
			return ReadFrame();
		}

		#~
		Reads text from the web socket
		@return text read, Nil otherwise
		~#
		method : public : ReadSocketText() ~ String {
			data := ReadFrame();
			if(data <> Nil) {
				return String->New(data);
			};

			return Nil;
		}

		method : ReadFrame() ~ Byte[] {
			if(@socket <> Nil) {
				# read header
				each(i : 2) {
					@header[i] := @socket->ReadByte();
				};
				opcode := (@header[0] and 0xff)->As(Byte);

				if(@is_debug){
					System.IO.Console->Print("read - opt+len: ")->PrintLine(@header->ToHexString());
				};

				# ping
				if(opcode = 0x89) {
					payload_length : Int := @header[1];
					buffer := Byte->New[payload_length];
					each(i : payload_length) {
						buffer[i] := @socket->ReadByte();
					};

					if(@is_debug){
						System.IO.Console->Print("ping - payload: ")->PrintLine(buffer->ToHexString());
					};

					@socket->WriteByte(0x8a);
					@socket->WriteBuffer(buffer);

					# read header
					each(i : 2) {
						@header[i] := @socket->ReadByte();
					};
					opcode := (@header[0] and 0xff)->As(Byte);

					if(@is_debug){
						System.IO.Console->Print("read - opt+len: ")->PrintLine(@header->ToHexString());
					};
				};
				
				if(opcode = 0x81 | opcode = 0x82 | opcode = 0x88) {
					payload_length : Int := @header[1];
					if(payload_length = 126) {
						each(i : 2) {
							@header[i] := @socket->ReadByte();
						};

						if(@is_debug){
							System.IO.Console->Print("read - length-ext: ")->PrintLine(@header->ToHexString());
						};

						payload_length := DecodeInt(@header, 0, 2);
					}
					else if(payload_length = 127) {
						buffer := Byte->New[8];

						each(i : 8) {
							buffer[i] := @socket->ReadByte();
						};

						if(@is_debug){
							System.IO.Console->Print("read - length-ext: ")->PrintLine(buffer->ToHexString());
						};

						payload_length := DecodeInt(buffer, 0, 8);
					};

					if(@is_debug){
						System.IO.Console->Print("read - length: ")->PrintLine(payload_length);
					};

					# cap max at 4GB
					if(payload_length < 4294967296) {
						# read payload
						buffer := Byte->New[payload_length];
						each(i : payload_length) {
							buffer[i] := @socket->ReadByte();
						};

						if(opcode = 0x88) {
							@status_code := DecodeInt(@header, 0, 2);
							@status_msg := String->New(buffer, 2, buffer->Size() - 2);
							@socket->Close();

							return Nil;
						};

						if(@is_debug){
							System.IO.Console->Print("read - buffer: '")->Print(buffer->ToHexString())->PrintLine("'\n===");
						};

						return buffer;
					};
				};
			};

			return Nil;
		}

		method : WriteFrame(data : Byte[], offset : Int, length : Int, mode : Int, fragment : Bool) ~ Bool {
			# cap max at 4GB
			if(@socket <> Nil & data <> Nil & length < 4294967296) { # TODO: bounds check
				frame_offset : Int;
				
				# create frame
				frame : Byte[];

				if(length < 126) {
					frame_offset := 6;
				}
				else if(length < 65536) {
					frame_offset := 8;
				}
				else {
					frame_offset := 14;
				};
				frame := Byte->New[frame_offset + length];	
				
				# set utf-8 opcode
				if(fragment) {
					frame[0] := 0x0 + mode;
				}
				else {
					frame[0] := 0x80 + mode;
				};

				# set payload length and bit mask
				mask_payload_length := 0x80; # set mask bit
				if(length < 126) {
					mask_payload_length += length; # payload size
					frame[1] := mask_payload_length;

					if(@is_debug){
						opcodes := Byte->New[2];
						opcodes[0] := frame[0];
						opcodes[1] := frame[1];
						System.IO.Console->Print("write - opcode+length: ")->PrintLine(opcodes->ToHexString());
					};

					# key mask
					frame[2] := Int->Random(255);
					frame[3] := Int->Random(255);
					frame[4] := Int->Random(255);
					frame[5] := Int->Random(255);

					if(@is_debug){
						mask := Byte->New[4];
						mask[0] := frame[2];
						mask[1] := frame[3];
						mask[2] := frame[4];
						mask[3] := frame[5];
						System.IO.Console->Print("write - mask: ")->PrintLine(mask->ToHexString());
					};
				}
				else if(length < 65536) {
					mask_payload_length += 126; # payload size
					
					frame[1] := mask_payload_length;
					EncodeInt(length, frame, 2, 2);

					if(@is_debug){
						opcodes := Byte->New[3];
						opcodes[0] := frame[0];
						opcodes[1] := frame[1];
						opcodes[2] := frame[2];
						System.IO.Console->Print("write - opcode+length-ext-2: ")->PrintLine(opcodes->ToHexString());
					};

					# key mask
					frame[4] := Int->Random(255);
					frame[5] := Int->Random(255);
					frame[6] := Int->Random(255);
					frame[7] := Int->Random(255);

					if(@is_debug){
						mask := Byte->New[4];
						mask[0] := frame[4];
						mask[1] := frame[5];
						mask[2] := frame[6];
						mask[3] := frame[7];
						System.IO.Console->Print("write - mask: ")->PrintLine(mask->ToHexString());
					};
				}
				else {
					mask_payload_length += 127; # payload size

					frame[1] := mask_payload_length;
					EncodeInt(length, frame, 2, 8);

					if(@is_debug){
						opcodes := Byte->New[9];
						opcodes[0] := frame[0];
						opcodes[1] := frame[1];
						opcodes[2] := frame[2];
						opcodes[3] := frame[3];
						opcodes[4] := frame[4];
						opcodes[5] := frame[5];
						opcodes[6] := frame[6];
						opcodes[7] := frame[7];
						opcodes[8] := frame[8];	

						System.IO.Console->Print("write - opcode+length-ext-8: ")->PrintLine(opcodes->ToHexString());
					};

					# key mask
					frame[10] := Int->Random(255);
					frame[11] := Int->Random(255);
					frame[12] := Int->Random(255);
					frame[13] := Int->Random(255);

					if(@is_debug){
						mask := Byte->New[4];
						mask[0] := frame[10];
						mask[1] := frame[11];
						mask[2] := frame[12];
						mask[3] := frame[13];
						System.IO.Console->Print("write - mask: ")->PrintLine(mask->ToHexString());
					};
				};

				# encode payload
				j := 0;
				for(i := 0; i < length; i += 1;) {
					frame[frame_offset + i] := data[i + offset] xor frame[j % 4 + frame_offset - 4];
					j += 1;
				};

				if(@is_debug){
					buffer := ByteBuffer->New();

					each(f in frame) {
						buffer->Append(f)
					};
					
					"write - frame: "->Print();
					buffer->ToByteArray()->ToHexString()->PrintLine();
					"\n==="->PrintLine();
				};

				return @socket->WriteBuffer(frame) > 0;
			};

			return false;
		}

		method : native : EncodeInt(value : Int, bytes : Byte[], offset : Int, num_bytes : Int) ~ Nil {
			shift := (num_bytes - 1) << 3;
			end := offset + num_bytes;

			for(i := offset; i < end; i += 1;) {
				bytes[i] := (value >> shift) and 0xff;
				shift -= 8;
			};
		}

		method : native : DecodeInt(bytes : Byte[], offset : Int, num_bytes : Int) ~ Int {
			value : Int;
			
			shift := (num_bytes - 1) << 3;
			end := offset + num_bytes;

			for(i := offset; i < end; i += 1;) {
				value += bytes[i] and 0xff << shift;
				shift -= 8;
			};

			return value;
		}

		#~
		Pings the websocket server
		@return true if pinged, false otherwise
		~#
		method : public : PingSocket() ~ Bool {
			if(@socket <> Nil) {
				# ping opcode
				@socket->WriteByte(0x89);
				@socket->WriteByte(0x80);

				# payload size
				@socket->WriteByte(0x0);
				@socket->WriteByte(0x0);

				# masking bytes
				@socket->WriteByte(0x0);
				@socket->WriteByte(0x0);
				@socket->WriteByte(0x0);

				# read header
				each(i : 2) {
					@header[i] := @socket->ReadByte();
				};
				opcode := (@header[0] and 0xff)->As(Byte);
				# System.IO.Console->Print("read - opt+len: ")->PrintLine(@header->ToHexString());

				payload_length : Int := @header[1];
				buffer := Byte->New[payload_length];
				each(i : payload_length) {
					buffer[i] := @socket->ReadByte();
				};

				if(@is_debug){
					System.IO.Console->Print("pong - payload: ")->PrintLine(buffer->ToHexString());
				};

				if(opcode = 0x8a) {
					return true;
				};
			};

			return false;
		}

		#~
		Closes the web socket connection
		~#
		method : public : CloseSocket() ~ Nil {
			CloseSocket(1000);
		}

		#~
		Closes the web socket connection
		@param reason reason to close socket
		~#
		method : public : CloseSocket(reason : Int) ~ Nil {
			if(@socket <> Nil) {
				@socket->WriteByte(0x88);

				@socket->WriteByte((reason >> 8) and 0xff);
				@socket->WriteByte(reason and 0xff);
				
				@socket->Close();
			};
		}

		#~
		Gets the last status code 
		@return last status code 
		~#
		method : public : GetStatusCode() ~ Int {
			return @status_code;
		}

		#~
		Gets the last status message
		@return last status message 
		~#
		method : public : GetStatusMessage() ~ String {
			return @status_msg;
		}

		#~
		Gets the socket's X.509 certificate issuer name
		@return certificate issuer name
		~#
		method : public : GetIssuer() ~ String {
			return @cert_issuer;
		}

		#~
		Gets the socket's X.509 certificate subject name
		@return certificate subject name
		~#
		method : public : GetSubject() ~ String {
			return @cert_subject;
		}

		#~
		Sets cookie support
		@param cookies_enabled true if cookies are enabled, false otherwise
		~#
		method : public : EnableCookies(cookies_enabled : Bool) ~ Nil {
			@cookies_enabled := cookies_enabled;
		}	
		
		#~
		Gets the cookies
		@return vector of cookies
		~#
		method : public : GetCookies() ~ Vector<Cookie> {
			return @cookies;
		}

		#~
		Adds a HTTPS request header
		@param name header name
		@param value header value
		~#
		method : public : AddHeader(name : String, value : String) ~  Nil {
			@request_headers->Insert(name->ToLower(), value);
		}

		#~
		Removes a HTTPS request header
		@param name header name
		~#
		method : public : RemoveHeader(name : String) ~  Nil {
			@request_headers->Remove(name->ToLower());
		}
	}
}
