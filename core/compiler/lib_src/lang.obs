#~
Objeck system classes.
Copyright (c) 2008-2025 Randy Hollines
note: compile compiler with -D_SYSTEM flag (on Linux)

>> While it may be fun, best not edit this file. Visual reference: (https://www.youtube.com/watch?v=snTaSJk0n_Y&t=16s) <<<
* This is a special file that bootstraps the compiler
* If you are using a string use 'Append' instead of '+=' otherwise the runtime will crash
* You only have access to classes within this file, so you are unable to use collections
* Return values are not checked as values may come directly from VM system calls
* Bootstrap directives for the VM an TRAP instructions are frequently used, you will have 
* to dig into the VM code to figure out what is going on.
* Primitive classes such as 'Int', 'Bool' and, 'Bool' start with at '$'
~#	

#~
Core system classes 
~#
bundle System {
	#~
	Range interface
	~#
	interface Range {
	    
	}

	#~
	Boolean class
	~#
	class $Bool {
		#~
		Prints a boolean value
		@ignore-params
		~#
		function : Print(b : Bool) ~ Nil {
			STD_OUT_BOOL;
		}

		function : Size(v : Bool) ~ Int {
			if(v) {
				return 1;
			};

			return 0;
		}
		
		#~
		Pseudo random coin flip
		@return true or false
		~#
		function : Flip() ~ Bool {
			return Int->Random(1) % 2 = 0;
		}

		#~
		Prints a boolean value with a newline
		@ignore-params
		~#
		function : PrintLine(b : Bool) ~ Nil {
			STD_OUT_BOOL;
			'\n'->Print();
		}

		function : Print(bb : Bool[]) ~ Nil {
			s := bb->Size();

			each(i : s) {
				b := bb[i];

				b->Print();
				if(i + 1 < s) {
					','->Print();
				};
			};
		}

		function : PrintLine(bb : Bool[]) ~ Nil {
			s := bb->Size();

			each(i : s) {
				b := bb[i];

				b->Print();
				if(i + 1 < s) {
					','->Print();
				};
			};

			""->Print();
		}

		#~
		Prints an error boolean value
		@ignore-params
		~#
		function : Error(b : Bool) ~ Nil {
			STD_ERR_BOOL;
		}

		#~
		Prints an error boolean value with a newline
		@ignore-params
		~#
		function : ErrorLine(b : Bool) ~ Nil {
			STD_ERR_BOOL;
			'\n'->Error();
		}

		function : Size(b : Bool[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(b : Bool[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(b : Bool[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Formats the boolean value into a string
		@ignore-params
		@return string value
		~#
		function : native : ToString(b : Bool) ~ String {
			if(b) {
				return "true";
			};
			
			return "false";
		}
		
		#~
		Returns the number of rows in the matrix
		@param matrix matrix to process
		@return number of rows in the matrix
		~#
		
		function : Rows(matrix : Bool[,]) ~ Int {
			if(matrix <> Nil) {
				dims := matrix->Size();
				return dims[0];
			};

			return 0;
		}

		#~
		Returns the number of columns in the matrix
		@param matrix matrix to process
		@return number of columns in the matrix
		~#
		function : Columns(matrix : Bool[,]) ~ Int {
			if(matrix <> Nil) {
				dims := matrix->Size();
				return dims[1];
			};

			return 0;
		}

		#~
		Formats the boolean array into a string
		@param b boolean array
		@return string value
		~#
		function : native : ToString(b : Bool[]) ~ String {
			buffer := "[";
			each(i : b) {
				buffer->Append(b[i]);
				if(i + 1 < b->Size()) {
					buffer->Append(',');
				}
			};
			buffer->Append(']');

			return buffer;
		}
		
		#~
		Returns a string representation of the boolean array
		@param v boolean array
		@return string representation of the boolean array
		~#
		function : ToString(v : Bool[,]) ~ String {
			buffer := "[";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					buffer->Append(v[r,c]);
					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				if(r + 1 < rows) {
					buffer->Append("]\n");
				}
				else {
					buffer->Append(']');
				};
			};
			buffer->Append(']');

			return buffer;
		}
	}
	
	#~
	Base class for numbers
	~#
	class Number {
		#~
		Number formats.<br/>
		<p><pre>Number->Format</pre></p>
		@class Number
		~#
		enum Format := -20 {
			FIXED,
			SCIENTIFIC,
			HEX,
			DEC,
			OCT,
			DEFAULT
		}

		function : IntToString(value : Int, base : Int, buffer : Char[]) ~ Nil {
			I2S;
		}

		function : FloatToString(value : Float, buffer : Char[]) ~ Nil {
			F2S;
		}
	}

	#~
	The byte class represents a 1-byte value.
	~#
	class $Byte from Number {
		#~
		Compresses a byte stream using zlib
		@ignore-params
		@return compressed bytes
		~#
		function : CompressZlib(input : Byte[]) ~ Byte[] {
			COMPRESS_ZLIB_BYTES;
		}

		#~
		Uncompresses a byte stream using zlib
		@ignore-params
		@return uncompressed bytes
		~#
		function : UncompressZlib(input : Byte[]) ~ Byte[] {
			UNCOMPRESS_ZLIB_BYTES;
		}

		#~
		Compresses a byte stream using gzip
		@ignore-params
		@return compressed bytes
		~#
		function : CompressGzip(input : Byte[]) ~ Byte[] {
			COMPRESS_GZIP_BYTES;
		}

		#~
		Uncompresses a byte stream using gzip
		@ignore-params
		@return uncompressed bytes
		~#
		function : UncompressGzip(input : Byte[]) ~ Byte[] {
			UNCOMPRESS_GZIP_BYTES;
		}

		#~
		Compresses a byte stream using Brotli
		@ignore-params
		@return compressed bytes
		~#
		function : CompressBr(input : Byte[]) ~ Byte[] {
			COMPRESS_BR_BYTES;
		}

		#~
		Uncompresses a byte stream using Brotli
		@ignore-params
		@return uncompressed bytes
		~#
		function : UncompressBr(input : Byte[]) ~ Byte[] {
			UNCOMPRESS_BR_BYTES;
		}

		#~
		Calculates the signed CRC32 value for the stream
		@ignore-params
		@return signed CRC32
		~#
		function : CRC32(input : Byte[]) ~ Int {
			CRC32_BYTES;
		}
		
		#~
		Returns a given value between an upper and lower bound
		@param min minimal value
		@param value value between the min and max
		@param max maximum value
		@return min if vaule is less than main, max if max is less than value, otherwise the value
		~#
		function : Clamp(min : Byte, value : Byte, max : Byte) ~ Byte {
			temp := value < min ? min : value;
			return temp > max ? max : temp;
		}

		#~
		Returns the smallest byte value
		@param l value to compare
		@param r value to compare
		@return smallest byte value
		~#
		function : Min(l : Byte, r : Byte) ~ Byte {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest byte value
		@param l value to compare
		@param r value to compare
		@return largest byte value
		~#
		function : Max(l : Byte, r : Byte) ~ Byte {
			if(l > r) {
				return l;
			};

			return r;
		}
		
		#~
		Compares two values
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Byte, r : Byte) ~ Int {
			if(l < r) {
				return -1;
			}
			else if(l > r) {
				return 1;
			};

			return 0;
		}

		#~
		Returns the Float value
		@ignore-params
		@return value
		~#
		function : ToFloat(v : Byte) ~ Float {
			return v->As(Float);
		}

		#~
		Returns the Character value
		@ignore-params
		@return value
		~#
		function : ToChar(v : Byte) ~ Char {
			return v->As(Char);
		}

		#~
		Returns the Int value
		@ignore-params
		@return value
		~#
		function : ToInt(v : Byte) ~ Int {
			return v->As(Int);
		}

		function : Size(v : Byte) ~ Byte {
			return v;
		}

		#~
		Returns the absolute value
		@ignore-params
		@return absolute value
		~#
		function : Abs(v : Byte) ~ Byte {
			if(v < 0) {
				v := (v - 1) xor -1;
			};

			return v;
		}

		#~
		Checks is a number is negative
		@ignore-params
		@return true if negative, false otherwise
		~#
		function : IsNeg(v : Byte) ~ Bool {
			if(v < 0) {
				return true;
			};

			return false;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(b : Byte) ~ Nil {
			STD_OUT_BYTE;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(b : Byte) ~ Nil {
			STD_OUT_BYTE;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(b : Byte) ~ Nil {
			STD_ERR_BYTE;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(b : Byte) ~ Nil {
			STD_ERR_BYTE;
			'\n'->Error();
		}

		function : Size(b : Byte[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Copy(b : Byte[]) ~ Byte[] {
			s := b->Size();
			o := Byte->New[s];
			Runtime->Copy(o, 0, b, 0, s);	
			return o;
		}
		
		#~
		Set all array elements to zero
		@param b byte array
		~#
		function : Clear(b : Byte[]) ~ Nil {
			ZERO_BYTE_ARY;
		}
		
		#~
		Converts the byte array to a character array
		@param b array
		@return character array
		~#
		function : ToUnicode(b : Byte[]) ~ Char[] {
			BYTES_TO_UNICODE;
		}
		
		function : native :  Sort(v : Byte[]) ~ Byte[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Byte->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Byte[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high - low) / 2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};

				while(array[j] > pivot) {
					j-=1;
				};

				if(i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};

			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}

		function : Size(b : Byte[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(b : Byte[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}
		
		#~
		Returns a binary string representation of the value
		@ignore-params
		@return binary string representation of the value
		~#
		function : native : ToBinaryString(v : Byte) ~ String {
			out := "";
			do {
				out->Append(v and 1 = 0 ? '0' : '1');
				v := v >> 1;
			} 
			while(v <> 0);

			return out->Reverse();
		}

		#~
		Returns a positive hexadecimal string representation of the value
		@ignore-params
		@return hexadecimal string representation of the value
		~#
		function : native : ToHexString(b : Byte) ~ String {
			buffer := Char->New[32];
			Number->IntToString(b, 16, buffer);
			return String->New(buffer, false);
		}
		
		function : native : ToHexString(b : Byte[]) ~ String {
			out := "["

			if(b->Size() > 0) {
				each(i : b) {
					buffer := Char->New[32];
					Number->IntToString(b[i]->As(Int), 16, buffer);
					out->Append(buffer);
					out->Append(',');
				};
				out->Pop();
			};

			out->Append(']');

			return out;
		}
		
		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(b : Byte) ~ String {
			buffer := Char->New[4];
			Number->IntToString(b->As(Int), 32, buffer);
			return String->New(buffer, false);
		}
		
		#~
		Prints values
		@param v values to print
		~#
		function : native : PrintLine(v : Byte[]) ~ Nil {
			String->New(v)->PrintLine();
		}

		#~
		Prints values
		@param v values to print
		~#
		function : native : PrintLine(v : Byte[,]) ~ Nil {
			ToString(v)->PrintLine();
		}

		#~
		Returns a string representation of the byte array
		@param v byte array
		@return string representation of the byte array
		~#
		function : native : ToString(v : Byte[]) ~ String {
			return String->New(v);
		}

		#~
		Returns a string representation of the byte array
		@param v byte array
		@return string representation of the byte array
		~#
		function : ToString(v : Byte[,]) ~ String {
			buffer := "[";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					buffer->Append(v[r,c]);
					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				buffer->Append(']');
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Searches for all occurrences of the byte array
		@param bytes byte array to search
		@param search byte array to search for
		@return an array of indexes
		~#
		function : FindAll(bytes : Byte[], search : Byte[]) ~ Int[] {
			buffer_max := 8;
			buffer := Int->New[buffer_max];
			
			count := 0;
			offset := 0;
			do {
				# check
				offset := Find(bytes, offset, search);
				# found
				if(offset > -1) {
					count += 1;
					if(count < buffer_max) {
						buffer[count - 1] := offset;
					}
					# copy elements
					else {
						temp := Int->New[buffer_max * 2];
						Runtime->Copy(temp, 0, buffer, 0, buffer_max);
						buffer_max *= 2;
						buffer := temp;
					};
					offset += search->Size();
				};
			}
			while(offset > -1);
			
			results := Int->New[count];
			each(i : results) {
				results[i] := buffer[i];
			};

			return results;
		}

		#~
		Searches for the first occurrence of a byte
		@param bytes byte array to search
		@param search byte to search for
		@return true of found, false otherwise
		~#
		function : native : Find(bytes : Byte[], search : Byte) ~ Int {
			return Find(bytes, 0, search);
		}

		#~
		Searches for the first occurrence of a byte
		@param bytes byte array to search
		@param offset search offset
		@param search byte to search for
		@return true of found, false otherwise
		~#
		function : native : Find(bytes : Byte[], offset : Int, search : Byte) ~ Int {
			if(offset < bytes->Size() & offset > -1) {
				for(i := offset; i < bytes->Size(); i += 1;) {
					if(bytes[i] = search) {
						return i;
					};
				};
			};

			return -1;
		}

		#~
		Searches for the first occurrence of a byte array
		@param bytes byte array to search
		@param search byte array to search for
		@return index of first occurrence, -1 otherwise
		~#
		function : native : Find(bytes : Byte[], search : Byte[]) ~ Int {
			return Find(bytes, 0, search);
		}
		
		#~
		Searches for the first occurrence of a byte array
		@param bytes byte array to search
		@param offset search offset
		@param search byte array to search for
		@return index of first occurrence, -1 otherwise
		~#
		function : native : Find(bytes : Byte[], offset : Int, search : Byte[]) ~ Int {
			bytes_size := bytes->Size();
			search_size := search->Size();

			if(search_size > 0 & offset < bytes_size) {
				found_index := Find(bytes, offset, search[0]);
				while(found_index > -1) {
					j := found_index;
					match := true;
					i : Int;
					for(i := 0; match & i < search_size & j < bytes_size; i += 1;) {
						if(search[i] <> bytes[j]) {
							match := false;
						};
						j += 1;
					};
					
					if(match & i = search_size) {
						return found_index;
					};
					
					found_index := Find(bytes, found_index + 1, search[0]);
				};

				return -1;
			};

			return -1;
		}
	}

	#~
	Character class represents a Unicode character value.
	~#	
	class $Char from Number {
		#~
		Converts character to lower-case
		@ignore-params
		@return lower-case representation
		~#
		function : ToLower(c : Char) ~ Char {
			if(c >= 'A' & c <= 'Z') {
				return c + 32;
			};

			return c;
		}

		function : Size(v : Char) ~ Char {
			return v;
		}

		#~
		Returns a hex string value
		@ignore-params
		@return hex string value
		~#
		function : native : ToHexString(v : Char) ~ String {
			buffer := Char->New[32];
			Number->IntToString(v->As(Int), 16, buffer);
			return String->New(buffer, false);
		}
		
		function : native : ToHexString(v : Char[]) ~ String {
			out := "[";

			if(v->Size() > 0) {
				each(i : v) {
					buffer := Char->New[32];
					n := v[i]->As(Int);
					Number->IntToString(n->Abs(), 16, buffer);
					out->Append(buffer);
					out->Append(',');
				};
				out->Pop();
			};
			
			out->Append(']');
			return out;
		}

		#~
		Converts character to upper-case
		@ignore-params
		@return upper-case representation
		~#
		function : native : ToUpper(c : Char) ~ Char {
			if(c >= 'a' & c <= 'z') {
				return c - 32;
			};

			return c;
		}
		
		#~
		Returns the Float value
		@ignore-params
		@return value
		~#
		function : ToFloat(v : Char) ~ Float {
			return v->As(Float);
		}

		#~
		Returns the Character value
		@ignore-params
		@return value
		~#
		function : ToByte(v : Byte) ~ Byte {
			return v->As(Byte);
		}

		#~
		Returns the Int value
		@ignore-params
		@return value
		~#
		function : ToInt(v : Char) ~ Int {
			return v->As(Int);
		}
		
		#~
		Checks if the character is lower-case
		@ignore-params
		@return true if lower-case, false otherwise
		~#
		function : native : IsLower(c : Char) ~ Bool {
			if(c >= 'a' & c <= 'z') {
				return true;
			};

			return false;
		}

		#~
		Checks if the character is upper-case
		@ignore-params
		@return true if upper-case, false otherwise
		~#
		function : native : IsUpper(c : Char) ~ Bool {
			if(c >= 'A' & c <= 'Z') {
				return true;
			};

			return false;
		}
		
		#~
		Compares two values
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Char, r : Char) ~ Int {
			if(l < r) {
				return -1;
			}
			else if(l > r) {
				return 1;
			};

			return 0;
		}

		#~
		Checks of the character is a numeric digit
		@ignore-params
		@return true if numeric digit, false otherwise
		~#
		function : native : IsDigit(c : Char) ~ Bool {
			if(c >= '0' & c <= '9') {
				return true;
			};
			
			return false;
		}

		#~
		Checks of the character is white space
		@ignore-params
		@return true if white space, false otherwise
		~#
		function : native : IsWhitespace(c : Char) ~ Bool {
			if(c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = '\v' | c = '\f' | 
					c = 0xa0 | c = 0x1680 | c >= 0x2000 & c <= 0x200a | c >= 0x000a & c <= 0x000d | 
					c = 0x202f | c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029) {
				return true;
			};
			
			return false;
		}

		#~
		Checks of the character is a alpha digit
		@ignore-params
		@return true if alpha digit, false otherwise
		~#
		function : native : IsChar(c : Char) ~ Bool {
			if((c >= 'a' & c <= 'z') | (c >= 'A' & c <= 'Z')) {
				return true;
			};
			
			return false;
		}
		
		#~
		Returns the smallest byte value
		@param l value to compare
		@param r value to compare
		@return smallest byte value
		~#
		function : native : Min(l : Char, r : Char) ~ Char {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest byte value
		@param l value to compare
		@param r value to compare
		@return largest byte value
		~#
		function : native : Max(l : Char, r : Char) ~ Char {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Returns a given value between an upper and lower bound
		@param min minimal value
		@param value value between the min and max
		@param max maximum value
		@return min if vaule is less than main, max if max is less than value, otherwise the value
		~#
		function : Clamp(min : Char, value : Char, max : Char) ~ Char {
			temp := value < min ? min : value;
			return temp > max ? max : temp;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(c : Char) ~ Nil {
			STD_OUT_CHAR;
		}

		function : PrintLine(c : Char) ~ Nil {
			STD_OUT_CHAR;
			'\n'->Print();
		}
		
		#~
		Prints value with newline
		@ignore-params
		~#
		function : native :  Sort(c : Char[]) ~ Char[] {
			size := c->Size();
			if(size <= 1) {
				return c;
			};			
			array := Char->New[size];
			Runtime->Copy(array, 0, c, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Char[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high - low) / 2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if(i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}

		function : Print(c : Char[]) ~ Nil {
			STD_OUT_STRING;
		}

		function : PrintLine(c : Char[]) ~ Nil {
			STD_OUT_STRING;
			'\n'->Print();
		}

		function : ToString(c : Char[]) ~ String {
			return String->New(c);
		}

		#~
		Returns a string representation of the char array
		@param v char array
		@return string representation of the char array
		~#
		function : ToString(v : Char[,]) ~ String {
			buffer := "[";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					buffer->Append(v[r,c]);
					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				if(r + 1 < rows) {
					buffer->Append("]\n");
				}
				else {
					buffer->Append(']');
				};
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(c : Char) ~ Nil {
			STD_ERR_CHAR;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(c : Char) ~ Nil {
			STD_ERR_CHAR;
			'\n'->Error();
		}

		function : Error(c : Char[]) ~ Nil {
			STD_ERR_STRING;
		}

		function : ErrorLine(c : Char[]) ~ Nil {
			STD_ERR_STRING;
			'\n'->Error();
		}
		
		function : Size(c : Char[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Copy(c : Char[]) ~ Char[] {
			s := c->Size();
			o := Char->New[s];
			Runtime->Copy(o, 0, c, 0, s);	
			return o;
		}

		#~
		Set all array elements to zero
		@param c array
		~#
		function : Clear(c : Char[]) ~ Nil {
			ZERO_CHAR_ARY;
		}
		
		#~
		Converts the character array to a byte array
		@param c character array
		@return byte array
		~#
		function : ToBytes(c : Char[]) ~ Byte[] {		
			UNICODE_TO_BYTES;
		}
		
		function : Size(c : Char[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(c : Char[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(c : Char) ~ String {
			string := String->New();
			string->Append(c);
			return string;
		}

		#~
		Returns an unsigned string representation of the value
		@ignore-params
		@return unsigned string representation of the value
		~#
		function : native : ToStringUnsigned(c : Char) ~ String {
			string := String->New();
			string->Append(c->As(Int)->Abs());
			return string;
		}
		
		#~
		Searches for all occurrences of the character array
		@param chars character array to search
		@param search character array to search for
		@return an array of indexes
		~#
		function : FindAll(chars : Char[], search : Char[]) ~ Int[] {
			buffer_max := 8;
			buffer := Int->New[buffer_max];
			
			count := 0;
			offset := 0;
			do {
				# check
				offset := Find(chars, offset, search);
				# found
				if(offset > -1) {
					count += 1;
					if(count < buffer_max) {
						buffer[count - 1] := offset;
					}
					# copy elements
					else {
						temp := Int->New[buffer_max * 2];
						Runtime->Copy(temp, 0, buffer, 0, buffer_max);
						buffer_max *= 2;
						buffer := temp;
					};
					offset += search->Size();
				};
			}
			while(offset > -1);
			
			results := Int->New[count];
			each(i : results) {
				results[i] := buffer[i];
			};

			return results;
		}

		#~
		Searches for the first occurrence of a byte
		@param chars character array to search
		@param search byte to search for
		@return true of found, false otherwise
		~#
		function : native : Find(chars : Char[], search : Char) ~ Int {
			return Find(chars, 0, search);
		}

		#~
		Searches for the first occurrence of a byte
		@param chars character array to search
		@param offset search offset
		@param search byte to search for
		@return true of found, false otherwise
		~#
		function : native : Find(chars : Char[], offset : Int, search : Char) ~ Int {
			if(offset < chars->Size() & offset > -1) {
				for(i := offset; i < chars->Size(); i += 1;) {
					if(chars[i] = search) {
						return i;
					};
				};
			};

			return -1;
		}

		#~
		Searches for the first occurrence of a character array
		@param chars character array to search
		@param search character array to search for
		@return index of first occurrence, -1 otherwise
		~#
		function : native : Find(chars : Char[], search : Char[]) ~ Int {
			return Find(chars, 0, search);
		}
		
		#~
		Searches for the first occurrence of a character array
		@param chars character array to search
		@param offset search offset
		@param search character array to search for
		@return index of first occurrence, -1 otherwise
		~#
		function : native : Find(chars : Char[], offset : Int, search : Char[]) ~ Int {
			chars_size := chars->Size();
			search_size := search->Size();

			if(search_size > 0 & offset < chars_size) {
				found_index := Find(chars, offset, search[0]);
				while(found_index > -1) {
					j := found_index;
					match := true;
					i : Int;
					for(i := 0; match & i < search_size & j < chars_size; i += 1;) {
						if(search[i] <> chars[j]) {
							match := false;
						};
						j += 1;
					};
					
					if(match & i = search_size) {
						return found_index;
					};
					
					found_index := Find(chars, found_index + 1, search[0]);
				};

				return -1;
			};

			return -1;
		}
	}

	#~
	Character range used primarily for looping
	~#	
	class CharRange implements Range {
		@start : Char;
		@end : Char;
		@step : Char;
		
		#~
		Constructor.
		@param start starting index
		@param end ending index
		@param step step by value
		~#
		New(start : Char, end : Char, step : Char) {
			Parent();
			@start := start;
			@end := end;
			@step := step;
		}

		#~
		Constructor.
		@param start starting index
		@param end ending index
		~#
		New(start : Char, end : Char) {
			Parent();
			@start := start;
			@end := end;
			@step := 1;
		}

		#~
		Constructor.
		@param end ending index
		~#
		New(end : Char) {
			Parent();
			@start := '\0';
			@end := end;
			@step := 1;
		}

		#~
		Gets the starting index
		@return starting index
		~#
		method : public : GetStart() ~ Char {
			return @start;
		}

		#~
		Sets the starting index
		@param start starting index
		~#
		method : public : SetStart(start : Char) ~ Nil {
			@start := start;
		}

		#~
		Gets the ending index
		@return ending index
		~#
		method : public : GetEnd() ~ Char {
			return @end;
		}

		#~
		Sets the ending index
		@param end ending index
		~#
		method : public : SetEnd(end : Char) ~ Nil {
			@end := end;
		}

		#~
		Gets the step value
		@return step value
		~#
		method : public : GetStep() ~ Char {
			return @step;
		}

		#~
		Sets the step value
		@param step step value
		~#
		method : public : SetStep(step : Char) ~ Nil {
			@step := step;
		}
	}
	
	#~
	Integer class represents an operating system long value
	~#
	class $Int from Number {
		#~
		Calculates the factorial of the value
		@param n number
		@return factorial of the value
		~#
		function : native : Factorial(n : Int) ~ Int {
			result := 1;
			
			for(i := 1; i <= n; i += 1;) {
				result *= i;
			};

			return result;
		}

		#~
		Calculates the double factorial of the value
		@param n number
		@return double factorial of the value
		~#
		function : native : DoubleFactorial(n : Int) ~ Int {
			value := 1;

			for(i := n; i >= 0; i -= 2;) {
				if(i = 0 | i = 1) {
					return value;
				}
				else {
					value *= i;
				};
			};

			return value;
		}

		#~
		Returns a NaN value
		@return NaN value
		~#
		function : NaN() ~ Int {
			NAN_INT;
		}

		#~
		Returns a positive infinity value
		@return positive infinity value
		~#
		function : Inf() ~ Int {
			INF_INT;
		}

		#~
		Returns a negative infinity value
		@return negative infinity value
		~#
		function : NegInf() ~ Int {
			NEG_INF_INT;
		}

		#~
		Returns the maximum size of an integer
		@return maximum size of an integer
		~#
		function : MaxSize() ~ Int {
			return (-1 + Int->MinSize());
		}

		#~
		Returns the minimum size of an integer
		@return maximum size of an integer
		~#
		function : MinSize() ~ Int {
			return 2->Pow(63);
		}
		
		#~
		Returns a pseudo random value between 0 and 1, inclusive
		@param range_start minimum value
		@param range_end maximum value
		@return pseudo random value
		~#
		function : Random(range_start : Int, range_end : Int) ~ Int {
			if(range_start >= range_end) {
				return 0;
			};
				
			return Int->Random(range_end - range_start) + range_start;
		}

		#~
		Returns a random number between 0 and max value, inclusive
		@param max max value
		@return random number within range
		~#
		function : Random(max : Int) ~ Int {
			max += 1;
			if(max <= 0) {
				return 0;
			};

			return (Float->Random() * 1000000000.0)->As(Int) % max;
		}

		#~
		Calculates the power value
		@param b power base
		@param r power to raise
		@return pseudo power value
		~#
		function : Pow(b : Int, r : Int) ~ Int {
			return Float->Pow(b->As(Float), r->As(Float))->Round();
		}

		#~
		Calculates the power value
		@param b power base
		@param r power to raise
		@return pseudo power value
		~#
		function : Pow(b : Int, r : Float) ~ Float {
			return Float->Pow(b->As(Float), r);
		}

		#~
		Returns the sign of a number
		@ignore-params
		@return sign of a number
		~#
		function : Sign(a : Int) ~ Int {
			if(a < 0) {
				return -1;
			}
			else if(a > 0) {
				return 1;
			};

			return 0;
		}

		#~
		Calculates the square root
		@ignore-params
		@return square root value
		~#
		function : Sqrt(a : Int) ~ Int {
			return Float->Sqrt(a->As(Float))->Round();
		}

		#~
		Calculates the cube root
		@ignore-params
		@return cube root value
		~#
		function : Cbrt(a : Int) ~ Int {
			return Float->Cbrt(a->As(Float))->Round();
		}

		#~
		Returns the smallest integer value
		@param l value to compare
		@param r value to compare
		@return smallest integer value
		~#
		function : native : Min(l : Int, r : Int) ~ Int {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Compares two values
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Int, r : Int) ~ Int {
			if(l < r) {
				return -1;
			}
			else if(l > r) {
				return 1;
			};

			return 0;
		}
	
		#~
		Returns the largest integer value
		@param l value to compare
		@param r value to compare
		@return largest integer value
		~#
		function : native : Max(l : Int, r : Int) ~ Int {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Returns a given value between an upper and lower bound
		@param min minimal value
		@param value value between the min and max
		@param max maximum value
		@return min if vaule is less than main, max if max is less than value, otherwise the value
		~#
		function : Clamp(min : Int, value : Int, max : Int) ~ Int {
			temp := value < min ? min : value;
			return temp > max ? max : temp;
		}

		#~
		Returns the absolute value
		@ignore-params
		@return absolute value
		~#
		function : Abs(v : Int) ~ Int {
			if(v < 0) {
				v := (v - 1) xor -1;
			};

			return v;
		}

		#~
		Checks is a number is negative
		@ignore-params
		@return true if negative, false otherwise
		~#
		function : IsNeg(v : Int) ~ Bool {
			if(v < 0) {
				return true;
			};

			return false;
		}

		function : Size(v : Int) ~ Int {
			return v;
		}

		#~
		Returns the Float value
		@ignore-params
		@return value
		~#
		function : ToFloat(v : Int) ~ Float {
			return v->As(Float);
		}

		#~
		Returns the Character value
		@ignore-params
		@return value
		~#
		function : ToChar(v : Int) ~ Char {
			return v->As(Char);
		}

		#~
		Returns the Byte value
		@ignore-params
		@return value
		~#
		function : ToByte(v : Int) ~ Byte {
			return v->As(Byte);
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(i : Int) ~ Nil {
			STD_OUT_INT;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(i : Int) ~ Nil {
			STD_OUT_INT;
			'\n'->Print();
		}
		
		#~
		Prints error value
		@ignore-params
		~#
		function : Error(i : Int) ~ Nil {
			STD_ERR_INT;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(i : Int) ~ Nil {
			STD_ERR_INT;
			'\n'->Error();
		}

		function : Size(i : Int[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Copy(i : Int[]) ~ Int[] {
			s := i->Size();
			o := Int->New[s];
			Runtime->Copy(o, 0, i, 0, s);	
			return o;
		}

		#~
		Set all array elements to zero
		@param a array
		~#
		function : Clear(a : Int[]) ~ Nil {
			ZERO_INT_ARY;
		}

		function : Size(i : Int[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(i : Int[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns the binary string value
		@ignore-params
		@return binary string value
		~#
		
		function : native : ToBinaryString(v : Int) ~ String {
			out := "";
			do {
				out->Append(v and 1 = 0 ? '0' : '1');
				v := v >> 1;
			} 
			while(v <> 0);

			return out->Reverse();
		}
		
		#~
		Returns a hex string value
		@ignore-params
		@return hex string value
		~#
		function : native : ToHexString(v : Int) ~ String {
			buffer := Char->New[32];
			Number->IntToString(v->As(Int), 16, buffer);
			return String->New(buffer, false);
		}
		
		function : native : ToHexString(v : Int[]) ~ String {
			out := "]";

			if(v->Size() > 0) {
				each(i : v) {
					buffer := Char->New[32];
					n := v[i]->As(Int);
					Number->IntToString(n->Abs(), 16, buffer);
					out->Append(',');
				};
				out->Pop();
			};
			
			out->Append(']');
			return out;
		}
		
		function : native :  Sort(v : Int[]) ~ Int[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Int->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Int[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high - low) / 2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if(i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}
		
		#~
		Returns the string value
		@ignore-params
		@return string value
		~#
		function : ToString(v : Int) ~ String {
			buffer := Char->New[72];
			Number->IntToString(v->As(Int), 10, buffer);
			return String->New(buffer, false);
		}

		#~
		Returns a comma formatted string value
		@ignore-params
		@return string value
		~#
		function : native : ToCommaString(v : Int) ~ String {
			buffer := Char->New[256];
			Number->IntToString(v->As(Int), 10, buffer);
			str := String->New(buffer, false);

			count := 1;
			comma_str : String := "";
			for(i := str->Size() - 1; i >= 0; i -= 1;) {
				comma_str->Append(str->Get(i));
				if(count % 3 = 0 & count + 1 <= str->Size()) {
					comma_str->Append(',');
				};
				count += 1;
			};

			return comma_str->Reverse();
		}

		#~
		Prints values
		@param v values to print
		~#
		function : native : PrintLine(v : Int[]) ~ Nil {
			ToString(v)->PrintLine();
		}

		#~
		Prints values
		@param v values to print
		~#
		function : native : PrintLine(v : Int[,]) ~ Nil {
			ToString(v)->PrintLine();
		}
		
		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(v : Int[]) ~ String {
			out := "[";
			each(i : v) {
				buffer := Char->New[128];
				Number->IntToString(v[i]->As(Int), 10, buffer);
				out->Append(buffer);
				if(i + 1 < v->Size()) {
					out->Append(',');
				};
			};
			out->Append(']');
			return out;
		}
		
		#~
		Returns a string representation of the int array
		@param v int array
		@return string representation of the int array
		~#
		function : ToString(v : Int[,]) ~ String {
			buffer := "[";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					buffer->Append(v[r,c]);
					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				if(r + 1 < rows) {
					buffer->Append("]\n");
				}
				else {
					buffer->Append(']');
				};
			};
			buffer->Append(']');

			return buffer;
		}
	}
	
	#~
	Integer range used primarily for looping
	~#	
	class IntRange implements Range {
		@start : Int;
		@end : Int;
		@step : Int;
		
		#~
		Constructor.
		@param start starting index
		@param end ending index
		@param step step by value
		~#
		New(start : Int, end : Int, step : Int) {
			Parent();
			@start := start;
			@end := end;
			@step := step;
		}

		#~
		Constructor.
		@param start starting index
		@param end ending index
		~#
		New(start : Int, end : Int) {
			Parent();
			@start := start;
			@end := end;
			@step := 1;
		}

		#~
		Constructor.
		@param end ending index
		~#
		New(end : Int) {
			Parent();
			@start := 0;
			@end := end;
			@step := 1;
		}

		#~
		Gets the starting index
		@return starting index
		~#
		method : public : GetStart() ~ Int {
			return @start;
		}

		#~
		Gets the ending index
		@return ending index
		~#
		method : public : GetEnd() ~ Int {
			return @end;
		}

		#~
		Gets the step value
		@return step value
		~#
		method : public : GetStep() ~ Int {
			return @step;
		}

		#~
		Sets the starting index
		@param start starting index
		~#
		method : public : SetStart(start : Char) ~ Nil {
			@start := start;
		}

		#~
		Sets the ending index
		@param end ending index
		~#
		method : public : SetEnd(end : Char) ~ Nil {
			@end := end;
		}

		#~
		Sets the step value
		@param step step value
		~#
		method : public : SetStep(step : Char) ~ Nil {
			@step := step;
		}
	}

	#~
	Float class represents a double-precision floating-point value
	~#	
	class $Float from Number {
		#~
		Calculates the factorial value
		@param n number
		@return factorial value
		~#
		function : Factorial(n : Float) ~ Float {
			return Float->Gamma(n + 1.0);
		}

		#~
		Calculates the double factorial of the value
		@param n number
		@return double factorial of the value
		~#
		function : native : DoubleFactorial(n : Float) ~ Float {
			value := 1.0;

			for(i := n; i >= 0.0; i -= 2.0;) {
				if(i = 0.0 | i = 1.0) {
					return value;
				}
				else {
					value *= i;
				};
			};

			return value;
		}

		#~
		Returns a NaN value
		@return NaN value
		~#
		function : NaN() ~ Float {
			NAN_FLOAT;
		}

		#~
		Returns a positive infinity value
		@return positive infinity value
		~#
		function : Inf() ~ Float {
			INF_FLOAT;
		}

		#~
		Returns a negative infinity value
		@return negative infinity value
		~#
		function : NegInf() ~ Float {
			NEG_INF_FLOAT;
		}
		
		#~
		Value of Pi
		@return value of Pi
		~#
		function : Pi() ~ Float {
			return 3.1415926536;
		}

		function : Size(v : Float) ~ Float {
			return v;
		}

		#~
		Value of E
		@return value of E
		~#
		function : E() ~ Float {
			return 2.7182818285;
		}

		#~
		Returns a given value between an upper and lower bound
		@param min minimal value
		@param value value between the min and max
		@param max maximum value
		@return min if vaule is less than main, max if max is less than value, otherwise the value
		~#
		function : Clamp(min : Float, value : Float, max : Float) ~ Float {
			temp := value < min ? min : value;
			return temp > max ? max : temp;
		}

		#~
		Calculates the gamma value
		@ignore-param n
		@return gamma value
		~#
		function : Gamma(n : Float) ~ Float {
			GAMMA_FLOAT;
		}

		#~
		Converts the value into radians
		@ignore-params
		@return radian value
		~#
		function : ToRadians(v : Float) ~ Float {
			return v * 3.1415926536 / 180.0;
		}
		
		#~
		Converts the value into degrees
		@ignore-params
		@return degree value
		~#
		function : ToDegrees(v : Float) ~ Float {
			return v * 180.0 / 3.1415926536;
		}

		#~
		Returns the Int value
		@ignore-params
		@return value
		~#
		function : ToInt(v : Float) ~ Int {
			return v->As(Int);
		}

		#~
		Returns the Character value
		@ignore-params
		@return value
		~#
		function : ToByte(v : Float) ~ Byte {
			return v->As(Byte);
		}

		#~
		Returns the Int value
		@ignore-params
		@return value
		~#
		function : ToChar(v : Float) ~ Char {
			return v->As(Char);
		}

		#~
		Returns the smallest float value
		@param r value to compare
		@ignore-param l
		@return smallest float value
		~#
		function : native : Min(l : Float, r : Float) ~ Float {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest float value
		@param l value to compare
		@param r value to compare
		@return largest float value
		~#
		function : native : Max(l : Float, r : Float) ~ Float {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Compares two value
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : Compare(l : Float, r : Float) ~ Int {
			if(l < r) {
				return -1;
			}
			else if(l > r) {
				return 1;
			};

			return 0;
		}

		#~
		Returns the absolute value
		@ignore-params
		@return absolute value
		~#
		function : Abs(v : Float) ~ Float {
			if(v < 0.0) {
				v *= -1.0;
			};

			return v;
		}

		#~
		Checks is a number is negative
		@ignore-params
		@return true if negative, false otherwise
		~#
		function : IsNeg(v : Float) ~ Bool {
			if(v < 0.0) {
				return true;
			};

			return false;
		}
		
		#~
		Calculates the floor value
		@ignore-params
		@return floor value
		~#
		function : Floor(f : Float) ~ Float {
			FLOR_FLOAT;
		}
		
		#~
		Calculates the ceiling value
		@ignore-params
		@return ceiling value
		~#
		function : Ceil(f : Float) ~ Float {
			CEIL_FLOAT;
		}

		#~
		Truncates the value
		@ignore-params
		@return truncated value
		~#
		function : Trunc(f : Float) ~ Float {
			TRUNC_FLOAT;
		}
		
		#~
		Calculates the sine value
		@ignore-params
		@return sine value
		~#
		function : Sin(f : Float) ~ Float {
			SIN_FLOAT;
		}
		
		#~
		Calculates the cosine value
		@ignore-params
		@return cosine value
		~#
		function : Cos(f : Float) ~ Float {
			COS_FLOAT;
		}
		
		#~
		Calculates the tangent value
		@ignore-params
		@return tangent value
		~#
		function : Tan(f : Float) ~ Float {
			TAN_FLOAT;
		}

		#~
		Calculates the arc-sine value
		@ignore-params
		@return arc-sine value
		~#
		function : ArcSin(f : Float) ~ Float {
			ASIN_FLOAT;
		}

		#~
		Calculates the arc-hyperbolic cosine
		@ignore-params
		@return hyperbolic arc-cosine value
		~#
		function : ArcCosh(f : Float) ~ Float {
			ACOSH_FLOAT;
		}

		#~
		Calculates the arc-hyperbolic sine
		@ignore-params
		@return hyperbolic arc-sine value
		~#
		function : ArcSinh(f : Float) ~ Float {
			ASINH_FLOAT;
		}

		#~
		Calculates the arc-hyperbolic tangent
		@ignore-params
		@return hyperbolic arc-tangent value
		~#
		function : ArcTanh(f : Float) ~ Float {
			ATANH_FLOAT;
		}

		#~
		Calculates the hyperbolic cosine
		@ignore-params
		@return hyperbolic cosine value
		~#
		function : Cosh(f : Float) ~ Float {
			COSH_FLOAT;
		}

		#~
		Calculates the hyperbolic sine
		@ignore-params
		@return hyperbolic sine value
		~#
		function : Sinh(f : Float) ~ Float {
			SINH_FLOAT;
		}

		#~
		Calculates the hyperbolic tangent
		@ignore-params
		@return hyperbolic tangent value
		~#
		function : Tanh(f : Float) ~ Float {
			TANH_FLOAT;
		}
			
		#~
		Calculates the cosine value
		@ignore-params
		@return cosine value
		~#
		function : ArcCos(f : Float) ~ Float {
			ACOS_FLOAT;
		}
		
		#~
		Calculates the arc-tangent value
		@ignore-params
		@return arc-tangent value
		~#
		function : ArcTan(f : Float) ~ Float {
			ATAN_FLOAT;
		}

		#~
		Calculates the binary logarithm
		@ignore-params
		@return binary logarithm
		~#
		function : Log2(f : Float) ~ Float {
			LOG2_FLOAT;
		}

		#~
		Calculates the cubic root
		@ignore-params
		@return cubic root
		~#
		function : Cbrt(f : Float) ~ Float {
			CBRT_FLOAT;
		}
		
		#~
		Calculates arc tangent of y/x
		@param y value
		@param x value
		@return arc-tangent value
		~#
		function : ArcTan2(y : Float, x : Float) ~ Float {
			ATAN2_FLOAT;
		}

		#~
		Calculates the decimal mod
		@param a value
		@param b value
		@return decimial mod
		~#
		function : Mod(a : Float, b : Float) ~ Float {
			MOD_FLOAT;
		}
		
		#~
		Calculates the log value
		@ignore-params
		@return log value
		~#
		function : Log(f : Float) ~ Float {
			LOG_FLOAT;
		}
		
		#~
		Rounds the value
		@ignore-params
		@return rounded value
		~#
		function : Round(f : Float) ~ Float {
			ROUND_FLOAT;
		}

		#~
		Calculates exponential value
		@ignore-params
		@return exponential value
		~#
		function : Exp(f : Float) ~ Float {
			EXP_FLOAT;
		}
		
		#~
		Calculates the common (base-10) logarithm value
		@ignore-params
		@return common (base-10) logarithm value
		~#
		function : Log10(f : Float) ~ Float {
			LOG10_FLOAT;
		}

		#~
		Returns the sign of a number
		@ignore-params
		@return sign of a number
		~#
		function : Sign(a : Float) ~ Float {
			if(a < 0.0) {
				return -1.0;
			}
			else if(a > 0.0) {
				return 1.0;
			};

			return 0.0;
		}
		
		#~
		Calculates the square root value
		@ignore-params
		@return square root value
		~#
		function : Sqrt(f : Float) ~ Float {
			SQRT_FLOAT;
		}
		
		#~
		Returns a pseudo random value between 0.0 and 1.0, inclusive
		@ignore-params
		@return pseudo random value
		~#
		function : Random() ~ Float {
			RAND_FLOAT;
		}

		#~
		Returns a pseudo random value between 0.0 and max, inclusive
		@param max maximum value
		@return pseudo random value
		~#
		function : Random(max : Float) ~ Float {
			return Random() * max;	
		}

		#~
		Returns a pseudo random value between 0.0 and 1.0, inclusive
		@param range_start minimum value
		@param range_end maximum value
		@return pseudo random value
		~#
		function : Random(range_start : Float, range_end : Float) ~ Float {
			if(range_start >= range_end) {
				return 0.0;
			};

			return Float->Random(range_end - range_start) + range_start;	
		}
		
		#~
		Calculates the power value
		@param b power base
		@param r power to raise
		@return pseudo power value
		~#
		function : Pow(b : Float, r : Int) ~ Float {
			return Pow(b, r->ToFloat());
		}

		#~
		Calculates the power value
		@param b power base
		@param r power to raise
		@return pseudo power value
		~#
		function : Pow(b : Float, r : Float) ~ Float {
			POW_FLOAT;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(f : Float) ~ Nil {
			STD_OUT_FLOAT;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(f : Float) ~ Nil {
			STD_OUT_FLOAT;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(f : Float) ~ Nil {
			STD_ERR_FLOAT;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(f : Float) ~ Nil {
			STD_ERR_FLOAT;
			'\n'->Error();
		}
		
		function : Size(f : Float[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Copy(f : Float[]) ~ Float[] {
			s := f->Size();
			o := Float->New[s];
			Runtime->Copy(o, 0, f, 0, s);	
			return o;
		}

		#~
		Set all array elements to zero
		@param f array
		~#
		function : Clear(f : Float[]) ~ Nil {
			ZERO_FLOAT_ARY;
		}

		function : Size(f : Float[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(f : Float[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Prints values
		@param v values to print
		~#
		function : native : PrintLine(v : Float[]) ~ Nil {
			ToString(v)->PrintLine();
		}

		#~
		Prints values
		@param v values to print
		~#
		function : native : PrintLine(v : Float[,]) ~ Nil {
			ToString(v)->PrintLine();
		}

		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(f : Float) ~ String {
			buffer := Char->New[64];
			Number->FloatToString(f, buffer);
			return String->New(buffer, false);
		}

		function : native : ToString(v : Float[]) ~ String {
			out := "[";
			each(i : v) {
				buffer := Char->New[64];
				Number->FloatToString(v[i], buffer);
				out->Append(buffer);
				if(i + 1 < v->Size()) {
				  out->Append(',');
				};
			};
			out->Append(']');
			return out;
		}
		
		#~
		Returns a string representation of the float array
		@param v float array
		@return string representation of the float array
		~#
		function : ToString(v : Float[,]) ~ String {
			buffer := "[";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					buffer->Append(v[r,c]);
					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				if(r + 1 < rows) {
					buffer->Append("]\n");
				}
				else {
					buffer->Append(']');
				};
			};
			buffer->Append(']');

			return buffer;
		}
		
		function : native :  Sort(v : Float[]) ~ Float[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Float->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Float[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high - low) / 2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if(i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}
	}

	#~
	Float range used primarily for looping
	~#	
	class FloatRange implements Range {
		@start : Float;
		@end : Float;
		@step : Float;
		
		#~
		Constructor.
		@param start starting index
		@param end ending index
		@param step step by value
		~#
		New(start : Float, end : Float, step : Float) {
			Parent();
			@start := start;
			@end := end;
			@step := step;
		}

		#~
		Constructor.
		@param start starting index
		@param end ending index
		~#
		New(start : Float, end : Float) {
			Parent();
			@start := start;
			@end := end;
			@step := 1.;
		}

		#~
		Constructor.
		@param end ending index
		~#
		New(end : Float) {
			Parent();
			@start := 0.;
			@end := end;
			@step := 1.;
		}

		#~
		Gets the starting index
		@return starting index
		~#
		method : public : GetStart() ~ Float {
			return @start;
		}

		#~
		Gets the ending index
		@return ending index
		~#
		method : public : GetEnd() ~ Float {
			return @end;
		}

		#~
		Gets the step value
		@return step value
		~#
		method : public : GetStep() ~ Float {
			return @step;
		}

		#~
		Sets the starting index
		@param start starting index
		~#
		method : public : SetStart(start : Char) ~ Nil {
			@start := start;
		}

		#~
		Sets the ending index
		@param end ending index
		~#
		method : public : SetEnd(end : Char) ~ Nil {
			@end := end;
		}

		#~
		Sets the step value
		@param step step value
		~#
		method : public : SetStep(step : Char) ~ Nil {
			@step := step;
		}
	}

	# Array class support
	class $BaseArray {
		function : native : PrintLine(v : System.Base[]) ~ Nil {
			ToString(v)->PrintLine();
		}

		function : native : PrintLine(v : System.Base[,]) ~ Nil {
			ToString(v)->PrintLine();
		}

		function : public : ToString(array : System.Base[]) ~ String {
			buffer := "[";
			
			each(i : array) {
				# get string value if instance implements 'Stringify'
				value := array[i];

				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
				};

				# add comma
				if(i + 1 < array->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}

		function : ToString(v : System.Base[,]) ~ String {
			buffer := "";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					value := v[r,c];

					if(value->TypeOf(Stringify)) {
						buffer->Append(value->As(System.Stringify)->ToString());
					}
					# use instance ID instead
					else {
						buffer->Append(value->GetInstanceID()->ToHexString());
					};

					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				if(r + 1 < rows) {
					buffer->Append("]\n");
				}
				else {
					buffer->Append(']');
				};
			};

			return buffer;
		}

		function : Size(array : System.Base[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Copy(v : System.Base[]) ~ System.Base[] {
			s := v->Size();
			o := System.Base->New[s];
			Runtime->Copy(o, 0, v, 0, s);	
			return o;
		}

		function : Size(array : System.Base[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(array : System.Base[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}
	}

	#~
	Interface for primitive types
	~#
	interface Primitive {
	}

	#~
	Holds a boolean value
	~#
	class BoolRef implements System.Compare, System.Clone, System.Stringify, Primitive {
		@value : Bool;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := false;
		}

		#~
		Copy constructor
		@param value boolean value
		~#
		New(value : Bool) {
			Parent();
			@value := value;
		}

		#~
		Creates an array of references from primitives
		@param input array of primitives
		@return an array of references
		~#
		function : FromArray(input : Bool[]) ~ BoolRef[] {
			out := BoolRef->New[input->Size()];

			each(i : input) {
				out[i] := BoolRef->New(input[i]);
			};
			
			return out;
		}

		#~
		Creates an array of primitives from references
		@param input array of references
		@return an array of primitives
		~#
		function : ToArray(input : BoolRef[]) ~ Bool[] {
			out := Bool->New[input->Size()];

			each(i : input) {
				out[i] := input[i]->Get();
			};
			
			return out;
		}

		#~
		Get boolean value
		@return boolean value
		~#
		method : public : Get() ~ Bool {
			return @value;
		}
		
		#~
		Set boolean value
		@param value boolean value		
		~#
		method : public : Set(value : Bool) ~ Nil {
			@value := value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			r := 1;

			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				r := -1;
			};
			
			right : BoolRef := rhs->As(BoolRef);
			if(@value = right->Get()) {
				r := 0;
			};
			
			return r;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.BoolRef {
			return BoolRef->New(@value);
		}

		#~
		Returns a unique hash ID for a boolean
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value ? 1 : 0;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

		method : public : ToString() ~ String {
			return @value->ToString();
		}
	}
	
	#~
	Holds an byte value
	~#
	class ByteRef implements System.Compare, System.Clone, System.Stringify, Primitive {
		@value : Byte;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value byte value
		~#
		New(value : Byte) {
			Parent();
			@value := value;
		}

		#~
		Creates an array of references from primitives
		@param input array of primitives
		@return an array of references
		~#
		function : FromArray(input : Byte[]) ~ ByteRef[] {
			out := ByteRef->New[input->Size()];

			each(i : input) {
				out[i] := ByteRef->New(input[i]);
			};
			
			return out;
		}

		#~
		Creates an array of primitives from references
		@param input array of references
		@return an array of primitives
		~#
		function : ToArray(input : ByteRef[]) ~ Byte[] {
			out := Byte->New[input->Size()];

			each(i : input) {
				out[i] := input[i]->Get();
			};
			
			return out;
		}

		#~
		Get byte value
		@return byte value
		~#
		method : public : Get() ~ Byte {
			return @value;
		}
		
		#~
		Set byte value
		@param value byte value		
		~#
		method : public : Set(value : Byte) ~ Nil {
			@value := value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			r := 1;

			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				r := -1;
			};
			
			right : ByteRef := rhs->As(ByteRef);
			if(@value = right->Get()) {
				r := 0;
			}
			else if(@value < right->Get()) {
				r := -1;
			};
			
			return r;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.ByteRef {
			return ByteRef->New(@value);
		}

		#~
		Returns a unique hash ID for a byte
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

		method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds an character value
	~#
	class CharRef implements System.Compare, System.Clone, System.Stringify, Primitive {
		@value : Char;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value character value
		~#
		New(value : Char) {
			Parent();
			@value := value;
		}

		#~
		Creates an array of references from primitives
		@param input array of primitives
		@return an array of references
		~#
		function : FromArray(input : Char[]) ~ CharRef[] {
			out := CharRef->New[input->Size()];

			each(i : input) {
				out[i] := CharRef->New(input[i]);
			};
			
			return out;
		}

		#~
		Creates an array of primitives from references
		@param input array of references
		@return an array of primitives
		~#
		function : ToArray(input : CharRef[]) ~ Char[] {
			out := Char->New[input->Size()];

			each(i : input) {
				out[i] := input[i]->Get();
			};
			
			return out;
		}

		#~
		Get character value
		@return character value
		~#
		method : public : Get() ~ Char {
			return @value;
		}
		
		#~
		Set character value
		@param value character value		
		~#
		method : public : Set(value : Char) ~ Nil {
			@value := value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			r := 1;

			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				r := -1;
			};
			
			right : CharRef := rhs->As(CharRef);
			if(@value = right->Get()) {
				r := 0;
			}
			else if(@value < right->Get()) {
				r := -1;
			};
			
			return r;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.CharRef {
			return CharRef->New(@value);
		}

		#~
		Returns a unique hash ID for a character
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

		method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds an integer value
	~#
	class IntRef implements System.Compare, System.Clone, System.Stringify, Primitive {
		@value : Int;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value integer value
		~#
		New(value : Int) {
			Parent();
			@value := value;
		}

		#~
		Creates an array of references from primitives
		@param input array of primitives
		@return an array of references
		~#
		function : FromArray(input : Int[]) ~ IntRef[] {
			out := IntRef->New[input->Size()];

			each(i : input) {
				out[i] := IntRef->New(input[i]);
			};
			
			return out;
		}

		#~
		Creates an array of primitives from references
		@param input array of references
		@return an array of primitives
		~#
		function : ToArray(input : IntRef[]) ~ Int[] {
			out := Int->New[input->Size()];

			each(i : input) {
				out[i] := input[i]->Get();
			};
			
			return out;
		}

		#~
		Get integer value
		@return integer value
		~#
		method : public : Get() ~ Int {
			return @value;
		}
		
		#~
		Set integer value
		@param value integer value		
		~#
		method : public : Set(value : Int) ~ Nil {
			@value := value;
		}

		#~
		Increments value by 1
		~#
		method : public : Inc() ~ Nil {
			@value += 1;
		}

		#~
		Adds to value
		@param value value to add to	
		~#
		method : public : Add(value : Int) ~ Nil {
			@value += value;
		}

		#~
		Decrements value by 1
		~#
		method : public : Dec() ~ Nil {
			@value -= 1;
		}

		#~
		Subtract from value
		@param value value to subtract by	
		~#
		method : public : Sub(value : Int) ~ Nil {
			@value -= value;
		}

		#~
		Multiply to value
		@param value value to multiply by	
		~#
		method : public : Mul(value : Int) ~ Nil {
			@value *= value;
		}

		#~
		Divide by value
		@param value value to divide by		
		~#
		method : public : Div(value : Int) ~ Nil {
			@value /= value;
		}
		
		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			r := 1;

			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				r := -1;
			};
			
			right : IntRef := rhs->As(IntRef);
			if(@value = right->Get()) {
				r := 0;
			}
			else if(@value < right->Get()) {
				r := -1;
			};
			
			return r;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.IntRef {
			return IntRef->New(@value);
		}

		#~
		Returns a unique hash ID for a integer
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

		method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds a float
	~#
	class FloatRef implements System.Compare, System.Clone, System.Stringify, Primitive {
		@value : Float;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0.0;
		}

		#~
		Copy constructor 
		@param value float value
		~#
		New(value : Float) {
			Parent();
			@value := value;
		}

		#~
		Creates an array of references from primitives
		@param input array of primitives
		@return an array of references
		~#
		function : FromArray(input : Float[]) ~ FloatRef[] {
			out := FloatRef->New[input->Size()];

			each(i : input) {
				out[i] := FloatRef->New(input[i]);
			};
			
			return out;
		}

		#~
		Creates an array of primitives from references
		@param input array of references
		@return an array of primitives
		~#
		function : ToArray(input : FloatRef[]) ~ Float[] {
			out := Float->New[input->Size()];

			each(i : input) {
				out[i] := input[i]->Get();
			};
			
			return out;
		}

		#~
		Get value
		@return value
		~#
		method : public : Get() ~ Float {
			return @value;
		}
		
		#~
		Set value
		@param value float value
		~#
		method : public : Set(value : Float) ~ Nil {
			@value := value;
		}
		
		#~
		Adds to value
		@param value value to add to	
		~#
		method : public : Add(value : Float) ~ Nil {
			@value += value;
		}

		#~
		Subtract from value
		@param value value to subtract by	
		~#
		method : public : Sub(value : Float) ~ Nil {
			@value -= value;
		}

		#~
		Multiply to value
		@param value value to multiply by	
		~#
		method : public : Mul(value : Float) ~ Nil {
			@value *= value;
		}

		#~
		Divide by value
		@param value value to divide by		
		~#
		method : public : Div(value : Float) ~ Nil {
			@value /= value;
		}
		
		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			r := 1;

			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				r := -1;
			};
			
			right : FloatRef := rhs->As(FloatRef);
			if(@value = right->Get()) {
				r := 0;
			}
			else if(@value < right->Get()) {
				r := -1;
			};
			
			return r;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.FloatRef {
			return FloatRef->New(@value);
		}
		
		#~
		Returns a unique hash ID for a float
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value * 10000.0;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

		method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds a byte array
	~#
	class ByteArrayRef implements Primitive, Stringify {
		@values : Byte[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values byte array 
		~#
		New(values : Byte[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Byte[] {
			return @values;
		}
		
		#~
		Sets values
		@param values byte array 
		~#
		method : public : Set(values : Byte[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}

	#~
	Holds a character array
	~#
	class CharArrayRef implements Primitive, Stringify {
		@values : Char[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values character array 
		~#
		New(values : Char[]) {
			Parent();
			@values := values;
		}

		#~
		Get value
		@return value
		~#
		method : public : Get() ~ Char[] {
			return @values;
		}
		
		#~
		Set value
		@param values character array 
		~#
		method : public : Set(values : Char[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}
	
	#~
	Holds an integer array
	~#
	class IntArrayRef implements Primitive, Stringify {
		@values : Int[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values integer array 
		~#
		New(values : Int[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Int[] {
			return @values;
		}
		
		#~
		Set values
		@param values integer array 
		~#
		method : public : Set(values : Int[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}

	#~
	Holds an boolean array
	~#
	class BoolArrayRef implements Primitive, Stringify {
		@values : Bool[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values integer array 
		~#
		New(values : Bool[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Bool[] {
			return @values;
		}
		
		#~
		Set values
		@param values integer array 
		~#
		method : public : Set(values : Bool[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}

	#~
	Holds a float array
	~#
	class FloatArrayRef implements Primitive, Stringify {
		@values : Float[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values float array 
		~#
		New(values : Float[]) {
			Parent();
			@values := values;
		}

		#~
		Gets values
		@return value
		~#
		method : public : Get() ~ Float[] {
			return @values;
		}
		
		#~
		Sets values
		@param values float array 
		~#
		method : public : Set(values : Float[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}

	#~
	Holds an base array
	~#
	class BaseArrayRef implements Primitive, Stringify {
		@values : Base[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values Base array 
		~#
		New(values : Base[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Base[] {
			return @values;
		}
		
		#~
		Set values
		@param values Base array 
		~#
		method : public : Set(values : Base[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}

	#~
	Holds an array of 'Compare' values
	~#
	class CompareArrayRef implements Primitive, Stringify {
		@values : Compare[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor 
		@param values Compare array 
		~#
		New(values : Compare[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Compare[] {
			return @values;
		}
		
		#~
		Set values
		@param values Compare array 
		~#
		method : public : Set(values : Compare[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}
	
	#~
	Holds an array of strings
	~#
	class StringArrayRef implements Primitive {
		@values : String[];

		#~
		Default constructor 
		~#
		New() {
			Parent();
		}

		#~
		Copy constructor
		@param values String array
		~#
		New(values : String[]) {
		Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ String[] {
			return @values;
		}

		#~
		Set values
		@param values String array
		~#
		method : public : Set(values : String[]) ~ Nil {
			@values := values;
		}

		method : public : ToString() ~ System.String {
			return @values->ToString();
		}
	}
	
	#~
	Holds a function of in/out type R
	~#
	class FuncRef <R> {
		@func : () ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : () ~ R) {
			Parent();
			@func := func;
		}

		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ () ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : () ~ R) ~ Nil {
			@func := func;
		}
	}
	
	#~
	Holds a function of in type X and out type R
	~#
	class Func2Ref <X, R> {
		@func : (X) ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : (X) ~ R) {
			Parent();
			@func := func;
		}

		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ (X) ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : (X) ~ R) ~ Nil {
			@func := func;
		}
		
		#~
		Apply function
		@param arg argument
		@return applied result
		~#
		function : Apply(arg : X) ~ R {
			return @func(arg);
		}
	}

	#~
	Holds a function of in types X, Y and out type R
	~#
	class Func3Ref <X, Y, R> {
		@func : (X, Y) ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : (X, Y) ~ R) {
			Parent();
			@func := func;
		}
		
		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ (X, Y) ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : (X, Y) ~ R) ~ Nil {
			@func := func;
		}
	}

	#~
	Holds a function of in types X, Y, Z and out type R
	~#
	class Func4Ref <X, Y, Z, R> {
		@func : (X, Y, Z) ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : (X, Y, Z) ~ R) {
			Parent();
			@func := func;
		}
		
		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ (X, Y, Z) ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : (X, Y, Z) ~ R) ~ Nil {
			@func := func;
		}
	}

	#~
	Base class for all objects
	~#	
	class Base {
		#~
		Default constructor
		~#	
		New() {
		}

		#~
		Returns the class associated with this instance
		@return associated with this instance
		~#	
		method : public : GetClass() ~ Introspection.Class {
			cls : Class;
			LOAD_CLS_BY_INST;
			return cls;
		}
		
		#~
		Returns the unique class ID
		@return unique class ID
		~#
		method : public : GetClassID() ~ Int {
			LOAD_CLS_INST_ID;
		}

		#~
		Returns the unique instance ID
		@return unique instance ID
		~#
		method : public : GetInstanceID() ~ Int {
			LOAD_INST_UID;
		}
	}
	
	#~
	Used to represent the string value of an object instance
	~#	
	interface Stringify {
		#~
		Converts an instance to a string
		@return string representation of the instance
		~#
		method : virtual : public : ToString() ~ System.String;
	}
	
	#~
	Used to compare two abstract values
	~#	
	interface Compare {
		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : virtual : public : Compare(rhs : System.Compare) ~ Int;

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : virtual : public : HashID() ~ Int;
	}

	#~
	Used to clone objects
	~#
	interface Clone {
		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : virtual : public : Clone() ~ System.Clone;
	}

	#~
	Provides rudimentary compare functionality 
	~#
	class BasicCompare implements System.Compare {
		#~
		Default constructor
		~#
		New() {
			Parent();
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			r := -1;

			if(GetInstanceID() = rhs->GetInstanceID()) {
				r := 0;
			}
			else if(GetInstanceID() < rhs->GetInstanceID()) {
				r := 1;
			};

			return r;
		}
		
		#~
		Returns the class default hash ID
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return GetInstanceID();
		}
	}

	#~
	Byte array buffer
	~#
	class ByteBuffer implements System.Compare, System.Clone {
		@buffer : Byte[];
		@max : Int;
		@pos : Int;

		#~
		Copy constructor
		@param buffer buffer to set
		~#
		New(buffer : Byte[]) {
			Parent();
			
			@buffer := buffer;
			@max := @pos := buffer->Size();
		}

		#~
		Default constructor
		~#
		New() {
			Parent();

			@max := 512;
			@buffer := Byte->New[@max];
			@pos := 0;
		}

		#~
		Appends a byte array
		@param array array to be copied
		~#
		method : public : native : Append(array : Byte[]) ~ Nil {
			max := @pos + array->Size();
			if(max >= @max) {
				@max += max << 1;
				temp := Byte->New[@max];
				Runtime->Copy(temp, 0, @buffer, 0, @buffer->Size());
				@buffer := temp;
			};
			
			end := array->Size();
			for(i := 0; i < end; i += 1;) {
				@buffer[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a byte array
		@param length number of characters to copy
		@param array array to be copied
		~#
		method : public : native : Append(length : Int, array : Byte[]) ~ Nil {
			max := @pos + length;
			if(max >= @max) {
				@max += max << 1;
				temp := Byte->New[@max];
				Runtime->Copy(temp, 0, @buffer, 0, @buffer->Size());
				@buffer := temp;
			};
			
			for(i := 0; i < length; i += 1;) {
				@buffer[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a byte
		@param c byte to append
		~#
		method : public : Append(c : Byte) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max += @pos << 1;
				temp := Byte->New[@max];
				# copy elements
				Runtime->Copy(temp, 0, @buffer, 0, @buffer->Size());
				@buffer := temp;
			};

			@buffer[@pos] := c;
			@pos += 1;
		}

		#~
		Return the size of the string
		@return size of the string
		~#
		method : public : Size() ~ Int {
			return @pos;			
		}

		#~
		Returns the byte at the given index
		@param index index offset
		@return byte at index
		~#
		method : public : native : Get(index : Int) ~ Char {
			if(index > -1 & index < @pos) {
				return @buffer[index];
			};

			return 0;
		}

		#~
		Returns a unique hash ID for a given byte sequence
		@return hash ID
		~#
		method : public : native : HashID() ~ Int {
			# djb2 hash			
			hash := 5381;
			
			each(i : @pos) {
				hash := ((hash << 5) + hash) + @buffer[i];				
			};
				
			return hash;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
						
			# check each character
			right_string := rhs->As(String);
			for(i := 0; i < @pos; i += 1;) {
				left := @buffer[i];
				right := right_string->Get(i);
				if(left > right) {
					return 1;
				}
				else if(left < right) {
					return -1;
				};
			};
			
			# check length
			if(@pos > right_string->Size()) {
				return 1;
			};
			
			if(@pos < right_string->Size()) {
				return -1;
			};
			
			# equal
			return 0;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.ByteBuffer {
		 	return ByteBuffer->New(ToByteArray());
		}

		#~
		Gets the current buffer's storage capacity. That is the 
		number of bytes the buffer will hold before it is 
		resized for growth.
		@return buffer capacity
		~#
		method : public : Capacity() ~ Int {
			return @max;
		}

		#~
		Gets the raw reference to the underlying byte array
		@return raw byte array reference
		~#
		method : public : Raw() ~ Byte[] {
			return @buffer;
		}

		#~
		Returns a trimmed byte array
		@return byte array
		~#
		method : public : ToByteArray() ~ Byte[] {
			out := Byte->New[@pos];

			each(i : @pos) {
				out[i] := @buffer[i];
			};

			return out;
		}
		
		#~
		Returns a string representation of the byte buffer
		@return string representation of the byte buffer
		~#
		method : public : ToString() ~ String {
			return @buffer->ToHexString()->ToString();
		}
	}

	#~
	Resizeable Unicode character string

	```
# build and print string
cities_str := "\t\tNapa,";
cities_str += "Fremont,";
cities_str += "Alameda,";
cities_str += "Berkeley,";
cities_str += "Fremont,";
cities_str += "San Carlos,";
cities_str += "Milpitas,  ";
cities_str->PrintLine();

# show the string size
cities_str->Size()->PrintLine();

# trim string
cities_str := cities_str->Trim();
cities_str->Size()->PrintLine();

# replace city
cities_str := cities_str->Replace("San Carlos", "Oakland");
cities_str->PrintLine();

# create a substring
start := cities_str->Find("Berkeley");
if(<>start->IsNeg()) {
   end := cities_str->Find(start, ',');
   if(<>end->IsNeg()) {
      city := cities_str->SubString(start, end - start);
      "They city found was {$city}"->PrintLine();
   }
};

# remove ending comma
cities_str->Pop();

# split string and print values
cities := cities_str->Split(',');
cities->Size()->PrintLine();

# iterate over cities
each(city := cities) {
   city->PrintLine();
};

# iterate over cities with an index
each(i : cities) {
   city := cities[i];
   "{$i}: |{$city}|"->PrintLine();
};
	```
	~#	
	class String implements System.Compare, System.Clone, System.Stringify {
		@string : Char[];
		@max : Int;
		@pos : Int;

		#~
		Default constructor
		~#
		New() {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
		}

		#~
		Copy constructor
		@param string string to be copied
		~#
		New(string : String) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;

			if(string <> Nil) {
				Append(string->ToCharArray());
			};
		}
		
		#~
		Copy constructor
		@param array array to be copied
		~#		
		New(array : Char[]) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}

		#~
		Copy constructor
		@param array array to be copied
		@param copy if false, use array for value for string otherwise copy values
		~#		
		New(array : Char[], copy : Bool) {
			Parent();

			if(copy) {
				@max := 8;
				@string := Char->New[@max];
				@pos := 0;
			}
			else {
				@max := array->Size();
				@string := array;
				@pos := 0;
			};

			Append(array);
		}
		
		#~
		Copy constructor
		@param array array to be copied
		@param offset offset array index offset
		@param length number of characters to copy
		~#
		New(array : Char[], offset : Int, length : Int) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;

			Append(array, offset, length);
		}
		
		#~
		Copy constructor
		@param bytes array to be copied
		~#
		New(bytes : Byte[]) {
			Parent();
			
			@max := 8;
			@string := Char->New[@max];
			@pos := 0;

			Append(bytes->ToUnicode());
		}

		#~
		Copy constructor
		@param bytes array to be copied
		@param offset offset array index offset
		@param length number of characters to copy
		~#
		New(bytes : Byte[], offset : Int, length : Int) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;

			Append(bytes->ToUnicode(), offset, length);
		}

		#~
		Returns string of self
		@return string of self
		~#
		method : public : ToString() ~ String {
			return @self;
		}

		#~
		Prints values
		@param v values to print
		~#
		function : PrintLine(v : String[]) ~ Nil {
			ToString(v)->PrintLine();
		}

		#~
		Formats an array of string
		@param v string array
		~#
		function : native : ToString(v : String[]) ~ String {
			buffer := "[";

			each(i : v) {
				str := v[i];
				buffer->Append('"');
				buffer->Append(str);
				buffer->Append('"');

				if(i + 1 < v->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Set integer string format.
		@param format integer format
		~#
		function : SetIntFormat(format : Number->Format) ~ Nil {
			select(format) {
				label Number->Format->DEC
				label Number->Format->DEFAULT {
					Runtime->SetProperty("int:string:format", "dec");
				}

				label Number->Format->OCT {
					Runtime->SetProperty("int:string:format", "oct");
				}

				label Number->Format->HEX {
					Runtime->SetProperty("int:string:format", "hex");
				}
			};
		}

		#~
		Set floating point string format.
		@param format float format
		~#
		function : SetFloatFormat(format : Number->Format) ~ Nil {
			select(format) {
				label Number->Format->FIXED
				label Number->Format->DEFAULT {
					Runtime->SetProperty("float:string:format", "fixed");
				}

				label Number->Format->SCIENTIFIC {
					Runtime->SetProperty("float:string:format", "scientific");
				}

				label Number->Format->HEX {
					Runtime->SetProperty("float:string:format", "hex");
				}
			};
		}
		
		#~
		Set floating point string precision.
		@param precision decimal precision
		~#
		function : SetFloatPrecision(precision : Int) ~ Nil {
			if(precision > -1) {
				Runtime->SetProperty("float:string:precision", precision->ToString());
			};
		}

		#~
		Returns a character array representation of the String
		@return character array
		~#
		method : public : ToCharArray() ~ Char[] {
			array := Char->New[@pos];
			Runtime->Copy(array, 0, @string, 0, @pos);
			return array;
		}
		
		#~
		Returns a byte array representation of the String
		@return byte array
		~#
		method : public : native : ToByteArray() ~ Byte[] {
			bytes := @string->ToBytes(); #  Unicode conversion 
			out := Byte->New[bytes->Size()];

			each(i : bytes) {
				out[i] := bytes[i];
			};

			return out;
		}
		
		#~
		Appends a boolean value
		@param flag boolean value
		~#
		method : public : Append(flag : Bool) ~ Nil {
			if(flag) {
				Append("true"->ToCharArray());
			}
			else {
				Append("false"->ToCharArray());
			};
		}

		#~
		Appends a integer value
		@param i integer value
		~#
		method : public : Append(i : Int) ~ Nil {
			Append(i->ToString()->ToCharArray());
		}

		#~
		Appends a float value
		@param f float value
		~#
		method : public : Append(f : Float) ~ Nil {
			Append(f->ToString()->ToCharArray());
		}

		#~
		Appends a string
		@param str string object
		~#
		method : public : Append(str : String) ~ Nil {
			Append(str->ToCharArray());
		}
		
		#~
		Appends a character array
		@param array character array
		~#
		method : public : Append(array : Char[]) ~ Nil {
			max := @pos + array->Size();
			if(max >= @max) {
				@max += max << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, @string->Size());
				@string := temp;
			};
			
			end := array->Size();	
			for(i := 0; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a portion of character array
		@param array array to be copied
		@param offset offset array index offset
		@param length number of characters to copy
		~#
		method : public : native : Append(array : Char[], offset : Int, length : Int) ~ Nil {
			if(offset < 0) {
				return;
			};
			
			max := @pos + length;
			if(max >= @max) {
				@max += max << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, @string->Size());
				@string := temp;
			};

			end := offset + length;
			for(i := offset; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}
		
		#~
		Appends a character array
		@param array array to be copied
		~#
		method : public : native : Append(array : Byte[]) ~ Nil {
			max := @pos + array->Size();
			if(max >= @max) {
				@max += max << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, @string->Size());
				@string := temp;
			};
			
			end := array->Size();
			for(i := 0; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a portion of byte array
		@param array array to be copied
		@param offset offset array index offset
		@param length number of bytes to copy
		~#
		method : public : native : Append(array : Byte[], offset : Int, length : Int) ~ Nil {
			if(offset < 0) {
				return;
			};

			max := @pos + length;
			if(max >= @max) {
				@max += max << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, @string->Size());
				@string := temp;
			};

			end := offset + length;
			for(i := offset; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a character
		@param c character to append
		~#
		method : public : Append(c : Char) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max += @pos << 1;
				temp := Char->New[@max];
				# copy elements
				Runtime->Copy(temp, 0, @string, 0, @string->Size());
				@string := temp;
			};

			@string[@pos] := c;
			@pos += 1;
		}
		
		#~
		Appends a byte
		@param c byte to append
		~#
		method : public : Append(c : Byte) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max += @pos << 1;
				temp := Char->New[@max];
				# copy elements
				Runtime->Copy(temp, 0, @string, 0, @string->Size());
				@string := temp;
			};

			@string[@pos] := c;
			@pos += 1;
		}
		
		#~
		Searches for the first occurrence of a character
		@param char character to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : Find(char : Char) ~ Int {
			return Find(0, char);
		}

		#~
		Searches for the first occurrence of a character
		@param char character to search for
		@return true of found, false otherwise
		~#
		method : public : Has(char : Char) ~ Bool {
			return Find(0, char) > -1;
		}

		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param char character to search for
		@return true of found, false otherwise
		~#
		method : public : Has(offset : Int, char : Char) ~ Bool {
			return Find(offset, char) > -1;
		}


		#~
		Searches for the first occurrence of a character
		@param str string to search for
		@return true of found, false otherwise
		~#
		method : public : Has(str : String) ~ Bool {
			return Find(0, str) > -1;
		}

		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param str string to search for
		@return true of found, false otherwise
		~#
		method : public : Has(offset : Int, str : String) ~ Bool {
			return Find(offset, str) > -1;
		}
			
		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param char character to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : native : Find(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				for(i := offset; i < @pos; i += 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}

		#~
		Checks to see if the string can be represented as an float
		@return true if the string can be represented as an float, false otherwise
		~#
		method : public : IsFloat() ~ Bool {
			if(@pos > 1) {
				count := Count('.');
				if(count = 1) {
					halves := Split(".");
									
					count := halves->Size();
					if(count = 0) {
						for(i := 0; i < @pos - 1; i +=1;) {
							c := @string[i];
							if(<>(c >= '0' & c <= '9')) {
								return false;
							};
						};

						return true;
					}
					else if(count = 2) {
						first := halves[0];
						second := halves[1];

						if(first <> Nil & second <> Nil) {
							return IsInt(first) & IsInt(second);
						}
						else {
							return IsInt(second);
						};
					};
				};

				return false;
			};

			return IsInt();
		}

		method : IsInt(str : String) ~ Bool {
			# empty string
			if(str->Size() > 0) {
				i := 0;

				if(str->Get(0) = '+' | str->Get(0) = '-') {
					i += 1;
				};

				# hex
				if(str->Size() > i + 2 & str->Get(i) = '0' & (str->Get(i + 1) = 'x' | str->Get(i + 1) = 'X')) {
					for(i := i + 2; i < str->Size(); i +=1;) {
						c := str->Get(i);					
						first := c >= '0' & c <= '9';
						second := c >= 'a' & c <= 'f';
						third := c >= 'A' & c <= 'F';

						if(<>first & <>second & <>third) {
							return false;
						};
					};

					return true;
				}
				# decimal
				else if(str->Size() > i) {	
					for(i := i; i < str->Size(); i +=1;) {
						c := str->Get(i);
						if(<>(c >= '0' & c <= '9')) {
							return false;
						};
					};

					return true;
				};
			};

			return false;
		}

		#~
		Checks to see if the string can be represented as an interger
		 @return true if the string can be represented as an interger, false otherwise
		~#
		method : public : native : IsInt() ~ Bool {
			# empty string
			if(@pos > 0) {
				i := 0;

				if(@string[0] = '+' | @string[0] = '-') {
					i += 1;
				};

				# hex
				if(@pos > i + 2 & @string[i] = '0' & (@string[i + 1] = 'x' | @string[i + 1] = 'X')) {
					for(i := i + 2; i < @pos; i +=1;) {
						c := @string[i];					
						first := c >= '0' & c <= '9';
						second := c >= 'a' & c <= 'f';
						third := c >= 'A' & c <= 'F';

						if(<>first & <>second & <>third) {
							return false;
						};
					};

					return true;
				}
				# decimal
				else if(@pos > i) {	
					for(i := i; i < @pos; i +=1;) {
						c := @string[i];
						if(<>(c >= '0' & c <= '9')) {
							return false;
						};
					};

					return true;
				};
			};

			return false;
		}

		#~
		Counts the occurrence of a character
		@param char character to search for
		@return count of occurrences or -1 if not found
		~#
		method : public : Count(char : Char) ~ Int {
			return Count(0, char);
		}
		
		#~
		Counts the occurrence of a character
		@param offset search offset
		@param char character to search for
		@return count of occurrences or -1 if not found
		~#
		method : public : native : Count(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				count := 0;

				for(i := offset; i < @pos; i += 1;) {
					if(@string[i] = char) {
						count += 1;
					};
				};

				return count;
			};

			return -1;
		}
		
		#~
		Searches for the last occurrence of a character
		@param char character to search for
		@return index of last occurrence, -1 otherwise
		~#
		method : public : FindLast(char : Char) ~ Int {
			return FindLast(@pos - 1, char);
		}
		
		#~
		Searches for the last occurrence of a character
		@param offset search offset
		@param char character to search for
		@return index of last occurrence, -1 otherwise
		~#
		method : public : native : FindLast(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				for(i := offset; i > -1; i -= 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}

		#~
		Searches for the first occurrence of a string
		@param find string to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : Find(find : String) ~ Int {
			return Find(0, find);
		}

		#~
		Searches for all occurrences of a string
		@param find string to search for
		@return an array of indexes
		~#
		method : public : FindAll(find : String) ~ Int[] {
			buffer_max := 8;
			buffer := Int->New[buffer_max];
			
			count := 0;
			offset := 0;
			do {
				# check
				offset := Find(offset, find);
				# found
				if(offset > -1) {
					count += 1;
					if(count < buffer_max) {
						buffer[count - 1] := offset;
					}
					# copy elements
					else {
						temp := Int->New[buffer_max * 2];
						Runtime->Copy(temp, 0, buffer, 0, buffer_max);
						buffer_max *= 2;
						buffer := temp;
					};
					offset += find->Size();
				};
			}
			while(offset > -1);
			
			results := Int->New[count];
			each(i : results) {
				results[i] := buffer[i];
			};

			return results;
		}

		#~
		Searches for the first occurrence of a string
		@param offset search index offset
		@param find string to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : native : Find(offset : Int, find : String) ~ Int {
			size := find->Size();

			if(size > 0 & offset < @pos) {
				found_index := Find(offset, find->Get(0));
				while(found_index > -1) {
					j := found_index;
					match := true;
					i : Int;
					for(i := 0; match & i < size & j < @pos; i += 1;) {
						if(find->Get(i) <> @string[j]) {
							match := false;
						};
						j += 1;
					};

					if(match & i = size) {
						return found_index;
					};
					
					found_index := Find(found_index + 1, find->Get(0));
				};

				return -1;
			};

			return -1;
		}
		
		#~
		Replaces all occurrences the search string
		@param find string to search for
		@param replace string to replace with
		@return new string instance
		~#
		method : public : ReplaceAll(find : String, replace : String) ~ String {
			last := @self;

			result := last->Replace(find, replace);
			while(result <> last) {
				last := result;
				result := last->Replace(find, replace);
			};
			
			return result;
		}

		#~
		Removes all occurrences the search string
		@param find string to search for
		@return new string instance
		~#
		method : public : RemoveAll(find : String) ~ String {
			return ReplaceAll(find, Nil);
		}

		#~
		Removes all occurrences the search character
		@param find character to search for
		@return new string instance
		~#
		method : public : RemoveAll(find : Char) ~ String {
			buffer := "";

			for(i := 0; i < @pos; i += 1;) {
				char := @string[i];
				if(char <> find) {
					buffer->Append(char);
				};
			};

			return buffer;
		}

		#~
		Replaces all occurrences the search string
		@param find character to search for
		@param replace character to replace with
		@return new string instance
		~#
		method : public : native : ReplaceAll(find : Char, replace : Char) ~ String {
			buffer := "";

			for(i := 0; i < @pos; i += 1;) {
				char := @string[i];
				if(char = find) {
					buffer->Append(replace);
				}
				else {
					buffer->Append(char);
				};
			};

			return buffer;
		}
		
		#~
		Replaces the first occurrence the search string
		@param find string to search for
		@param replace string to replace with
		@return new string instance
		~#
		method : public : Replace(find : String, replace : String) ~ String {
			index := Find(find);
			if(index < 0) {
				return @self;
			};
		
			begin := SubString(0, index);
			new_string := begin = Nil ? String->New() : String->New(begin);

			index += find->Size();
			length := Size() - index;
			
			if(length = 0) {
				if(replace <> Nil) {
					new_string->Append(replace);
				};
			}
			else {
				end := SubString(index, length);
				if(end = Nil) {
					return @self;
				};

				if(replace <> Nil) {
					new_string->Append(replace);
				};
				new_string->Append(end);
			};
			
			return new_string;
		}

		#~
		Removes the first occurrence the search string
		@param find string to search for
		@return new string instance
		~#
		method : public : Remove(find : String) ~ String {
			return Replace(find, Nil);
		}

		#~
		Removes all matching characters from a string
		@param char character to remove
		@return string with matching characters removed
		~#
		method : public : Remove(char : Char) ~ String {
			new_string := String->New();
			
			for(i := 0; i < @pos; i += 1;) {
				cur_char := @string[i];
				if(cur_char <> char) {
					new_string->Append(cur_char);
				};
			};

			return new_string;
		}

		#~
		Deletes the character at the given index
		@param offset offset index
		@return true if deleted, false otherwise 
		~#
		method : public : Delete(offset : Int) ~ Bool {
			return Delete(offset, 1);
		}

		#~
		Deletes the characters at the given range
		@param offset offset index
		@param length length
		@return true if deleted, false otherwise 
		~#
		method : public : Delete(offset : Int, length : Int) ~ Bool {
			space := offset + length;
			if(offset < 0 | offset > @pos | space < 0 | space > @pos) {
				return false;
			};

			len := @pos - length;
			end := offset + length;
			Runtime->Copy(@string, offset, @string, end, @pos - end);
			@string[len] := '\0';
			@pos := len;

			return true;
		}

		#~
		Gets the current string's storage capacity. That is the 
		number of characters the string will hold before it is 
		resized for growth.
		@return string capacity
		~#
		method : public : Capacity() ~ Int {
			return @max;
		}

		#~
		Compresses a string removing unused space.
		~#
		method : public : Compress() ~ Nil {
			temp := Char->New[@pos];
			Runtime->Copy(temp, 0, @string, 0, @pos);
			@string := temp;	
			@max := @pos;
		}
		
		#~
		Insert inserts a character
		@param index insert offset
		@param char character to insert
		@return true if inserted, false otherwise 
		~#
		method : public : Insert(index : Int, char : Char) ~ Bool {
			if(index < 0 | index > @pos) {
				return false;
			};

			offset := index + 1;
			length := @pos - index;

			size := @pos + 1;
			if(size > @max) {
				@max += size << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, index);

				temp[index] := char;
				Runtime->Copy(temp, offset, @string, index, length);
					
				@string := temp;
			}
			else {
				Runtime->Copy(@string, offset, @string, index, length);
				@string[index] := char;
			};
			@pos := size;
			
			return true;
		}

		#~
		Insert inserts a string
		@param index insert offset
		@param string string to insert
		@return true if inserted, false otherwise 
		~#
		method : public : Insert(index : Int, string : String) ~ Bool {
			if(index < 0 | index > @pos) {
				return false;
			};
			
			buffer := string->ToCharArray();
			buffer_size := buffer->Size();

			offset := index + buffer_size;
			length := @pos - index;

			size := @pos + buffer_size;
			if(size > @max) {
				@max += size << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, index);
				
				Runtime->Copy(temp, index, buffer, 0, buffer_size);
				Runtime->Copy(temp, offset, @string, index, length);
				
				@string := temp;
			}
			else {
				Runtime->Copy(@string, offset, @string, index, length);
				Runtime->Copy(@string, index, buffer, 0, buffer_size);
			};
			@pos := size;
			
			return true;

		}

		#~
		Insert inserts a string
		@param index insert offset
		@param buffer buffer to insert
		@return true if inserted, false otherwise 
		~#
		method : public : Insert(index : Int, buffer : Char[]) ~ Bool {
			if(index < 0 | index > @pos) {
				return false;
			};
			buffer_size := buffer->Size();

			offset := index + buffer_size;
			length := @pos - index;

			size := @pos + buffer_size;
			if(size > @max) {
				@max += size << 1;
				temp := Char->New[@max];
				Runtime->Copy(temp, 0, @string, 0, index);
				
				Runtime->Copy(temp, index, buffer, 0, buffer_size);
				Runtime->Copy(temp, offset, @string, index, length);
				
				@string := temp;
			}
			else {
				Runtime->Copy(@string, offset, @string, index, length);
				Runtime->Copy(@string, index, buffer, 0, buffer_size);
			};
			@pos := size;
			
			return true;

		}
		
		#~
		Pads a string with a character
		@param char character to pad with
		@param num number of character to pad
		@param is_left if true, pad left, otherwise pad right
		@return padded string
		~#
		method : public : Pad(char : Char, num : Int, is_left : Bool := false) ~ String {
			padding := String->New();
			each(i : num) {
				padding->Append(char);
			};

			value : String;
			if(is_left) {
				value := String->New(padding);
				value->Append(@string);

			}
			else {
				value := String->New(@string);
				value->Append(padding);
			};

			return value;
		}
		
		#~
		Justify if word length is then width
		@param width width to justify to
		@param is_left if true, justify left, right otherwise
		@return padded string
		~#
		method : public : Justify(width : Int, is_left : Bool := false) ~ String {
			if(width > 0 & @string->Size() < width) {
				return Pad(' ', width - @pos, is_left);
			};

			return String->New(@string);
		}
		
		#~
		Returns rather the string is empty
		@return true if empty, false otherwise 
		~#
		method : public : IsEmpty() ~ Bool {
			return @pos = 0 ? true : false; 			
		}

		#~
		Clears string
		~#
		method : public : Clear() ~ Nil {
			@max := 8;
			@string := Char->New[@max];
			@pos := 0;			
		}

		#~
		Return the size of the string
		@return size of the string
		~#
		method : public : Size() ~ Int {
			return @pos;			
		}
  
		#~
		Returns character at the given index
		@param index index offset
		@return character at index
		~#
		method : public : native : Get(index : Int) ~ Char {
			if(index > -1 & index < @pos) {
				return @string[index];
			};

			return '\0';
		}

		#~
		Returns the first character
		@return first character
		~#
		method : public : First() ~ Char {
			return @string[0];
		}

		#~
		Returns the last character
		@return last character
		~#
		method : public : native : Last() ~ Char {
			if(@pos > 0) {
				return @string[@pos - 1];
			};
			
			return '\0';
		}

		#~
		Sets character at the given index
		@param char charter to set
		@param index index offset
		@return true if successful, false otherwise
		~#
		method : public : Set(char : Char, index : Int) ~ Bool {
			if(index > -1 & index < @pos) {
				@string[index] := char;
			};

			return false;
		}

		#~
		Pops the last character from the string reducing the
		size by 1
		@return last character of the string
		~#
		method : public : native : Pop() ~ Char {
			if(@pos > 0) {
				@pos -= 1;
				c := @string[@pos];
				@string[@pos] := '\0';
				return c;
			};

			return '\0';
		}
		
		#~
		Parses the string into an integer
		@return integer value
		~#
		method : public : ToInt() ~ Int {
			return ToInt(10);
		}

		#~
		Parses the string into an integer
		@param base base radix 
		@return integer value
		~#
		method : public : ToInt(base : Int) ~ Int {
			S2I;
		}

		#~
		Parses the string into a float
		@return float value
		~#
		method : public : ToFloat() ~ Float {
			S2F;
		}

		#~
		Parses the string into a boolean
		@return boolean value
		~#
		method : public : ToBool() ~ Bool {
			if(Get(0) = 't') {
				check := ['r', 'u', 'e'];
				each(i : check) {
					if(Get(i + 1) <> check[i]) {
						return false;
					};
				};
				
				return true;
			}
			else if(Get(0) = 'T') {
				check := ['R', 'U', 'E'];
				each(i : check) {
					if(Get(i + 1) <> check[i]) {
						return false;
					};
				};

				return true;
			};

			return false;
		}

		#~
		Checks if the string starts with the given character
		@param char character to compare
		@return true if starts with character, false otherwise
		~#
		method : public : StartsWith(char : Char) ~ Bool {
			return char <> '\0' & Get(0) = char;
		}
		
		#~
		Checks if the string ends with the given character
		@param char character to compare
		@return true if ends with character, false otherwise
		~#
		method : public : EndsWith(char : Char) ~ Bool {
			return char <> '\0' & Get(@pos - 1) = char;
		}

		#~
		Checks if the string starts with the given string
		@param string string to check for
		@return true if starts with string, false otherwise
		~#
		method : public : StartsWith(string : String) ~ Bool {
			size := string->Size();

			if(size <= @pos) {
				for(i := 0; i < size; i += 1;) {
					if(string->Get(i) <> @string[i]) {
						return false;
					};
				};

				return true;
			};

			return false;
		}

		#~
		Checks if the string ends with the given string
		@param string string to check for
		@return true if ends with string, false otherwise
		~#
		method : public : native : EndsWith(string : String) ~ Bool {
			size := string->Size();

			if(size <= @pos) {
				i := size - 1;
				j := @pos - 1;
				while(i > -1) {
					if(string->Get(i) <> @string[j]) {
						return false;
					};
					i := i - 1;
					j := j - 1;
				};

				return true;
			};

			return false;
		}
		
		#~
		Reverses a string
		@return reversed string 
		~#
		method : public : native : Reverse() ~ String {
			temp := Char->New[@max];

			i := 0; j := @pos - 1;
			while(j > -1) {
				temp[i] := @string[j];
				j -= 1;	i += 1;
			};
			
			return String->New(temp, false);
		}

		#~
		Removes all leading white space
		@return trimmed string
		~#
	    method : public : native : TrimFront() ~ String {
	            if(@pos = 0) {
	                    return "";
	            };

	            start := 0;
	            c := @string[start];
	            while(start < @pos & (c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = '\v' | c = '\f' | 
						c = 0xa0 | c = 0x1680 | c >= 0x2000 & c <= 0x200a | c >= 0x000a & c <= 0x000d | 
						c = 0x202f | c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029)) {
					start += 1;
					c := @string[start];
	            };

			return String->New(@string, start, @pos - start + 1);
		}

		#~
        Removes all trailing white space
        @return trimmed string
        ~#
        method : public : native : TrimBack() ~ String {
            if(@pos = 0) {
                    return "";
            };

			end := @pos;
			do {
				end -= 1;
				c := @string[end];
			}
			while(end > 0 & (c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = '\v' | c = '\f' | 
				c = 0xa0 | c = 0x1680 | c >= 0x2000 & c <= 0x200a |	c >= 0x000a & c <= 0x000d | 
				c = 0x202f | c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029));

			if(end < 1) {
				return "";
			};

			return String->New(@string, 0, end + 1);
		}

		#~
		Removes all leading and trailing white space
		@return trimmed string
		~#
		method : public : native : Trim() ~ String {
			if(@pos = 0) {
				return "";
			};

			start := 0;
			c := @string[start];
			while(start < @pos & (c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = '\v' | c = '\f' | 
					c = 0xa0 | c = 0x1680 | c >= 0x2000 & c <= 0x200a | c >= 0x000a & c <= 0x000d | 
					c = 0x202f | c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029)) {
				start += 1;
				c := @string[start];
			};

			end := @pos;
			do {
				end -= 1;
				c := @string[end];
			}
			while(end > 0 & (c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = '\v' | c = '\f' | 
				c = 0xa0 | c = 0x1680 | c >= 0x2000 & c <= 0x200a | c >= 0x000a & c <= 0x000d | 
				c = 0x202f | c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029));

			if(end < start) {
				return "";
			};
	
			return String->New(@string, start, end - start + 1);
		}
		
		#~
		Splits a string into lines
		@return array of lines
		~#
		method : public : native : Lines() ~ String[] {
			count := 0;

			# count lines
			start := 0;
			skip := false;
			each(i : @pos) {
				if(skip) {
					skip := false;
				}
				else {
					if(@string[i] = '\r' & i + 1 < @pos & @string[i + 1] = '\n') {
						count += 1;

						# update
						start := i + 2;
						skip := true;
					}
					else if(@string[i] = '\n' | @string[i] = '\r') {
						count += 1;

						# update
						start := i + 1;
					};
				};
			};

			# response array
			lines := String->New[count];
			count := 0;

			# parse lines
			start := 0;
			skip := false;
			each(i : @pos) {
				if(skip) {
					skip := false;
				}
				else {
					if(@string[i] = '\r' & i + 1 < @pos & @string[i + 1] = '\n') {
						line : String;
						len := i - start;
						if(len > 0) {
							lines[count++] := SubString(start, len);
						}
						else {
							lines[count++] := String->New();
						};

						# update
						start := i + 2;
						skip := true;
					}
					else if(@string[i] = '\n' | @string[i] = '\r') {
						line : String;
						len := i - start;
						if(len > 0) {
							lines[count++] := SubString(start, len);
						}
						else {
							lines[count++] := String->New();
						};

						# update
						start := i + 1;
					};
				};
			};

			return lines;
		}

		#~
		Splits a string based upon delimiter
		@param delim splitting delimiter
		@return array of split sub strings 
		~#
		method : public : Split(delim : String) ~ String[] {
			delim_size := delim->Size();
			if(delim_size = 0 | @pos = 0) {
				return String->New[0];
			};
			
			# first-pass count tokens
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			each(i : @pos) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim_size & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim_size) {
						count += 1;
						start_index := found_index + delim_size;
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				count += 1;
			};
			
			# second-pass parse tokens
			parsed_strings : String[] := String->New[count];
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			each(i : @pos) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim_size & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim_size) {
						parsed_strings[count] := SubString(start_index, found_index - start_index);
						count += 1;
						
						start_index := found_index + delim_size;
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				parsed_strings[count] := SubString(start_index, @pos - start_index);
				count += 1;
			};
			
			return parsed_strings;
		}


		#~
		Splits a string based upon delimiter
		@param delim splitting delimiter
		@return array of split sub strings 
		~#
		method : public : Split(delim : Char) ~ String[] {
			count := 0;
			
			each(i : @pos) {
				if(@string[i] = delim) {
					count += 1;
				};
			};

			if(count <> 0) {
				count += 1;
			};

			strings := String->New[count];

			start := count := 0;
			each(i : @pos) {
				char := @string[i];

				if(char = delim) {
					strings[count++] := String->New(@string, start, i - start);
					start := i + 1;
				};
			};

			if(start <> 0) {
				strings[count++] := String->New(@string, start, @string->Size() - start);
			};

			return strings;
		}
		
		#~
		Transforms a to upper case
		@return upper case string
		~#
		method : public : native : ToUpper() ~ String {
			array := Char->New[@pos];

			each(i : @pos) {
				c := @string[i];
				if(c > 96 & c < 123) {
					c := c - 32;
				};
				array[i] := c;
			};
			
			return String->New(array, false);
		}
		
		#~
		Transforms a to lower case
		@return lower case string
		~#
		method : public : native : ToLower() ~ String {
			array := Char->New[@pos];

			each(i : @pos) {
				c := @string[i];
				if(c > 64 & c < 91) {
					c := c + 32;
				};
				array[i] := c;
			};
			
			return String->New(array, false);
		}

		#~
		Creates a sub-string
		@param length max length of sub-string
		@return sub-string
		~#
		method : public : SubString(length : Int) ~ String {
			return SubString(0, length);
		}

		#~
		Creates a sub-string
		@param offset index offset
		@param length max length of sub-string
		@return sub-string
		~#
		method : public : SubString(offset : Int, length : Int) ~ String {
			if(offset < 0 | offset > @pos) {
				return Nil;
			};

			end : Int := length + offset;
			if(end < 0 | end > @pos) {
				return Nil;
			};

			array := Char->New[length];
			if(<>Runtime->Copy(array, 0, @string, offset, length)) {
				return Nil;
			};

			return String->New(array, false);
		}
	
		#~
		Compares two strings
		@param rhs string to compare
		@return true if equal, false otherwise
		~#
		method : public : native : Equals(rhs : String) ~ Bool {
			if(@pos <> rhs->Size()) {
				return false;
			};

			start := 0;
			end := @pos - 1;

			while(start <= end) {
				l := @string[start];
				r := rhs->Get(start);
				if(l <> r) {
					return false;
				}

				l := @string[end];
				r := rhs->Get(end);
				if(l <> r) {
					return false;
				}

				start += 1;
				end -= 1;
			};

			return true;
		}

		#~
		Compares a string to an array of values
		@param rhs array of values to compare
		@return true if at least one match, false otherwise
		~#
		method : public : Equals(rhs : String[]) ~ Bool {
			each(str := rhs) {
				if(Equals(str)) {
					return true;
				};
			};

			return false;
		}
		
		#~
		Compares two strings, ignoring the case
		@param rhs string to compare
		@return true if equal, false otherwise
		~#
		method : public : native : EqualsIgnoreCase(rhs : String) ~ Bool {
			if(@pos <> rhs->Size()) {
				return false;
			};
			
			start := 0;
			end := @pos - 1;

			while(start <= end) {
				l := @string[start]->ToLower();
				r := rhs->Get(start)->ToLower();
				if(l <> r) {
					return false;
				}

				l := @string[end]->ToLower();
				r := rhs->Get(end)->ToLower();
				if(l <> r) {
					return false;
				}

				start += 1;
				end -= 1;
			};

			return true;
		}

		#~
		Compares a string to an array of values, ignoring case
		@param rhs array of values to compare
		@return true if at least one match, false otherwise
		~#
		method : public : EqualsIgnoreCase(rhs : String[]) ~ Bool {
			each(str := rhs) {
				if(EqualsIgnoreCase(str)) {
					return true;
				};
			};

			return false;
		}

		#~
		Returns a unique hash ID for a given string sequence
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			STRING_HASH_ID;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
						
			# check each character
			right_string := rhs->As(String);
			for(i := 0; i < @pos; i += 1;) {
				left := @string[i];
				right := right_string->Get(i);
				if(left > right) {
					return 1;
				}
				else if(left < right) {
					return -1;
				};
			};
			
			# check length
			if(@pos > right_string->Size()) {
				return 1;
			};
			
			if(@pos < right_string->Size()) {
				return -1;
			};
			
			# equal
			return 0;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.String {
			return String->New(@string);
		}

		#~
		Creates a new instance of the string
		@return new string instance
		~#
		method : public : Copy() ~ String {
			return String->New(@string);
		}

		#~
		Print a string
		~#
		method : public : Print() ~ Nil {
			@string->Print();
		}

		#~
		Print a string with a newline
		~#
		method : public : PrintLine() ~ Nil {
			@string->PrintLine();
		}

		#~
		Print an error string
		~#
		method : public : Error() ~ Nil {
			@string->Error();
		}

		#~
		Print an error string with a newline
		~#
		method : public : ErrorLine() ~ Nil {
			@string->ErrorLine();
		}
	}
	
	#~
	Provides access to runtime system
	~#	
	class Runtime {
		#~
		Runtime signal types.<br/>
		<p><pre>Runtime->Signal</pre></p>
		@class Runtime
		~#
		enum Signal := -40 {
			SIGABRT,
			SIGFPE,
			SIGILL,
			SIGINT,
			SIGSEGV,
			SIGTERM
		}

		#~
		Sets the runtime locale
		@param locale <a href='https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/setlocale-wsetlocale?view=msvc-170'>locale string</a>
		~#
		function : SetLocale(locale : String) ~ Nil {
			Runtime->SetProperty("locale", locale);
		}

		#~
		Sets a system signal	
		@param type signal type
		@param func function handler for signal
		~#
		function : SetSignal(type : Runtime->Signal, func : (Int) ~ Nil) ~ Nil {
			SET_SIGNAL;
		}

		#~
		Raises a system signal
		@param type signal type
		~#
		function : RaiseSignal(type : Runtime->Signal) ~ Nil {
			RAISE_SIGNAL;
		}

		#~
		Causes the executing program to halt
		@param code exit code
		~#
		function : Exit(code : Int) ~ Nil {
			EXIT;
		}

		#~
		Executes a system command
		@param c system command
		@return command status code
		~#
		function : Command(c : System.String) ~ Int {
			SYS_CMD;
		}

		#~
		Executes a system command
		@param c system command
		@return output from command
		~#
		function : CommandOutput(c : System.String) ~ CommandOutput {
			CommandOutput(c, Nil->As(String[]));
		}
		
		#~
		Executes a system command
		@param c system command
		@param e array of environment variables
		@return output from command
		~#
		function : CommandOutput(c : System.String, e : String[]) ~ CommandOutput {
			SYS_CMD_OUT;
		}
		
		#~
		Asserts runtime value to be true. If false,
		program exits with stack trace.
		@param assert value to assert
		~#
		function : Assert(assert : Bool) ~ Nil {
			ASSERT_TRUE;
		}
		
		#~
		Returns an OS platform string
		@return OS platform string
		~#
		function : GetPlatform() ~ String {
			GET_PLTFRM;
		}

		#~
		Returns the package version string
		@return package version string
		~#
		function : GetVersion() ~ String {
			GET_VERSION;
		}

		#~
		Returns the system's temporary directory
		@return system's temporary directory
		~#
		function : GetTempDir() ~ String {
			return GetProperty("tmp_dir");
		}

		#~
		Returns the current user's working directory
		@return current user's working directory
		~#
		function : GetUserDir() ~ String {
			return GetProperty("user_dir");
		}
		
		#~
		Returns the installation directory
		@return installation directory
		~#
		function : GetInstallDir() ~ String {
			return GetProperty("install_dir");
		}

		#~
		Returns the library directory
		@return installation directory
		~#
		function : GetLibraryDir() ~ String {
			return GetProperty("lib_dir");
		}
		
		#~
		Fetches a runtime property. System properties include: 'user_dir', temp_dir and 'install_dir'.
		@param key property key
		@return runtime property 
		~#
		function : GetProperty(key : String) ~ String {
			GET_SYS_PROP;
		}

		#~
		Checks if a property exists
		@param key property key
		@return true if it exists, false otherwise
		~#
		function : HasProperty(key : String) ~ Bool {
			value := GetProperty(key);
			return value <> Nil & <>value->IsEmpty();
		}
		
		#~
		Sets a runtime property 
		@param key property key
		@param value property value
		~#
		function : SetProperty(key : String, value : String) ~ Nil {
			SET_SYS_PROP;
		}

		#~
		Fetches a runtime environment variable.
		@param key variable key
		@return runtime environment variable 
		~#
		function : GetEnvironmentVariable(key : String) ~ String {
			GET_SYS_ENV;
		}

		#~
		Checks if an environment variable exists
		@param key variable key
		@return true if it exists, false otherwise
		~#
		function : HasEnvironmentVariable(key : String) ~ Bool {
			value := GetEnvironmentVariable(key);
			return value <> Nil & <>value->IsEmpty();
		}
		
		#~
		Sets a runtime environment variable 
		@param key variable key
		@param value environment value
		~#
		function : SetEnvironmentVariable(key : String, value : String) ~ Nil {
			SET_SYS_ENV;
		}
		
		#~
		Returns the current time
		@param gmt true of time is in GMT, false for local time zone
		@return current time
		~#
		function : GetTime(gmt : Bool) ~ Time.Date {
			return Time.Date->New(gmt);
		}
		
		#~
		Copies data between two byte arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of bytes to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Byte[], dest_offset : Int, src : Byte[], src_offset : Int, len : Int) ~ Bool {
			CPY_BYTE_ARY;
		}
		
		#~
		Copies data between two character arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of characters to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Char[], dest_offset : Int, src : Char[], src_offset : Int, len : Int) ~ Bool {
			CPY_CHAR_ARY;
		}
		
		#~
		Copies data between two integer arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Int[], dest_offset : Int, src : Int[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two Base arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Base[], dest_offset : Int, src : Base[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two Compare arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Compare[], dest_offset : Int, src : Compare[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two float arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Float[], dest_offset : Int, src : Float[], src_offset : Int, len : Int) ~ Bool {
			CPY_FLOAT_ARY;
		}
	}

	#~
	Output from system command call
	~#	
	class CommandOutput {
		New() {
			Parent();
		}

		@command : String;
		@status : Int;
		@output : String[];

		#~
		Gets the command that was executed
		@return command executed
		~#
		method : public : GetCommand() ~ String {
			return @command;
		}

		#~
		Gets the return status code for the command executed
		@return status code
		~#
		method : public : GetStatus() ~ Int {
			return @status;
		}

		#~
		Gets output from command
		@return output from command
		~#
		method : public : GetOutput() ~ String[] {
			return @output;
		}

		#~
		Creates a string representation of the command output
		@return string representation of the command output
		~#
		method : public : ToString() ~ String {
			buffer := "command='{$@command}', status={$@status}\noutput:";
			for(i := 0; i < @output->Size(); i += 1;) {
				output := @output[i];
				buffer->Append("\t'{$output}'");
			};
			
			return buffer;
		}
	}
}

#~
System API Bundle
~#
bundle System.API {
	#~
	Class allow programmers to load native shared 
	libraries that can be called by Objeck classes. 
	Programmers can call native C functions within these 
	libraries.
	~#	
	class DllProxy {
		@name : String;
		@ptr : Int;
		
		#~
		<p>Path to the shared library.</p></strong>The file 
		name must start with 'libobjk_'. The file 
		ending should not include the extension 
		name (i.e. .dll, .so, etc.) for portability. 
		@param name shared library path<strong>
		~#
		New(name : String) {
			Parent();

			@name := name;
			EXT_LIB_LOAD;
		}
		
		#~
		Returns rather the shared library has been successfully loaded
		@return returns true if the the library has been successfully loaded, false otherwise
		~#
		method : public : IsLoaded() ~ Bool {
			return @ptr <> 0;
		}
		
		#~
		Unloads the shared library
		~#
		method : public : Unload() ~ Nil {
			EXT_LIB_UNLOAD;
		}
		
		#~
		Calls a native C function.
		@param name of the native C function
		@param args argument to the native function
		~#
		method : public : CallFunction(name : String, args : Base[]) ~ Nil {
			EXT_LIB_FUNC_CALL;
		}
	}
}

#~
Provides support for dates and times
~#	
bundle System.Time {	
	#~
	Provides date and time functionality 
	~#	
	class Date implements System.Compare, System.Clone, System.Stringify {
		@day : Int;
		@month : Int;
		@year : Int;
		@hours : Int;
		@mins : Int;
		@secs : Int;
		@is_savings : Bool;
		@week_day : Int;
		@is_gmt : Bool;
		
		#~
		Default constructor 
		~#
		New() {
			Parent();
			SYS_TIME;
		}

		#~
		Constructor 
		@param gmt true of time is in GMT, false for local time zone
		~#
		New(gmt : Bool) {
			Parent();
			if(gmt) {
				GMT_TIME;
			}
			else {
				SYS_TIME;
			};
		}

		#~
		Constructor, set time using Unix time
		@param unix_time number of seconds elapsed since 00:00 hours, Jan 1, 1970 UTC
		@param gmt true of time is in GMT, false for local time zone
		~#
		New(unix_time : Int, gmt : Bool := true) {
			Parent();
			if(gmt) {
				DATE_FROM_UNIX_GMT_TIME;
			}
			else {
				DATE_FROM_UNIX_LOCAL_TIME;
			};
		}
		
		#~
		Constructor, sets time to midnight of the given day
		@param day day of month
		@param month day of year
		@param year year
		@param gmt true of time is in GMT, false for local time zone
		~#
		New(day : Int, month : Int, year : Int, gmt : Bool) {
			Parent();
			DATE_TIME_SET_1;
		}

		#~
		Constructor 
		@param day day of month
		@param month month of year
		@param year year
		@param hours hours
		@param mins minutes
		@param secs seconds
		@param gmt true of time is in GMT, false for local time zone
		~#
		New(day : Int, month : Int, year : Int, hours : Int, mins : Int, secs : Int, gmt : Bool) {
			Parent();
			DATE_TIME_SET_2;
		}

		#~
		Compares two dates
		@param rhs compare date
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			r := 0;

			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				r := -1;
			};
						
			# check dates
			right_date := rhs->As(Date);
			if(@year > right_date->GetYear()) {
				r := 1;
			}
			else if(@year < right_date->GetYear()) {
				r := -1;
			}
			else if(@month > right_date->GetMonth()) {
				r := 1;
			}
			else if(@month < right_date->GetMonth()) {
				r := -1;
			}
			else if(@day > right_date->GetDay()) {
				r := 1;
			}
			else if(@day < right_date->GetDay()) {
				r := -1;
			}
			else if(@hours > right_date->GetHours()) {
				r := 1;
			}
			else if(@hours < right_date->GetHours()) {
				r := -1;
			}
			else if(@mins > right_date->GetMinutes()) {
				r := 1;
			}
			else if(@mins < right_date->GetMinutes()) {
				r := -1;
			}
			else if(@secs > right_date->GetSeconds()) {
				r := 1;
			}
			else if(@secs < right_date->GetSeconds()) {
				r := -1;
			};
			
			return r;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Time.Date {
			return System.Time.Date->New(@day, @month, @year, @hours, @mins, @secs, @is_gmt);
		}

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return ToString()->HashID();
		}
		
		#~
		Returns rather time is daylight savings
		@return true if daylight savings, false otherwise
		~#
		method : public : IsDaylightSaving() ~ Bool {
			return @is_savings;
		}

		#~
		Returns rather time is GMT
		@return true if GMT, false otherwise
		~#
		method : public : IsGmt() ~ Bool {
			return @is_gmt;
		}
		
		#~
		Returns the day
		@return day
		~#
		method : public : GetDay() ~ Int {
			return @day;
		}

		#~
		Returns name of the week day
		@return name of the week day
		~#
		method : public : GetWeekDayName() ~ String {
			days_of_week := ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
			if(@week_day > -1 & @week_day < days_of_week->Size()) {
				return days_of_week[@week_day];
			};

			return "";
		}

		#~
		Returns day of the week
		@return 0-6 day value
		~#
		method : public : GetWeekDay() ~ Int {
			return @week_day;
		}

		#~
		Returns the month 
		@return 1-12 month value
		~#
		method : public : GetMonth() ~ Int {
			return @month;
		}
		
		#~
		Returns name of the month
		@return name of the month
		~#
		method : public : GetMonthName() ~ String {
			days_of_month := ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
			if(@month > -1 & @month - 1 < days_of_month->Size()) {
				return days_of_month[@month - 1];
			};

			return "";
		}

		#~
		Returns the year 
		@return year
		~#
		method : public : GetYear() ~ Int {
			return @year;
		}
		
		#~
		Returns the hours 
		@return hours
		~#
		method : public : GetHours() ~ Int {
			return @hours;
		}
		
		#~
		Returns the minutes  
		@return minutes
		~#
		method : public : GetMinutes() ~ Int {
			return @mins;
		}

		#~
		Gets the time string
		@param is_24hr true if 24-hour clock, false otherwise
		@return time string
		~#
		method : public : GetTimeString(is_24hr : Bool := true) ~ String {
			buffer := "";
			is_pm := false;

			if(is_24hr & @hours > 12) {
	   			@hours /= 2;
	   			is_pm := true;
		   	};
	   		buffer->Append(@hours);

			if(@mins < 9) {
	   			buffer->Append(":0{$@mins}");
	   		}
	   		else {
	   			buffer->Append(":{$@mins}");
	   		}

	   		if(@secs < 9) {
	   			buffer->Append(":0{$@secs}");
	   		}
	   		else {
	   			buffer->Append(":{$@secs}");
	   		}

	   		if(is_24hr) {
		   		if(is_pm) {
		   			buffer->Append(" AM");
		   		}
		   		else {
		   			buffer->Append(" PM");
		   		};
		   	};

			return buffer;
		}

		#~
		Gets the date string
		@return date string
		~#
		method : public : GetDateString() ~ String {
			buffer := "";

			buffer->Append(@month);
	   		buffer->Append('/');
	   		buffer->Append(@day);
	   		buffer->Append('/');
	   		buffer->Append(@year);

			return buffer;
		}
		
		#~
		Returns the seconds  
		@return seconds
		~#
		method : public : GetSeconds() ~ Int {
			return @secs;
		}

		#~
		Add days to the date
		@param value days to add
		~#
		method : public : AddDays(value : Int) ~ Nil {
			DATE_TIME_ADD_DAYS;
		}

		#~
		Add hours to the date
		@param value hours to add
		~#
		method : public : AddHours(value : Int) ~ Nil {
			DATE_TIME_ADD_HOURS;
		}

		#~
		Add minutes to the date
		@param value minutes to add
		~#
		method : public : AddMinutes(value : Int) ~ Nil {
			DATE_TIME_ADD_MINS;
		}

		#~
		Add seconds to the date
		@param value seconds to add
		~#
		method : public : AddSeconds(value : Int) ~ Nil {
			DATE_TIME_ADD_SECS;
		}

		#~
		Get the Unix time, number of seconds elapsed since 00:00 hours, Jan 1, 1970 UTC
		@param elapsed seconds since Jan 1, 1970 UTC
		~#
		method : public : GetUnixTime() ~ Int {
			DATE_TO_UNIX_TIME;
		}

		#~
		Creates a string representation of the date
		@return string representation of the date
		~#
		method : public : ToString() ~ String {
			out := String->New();

			out->Append(GetWeekDayName());
			out->Append(", ");
			out->Append(GetMonthName());
			out->Append(" ");
			out->Append(@day);
			out->Append(", ");
			out->Append(@year);
			out->Append(" ");

			if(@hours = 0) {
				out->Append(12);
			}
			else {
				out->Append(@hours);
			};

			out->Append(":");
			if(@mins < 10) {
				out->Append('0');
			};
			out->Append(@mins);

			out->Append(":");
			if(@secs < 10) {
				out->Append('0');
			};
			out->Append(@secs);

			return out;
		}

		#~
		Creates a shortened string representation of the date
		@return shortened string representation of the date
		~#
		method : public : ToShortString() ~ String {
			out := String->New();

			out->Append(@month);
			out->Append('/');
			out->Append(@day);
			out->Append('/');
			out->Append(@year);
			out->Append(" ");

			if(@hours = 0) {
				out->Append(12);
			}
			else {
				out->Append(@hours);
			};

			out->Append(":");
			if(@mins < 10) {
				out->Append('0');
			};
			out->Append(@mins);

			out->Append(":");
			if(@secs < 10) {
				out->Append('0');
			};
			out->Append(@secs);

			return out;
		}
	}
	
	#~
	Provides a system timer
	~#
	class Alarm {
		@timer : Clock;
		@param : System.Base;

		#~
		Constructor
		@param time alarm time
		@param recur true if reoccurring, false otherwise
		~#
		New(time : Int, recur : Bool) {
			Parent();
			@timer := Clock->New(time, recur);
		}

		#~
		Constructor
		@param time alarm time
		~#
		New(time : Int) {
			Parent();
			@timer := Clock->New(time);
		}

		#~
		Start the alarm
		@param param callback parameter
		~#
		method : public : Start(param : System.Base) ~ Nil {
			@param := param;
			@timer->Execute(@self);
		}

		#~
		Ends the alarm if it's reoccurring
		~#
		method : public : Stop() ~ Nil {
			@timer->Stop();
		}

		#~
		Get the current timer interval
		~#
		method : public : GetInterval() ~ Int {
			@timer->GetTime();
		}
		
		#~
		Set the timer interval
		@param time timer interval
		~#
		method : public : SetInterval(time : Int) ~ Nil {
			@timer->SetTime(time);
		}

		method : public : GetParam() ~ System.Base {
			return @param;
		}

		#~
		Alarm callback method
		@param param callback parameter
		~#
		method : virtual : public : Ring(param : System.Base) ~ Nil;
	}

	class : private : Clock from System.Concurrency.Thread {
		@time : Int;
		@recur : Bool;

		New(time : Int, recur : Bool) {
			Parent();

			@time := time;
			@recur := recur;
		}

		New(time : Int) {
			Parent();

			@time := time;
			@recur := true;
		}

		method : public : GetTime() ~ Int {
			return @time;
		}

		method : public : SetTime(time : Int) ~ Nil {
			@time := time;
		}

		method : public : Stop() ~ Nil {
			@recur := false;
		}

		method : public : Run(param : System.Base) ~ Nil {
			alarm := param->As(Alarm);
			if(@recur) {
				while(@recur) {
					System.Concurrency.Thread->Sleep(@time);
					alarm->Ring(alarm->GetParam());
				};
			}
			else {
				System.Concurrency.Thread->Sleep(@time);
				alarm->Ring(alarm->GetParam());
			};
		}
	}
	
	#~
	Provides elapsed time 
	~#	
	class Timer {
		@elapsed : Int;
		@running : Bool;
		
		#~
		Constructor
		@param start flag, start timer after instantiation, default = true
		~#
		New(start : Bool := false) {
			Parent();

			if(start) {
				Start();
			};
		}
		
		#~
		Starts the timer
		~#
		method : public : Start() ~ Nil {
			TIMER_START;
			@running := true;
		}
		
		#~
		Ends the timer
		~#
		method : public : End() ~ Nil {
			TIMER_END;
			@running := false;
		}
		
		#~
		Gets the elapsed time in seconds
		~#
		method : public : GetElapsedTime() ~ Float {
			if(@running) {
				End();
			};
			
			TIMER_ELAPSED;
		}
		
		#~
		Formats the timer into a string
		@return formatted string
		~#
		method : public : ToString() ~ String {
			return GetElapsedTime()->ToString();
		}
	}
}

#~
System support for threads and runtime concurrency
~#
bundle System.Concurrency {	
	#~
	Abstracts native system thread execution 
	
	```
class Test {
  function : Main(args : String[]) ~ Nil {
    x := Counter->New("x,128");
    y := Counter->New("y,32");
    
    x->Execute(Nil);
    y->Execute(Nil);    

    x->Join();
    y->Join();
  }
}

class Counter from System.Concurrency.Thread {
  @name : String;
  @max : Int;

  New(tag : String) {
    Parent();
    parts := tag->Split(',');
    @name := parts[0]->Trim();
    @max := parts[1]->Trim()->ToInt();
  }

  method : public : Run(param:System.Base) ~ Nil {
    count := 0;
    while(count++ < @max) {
      "{$@name}: {$count}"->PrintLine();
    };
  }
}
	```
	~#	
	class Thread {
		@id : Int;
		@name : String;
		@param : System.Base;
		
		#~
		Name of the thread
		@param name name of the thread
		~#
		New(name : String) {
			Parent();
			@name := name;
		}
		
		#~
		Called to execute a new thread 
		@param param parameter to be passed into the newly executing thread 
		~#
		method : public : Execute(param : System.Base) ~ Nil {
			@param := param;
			ASYNC_MTHD_CALL;
		}

		#~
		Sleeps the executing thread
		@param t sleep time in milliseconds
		~#
		function : Sleep(t : Int) ~ Nil {
			THREAD_SLEEP;
		}
		
		#~
		Joins the executing thread with the caller
		~#
		method : public : Join() ~ Nil {
			THREAD_JOIN;
		}
		
		#~
		Returns the thread's name
		@return thread's name
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns a unique execution ID
		@return execution ID
		~#
		method : public : GetExecuteID() ~ Int {
			return @id;
		}
		
		#~
		Prototype for the thread to be executed
		@param param parameter to be passed into the thread 
		~#
		method : virtual : public : Run(param : System.Base) ~ Nil;
	}	
	
	#~
	Thread mutex used to protect critical sections 
	~#	
	class ThreadMutex {
		@name : String;
		# hack to hold a mutex struct.  Largest struct 
		# is 64-bytes for x64 POSIX
		@m0 : Int;
		@m1 : Int;
		@m2 : Int;
		@m3 : Int;
		@m4 : Int;
		@m5 : Int;
		@m6 : Int;
		@m7 : Int;
		
		#~
		Name of the mutex
		@param name name of the mutex
		~#
		New(name : String) {
			Parent();
			@name := name;
			THREAD_MUTEX;
		}
		
		#~
		Name of the mutex
		@return name of the mutex
		~#
		method : public : GetName() ~ String {
			return @name;
		}
	}
}

#~
Provides I/O functions
~#
bundle System.IO {
	#~
	An abstract input stream
	~#
	interface InputStream {
		#~
		Reads a byte
		@return byte read
		~#
		method : virtual : public : ReadByte() ~ Byte;
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : virtual : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int;
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : virtual : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int;
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : virtual : public : ReadLine() ~ System.String;
		
		#~
		Closes the stream
		~#
		method : virtual : public : Close() ~ Nil;
	}
	
	#~
	An abstract output stream
	~#
	interface OutputStream {
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : virtual : public : WriteByte(b : Int) ~ Bool;
		
		#~
		Writes bytes from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : virtual : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int;
		
		#~
		Writes characters from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : virtual : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int;
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : virtual : public : WriteString(str : System.String) ~ Nil;
		
		#~
		Closes the stream
		~#
		method : virtual : public : Close() ~ Nil;
	}
	
 	#~
	Provides standard I/O operations
	~#
	class Console {
		#~
		Reads bytes from STDIN
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of byte read
		~#
		function : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			STD_IN_BYTE_ARY_LEN;
		}
		
		#~
		Read characters from STDIN
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of byte read
		~#
		function : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			STD_IN_CHAR_ARY_LEN;
		}
		 	
		#~
		Write a byte buffer to STDOUT
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);	
		}

		#~
		Write a byte buffer to STDOUT
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of byte written
		~#
		function : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			STD_OUT_BYTE_ARY_LEN;	
		}

		#~
		Writes a character string
		@param str string to be written
		~#
		function : public : WriteString(str : System.String) ~ Int {
			return WriteString(str->ToCharArray());
		}

		#~
		Write a byte character to STDOUT
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteString(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);	
		}

		#~
		Write a character buffer to STDOUT
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of byte written
		~#
		function : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			STD_OUT_CHAR_ARY_LEN;
		}

		#~
		Write a byte buffer to STDERR
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteErrorBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Bool {
			STD_ERR_BYTE_ARY;	
		}

		#~
		Write a character buffer to STDERR
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteErrorBuffer(offset : Int, num : Int, buffer : Char[]) ~ Bool {
			STD_ERR_CHAR_ARY;
		}
		
		#~
		Reads a string from STDIN
		@return string read
		~#
		function : ReadLine() ~ System.String {
			console := IO.ConsoleIO->Instance();
			return console->ReadString();
		}

		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : Print(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
		
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : PrintLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
	
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : Print(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
	
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : PrintLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
		
		#~
		Writes a value
		@param c value
		@return I/O console instance
		~#
		function : Print(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(c);
		}
	
		#~
		Writes a value
		@param c value
		@return I/O console instance
		~#
		function : PrintLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(c);
		}
	
		#~
		Writes a value
		@param i value
		@return I/O console instance
		~#
		function : Print(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(i);
		}
	
		#~
		Writes a value
		@param i value
		@return I/O console instance
		~#
		function : PrintLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(i);
		}
		
		#~
		Writes a value
		@param f value
		@return I/O console instance
		~#
		function : Print(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(f);
		}
	
		#~
		Writes a value
		@param f value
		@return I/O console instance
		~#
		function : PrintLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(f);
		}
	
		#~
		Writes a value
		@param cc value
		@return I/O console instance
		~#
		function : Print(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(cc);
		}
	
		#~
		Writes a value
		@param cc value
		@return I/O console instance
		~#
		function : PrintLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(cc);
		}
		
		#~
		Writes a value
		@param s value
		@return I/O console instance
		~#
		function : Print(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(s);
		}
	
		#~
		Writes a value
		@param s value
		@return I/O console instance
		~#
		function : PrintLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(s);
		}
	
		#~
		Prints a character return
		@return I/O console instance
		~#
		function : PrintLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine();
		}

		#~
		Flushes the STDOUT buffer
		@return I/O console instance
		~#
		function : Flush() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Flush();
		}

		#~
		Flushes the STDERR buffer
		@return I/O console instance
		~#
		function : FlushError() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->FlushError();
		}

		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : Error(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(b);
		}
		
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : ErrorLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(b);
		}
	
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : Error(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(b);
		}
	
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : ErrorLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(b);
		}
		
		#~
		Writes an error value
		@param c value
		@return I/O console instance
		~#
		function : Error(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(c);
		}
	
		#~
		Writes an error value
		@param c value
		@return I/O console instance
		~#
		function : ErrorLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(c);
		}
	
		#~
		Writes an error value
		@param i value
		@return I/O console instance
		~#
		function : Error(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(i);
		}
	
		#~
		Writes an error value
		@param i value
		@return I/O console instance
		~#
		function : ErrorLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(i);
		}
		
		#~
		Writes an error value
		@param f value
		@return I/O console instance
		~#
		function : Error(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(f);
		}
	
		#~
		Writes an error value
		@param f value
		@return I/O console instance
		~#
		function : ErrorLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(f);
		}
	
		#~
		Writes an error value
		@param cc value
		@return I/O console instance
		~#
		function : Error(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(cc);
		}
	
		#~
		Writes an error value
		@param cc value
		@return I/O console instance
		~#
		function : ErrorLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(cc);
		}
		
		#~
		Writes an error value
		@param s value
		@return I/O console instance
		~#
		function : Error(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(s);
		}
	
		#~
		Writes an error value
		@param s value
		@return I/O console instance
		~#
		function : ErrorLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(s);
		}
	
		#~
		Writes an error character return
		@return I/O console instance
		~#
		function : ErrorLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine();
		}

		#~
		Set integer display format.
		@param format integer format
		~#
		function : SetIntFormat(format : Number->Format) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->SetIntFormat(format);
		}

		#~
		Set floating point display format.
		@param format integer format
		~#
		function : SetFloatFormat(format : Number->Format) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->SetFloatFormat(format);
		}

		#~
		Set floating point display precision.
		@param precision decimal precision
		~#
		function : SetFloatPrecision(precision : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->SetFloatPrecision(precision);
		}

		#~
		Sets the output width
		@param width output width
		~#
		function : SetWidth(width : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->SetWidth(width);
		}

		#~
		Sets the output fill
		@param fill output fill
		~#
		function : SetFill(fill : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->SetFill(fill);
		}
	}

	#~
	Named pipe support. 
	For POSIX, a file backed UNIX socket. For Windows, a named pipe object.
	~#
	class Pipe implements InputStream, OutputStream {
		@handle : Int;
		@mode : Pipe->Mode;
		@name : String;

		#~
		Pipe mode
		@class Pipe
		~#
		enum Mode := -4 {
			CREATE,
			OPEN
		}

		#~
		Creates a new pipe or attaches to an existing one
		@param name pipe path and name. For POSIX the base directory is <pre>/tmp/</pre> for Windows <pre>\\.\pipe\</pre>
		@param mode create or open pipe
		~#
		New(name : String, mode : Pipe->Mode) {
			Parent();

			@name := name;
			if(mode = Pipe->Mode->CREATE) {
				PIPE_CREATE;
			}
			else {
				PIPE_OPEN;
			};
			@mode := mode;
		}

		#~
		Gets the pipe name
		@return pipe name
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns rather the pipe is open
		@return true if pipe is open, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			return @handle = 0 ? false : true;
		}

		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			PIPE_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			PIPE_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			PIPE_IN_CHAR_ARY;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadLine() ~ System.String {
			if(@handle = 0) {
				return Nil;
			};
			
			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			PIPE_IN_STRING;
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			PIPE_OUT_BYTE;
		}
		
		#~
		Writes bytes from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			PIPE_OUT_BYTE_ARY;
		}
		
		#~
		Writes characters from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			PIPE_OUT_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			PIPE_OUT_STRING;
		}
		
		#~
		Closes the stream
		~#
		method : public : Close() ~ Nil{
			PIPE_CLOSE;
		}
	}
 	
 	class ConsoleIO {
		@console : static : ConsoleIO;

		New : private () {
			Parent();
		}

		function : Instance() ~ ConsoleIO {
			if(@console <> Nil) {
				@console := ConsoleIO->New();
			};

			return @console;
		}

		method : public : ReadString() ~ System.String {
			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : public : SetIntFormat(format : Number->Format) ~ ConsoleIO {
			STD_INT_FMT;
			return @console;
		}

		method : public : SetFloatFormat(format : Number->Format) ~ ConsoleIO {
			STD_FLOAT_FMT;
			return @console;
		}

		method : public : SetFloatPrecision(precision : Int) ~ ConsoleIO {
			STD_FLOAT_PER;
			return @console;
		}

		method : public : SetWidth(width : Int) ~ ConsoleIO {
			STD_WIDTH;
			return @console;
		}

		method : public : SetFill(fill : Int) ~ ConsoleIO {
			STD_FILL;
			return @console;
		}
		
		method : public : Print(b : Bool) ~ ConsoleIO {
			b->Print();
			return @console;
		}
		
		method : public : PrintLine(b : Bool) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			STD_IN_STRING;
		}
		
		method : public : Print(b : Byte) ~ ConsoleIO {
			b->Print();
			return @console;
		}

		method : public : PrintLine(b : Byte) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}
		
		method : public : Print(c : Char) ~ ConsoleIO {
			c->Print();
			return @console;
		}

		method : public : PrintLine(c : Char) ~ ConsoleIO {
			c->PrintLine();
			return @console;
		}

		method : public : Print(i : Int) ~ ConsoleIO {
			i->Print();
			return @console;
		}

		method : public : PrintLine(i : Int) ~ ConsoleIO {
			i->PrintLine();
			return @console;
		}
		
		method : public : Print(f : Float) ~ ConsoleIO {
			f->Print();
			return @console;
		}

		method : public : PrintLine(f : Float) ~ ConsoleIO {
			f->PrintLine();
			return @console;
		}

		method : public : Print(cc : Char[]) ~ ConsoleIO {
			cc->Print();
			return @console;
		}

		method : public : PrintLine(cc : Char[]) ~ ConsoleIO {
			cc->PrintLine();
			return @console;
		}
		
		method : public : Print(s : System.String) ~ ConsoleIO {
			s->Print();
			return @console;
		}

		method : public : PrintLine(s : System.String) ~ ConsoleIO {
			s->PrintLine();
			return @console;
		}

		method : public : PrintLine() ~ ConsoleIO {
			"\r\n"->Print();
			return @console;
		}

		method : public : Flush() ~ ConsoleIO {
			STD_FLUSH;
			return @console;
		}

		method : public : FlushError() ~ ConsoleIO {
			STD_ERR_FLUSH;
			return @console;
		}
		
		method : public : Error(b : Bool) ~ ConsoleIO {
			b->Error();
			return @console;
		}
		
		method : public : ErrorLine(b : Bool) ~ ConsoleIO {
			b->ErrorLine();
			return @console;
		}

		method : public : Error(b : Byte) ~ ConsoleIO {
			b->Error();
			return @console;
		}

		method : public : ErrorLine(b : Byte) ~ ConsoleIO {
			b->ErrorLine();
			return @console;
		}
		
		method : public : Error(c : Char) ~ ConsoleIO {
			c->Error();
			return @console;
		}

		method : public : ErrorLine(c : Char) ~ ConsoleIO {
			c->ErrorLine();
			return @console;
		}

		method : public : Error(i : Int) ~ ConsoleIO {
			i->Error();
			return @console;
		}

		method : public : ErrorLine(i : Int) ~ ConsoleIO {
			i->ErrorLine();
			return @console;
		}
		
		method : public : Error(f : Float) ~ ConsoleIO {
			f->Error();
			return @console;
		}

		method : public : ErrorLine(f : Float) ~ ConsoleIO {
			f->ErrorLine();
			return @console;
		}

		method : public : Error(cc : Char[]) ~ ConsoleIO {
			cc->Error();
			return @console;
		}

		method : public : ErrorLine(cc : Char[]) ~ ConsoleIO {
			cc->ErrorLine();
			return @console;
		}
		
		method : public : Error(s : System.String) ~ ConsoleIO {
			s->Error();
			return @console;
		}

		method : public : ErrorLine(s : System.String) ~ ConsoleIO {
			s->ErrorLine();
			return @console;
		}

		method : public : ErrorLine() ~ ConsoleIO {
			"\r\n"->ErrorLine();
			return @console;
		}
		
		method : public : ErrorFlush() ~ ConsoleIO {
			STD_ERR_FLUSH;
			return @console;
		}
	}
	
	#~
	Used to serialize objects
	~#
	class Serializer  {
		@buffer : Byte[];
		@pos : Int;

		
		New() {
			Parent();
			@buffer := Byte->New[16];
			@pos := 0;
		}

		#~
		Serializes a value
		@param b value to serialize
		~#
		method : public : Write(b : Bool) ~ Nil {
			SERL_INT;
		}

		#~
		Serializes a value
		@param c value to serialize
		~#
		method : public : Write(c : Char) ~ Nil {
			SERL_CHAR;
		}
		
		#~
		Serializes a value
		@param i value to serialize
		~#
		method : public : Write(i : Int) ~ Nil {
			SERL_INT;
		}
		
		#~
		Serializes a value
		@param f value to serialize
		~#
		method : public : Write(f : Float) ~ Nil {
			SERL_FLOAT;
		}
		
		#~
		Serializes a base object
		@param o value to serialize
		~#
		method : public : Write(o : Base) ~ Nil {
			SERL_OBJ_INST;
		}

		#~
		Serializes a base object
		@param b value to serialize
		~#
		method : public : Write(b : Bool[]) ~ Nil {
			SERL_INT_ARY;
		}

		#~
		Serializes base objects
		@param o value to serialize
		~#
		method : public : Write(o : Base[]) ~ Nil {
			SERL_OBJ_ARY;
		}

		#~
		Serializes a value
		@param b value to serialize
		~#
		method : public : Write(b : Byte[]) ~ Nil {
			SERL_BYTE_ARY;
		}

		#~
		Serializes an array of values
		@param c value to serialize
		~#
		method : public : Write(c : Char[]) ~ Nil {
			SERL_CHAR_ARY;
		}

		#~
		Serializes an array of values
		@param i value to serialize
		~#
		method : public : Write(i : Int[]) ~ Nil {
			SERL_INT_ARY;
		}
		
		#~
		Serializes an array of values
		@param f value to serialize
		~#
		method : public : Write(f : Float[]) ~ Nil {
			SERL_FLOAT_ARY;
		}
		
		#~
		Create a byte stream of the objects that 
		have been serialized
		@return byte stream of the objects that have been serialized
		~#
		method : public : Serialize() ~ Byte[] {
			return Byte->CompressZlib(@buffer);
		}
	}
	
	#~
	Used to deserialize objects
	~#
	class Deserializer  {
		@buffer : Byte[];
		@pos : Int;
		
		#~
		Default constructor
		@param buffer input byte buffer to read from
		~#
		New(buffer : Byte[]) {
			Parent();
			@buffer := Byte->UncompressZlib(buffer);
			@pos := 0;
		}

		#~
		Reads a value
		@return value read
		~#
		method : public : ReadBool() ~ Bool {
			DESERL_INT;
		}

		#~
		Reads a value
		@return value read
		~#
		method : public : ReadChar() ~ Char {
			DESERL_CHAR;
		}

		#~
		Reads a value
		@return value read
		~#		
		method : public : ReadInt() ~ Int {
			DESERL_INT;
		}

		#~
		Reads a value
		@return value read
		~#		
		method : public : ReadFloat() ~ Float {
			DESERL_FLOAT;
		}
		
		#~
		Reads an object
		@return value read
		~#
		method : public : ReadObject() ~ Base {
			DESERL_OBJ_INST;
		}

		#~
		Reads an object array
		@return value read
		~#
		method : public : ReadObjectArray() ~ Base[] {
			DESERL_OBJ_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadBoolArray() ~ Bool[] {
			DESERL_INT_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadByteArray() ~ Byte[] {
			DESERL_BYTE_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadCharArray() ~ Char[] {
			DESERL_CHAR_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadIntArray() ~ Int[] {
			DESERL_INT_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#		
		method : public : ReadFloatArray() ~ Float[] {
			DESERL_FLOAT_ARY;
		}
	}
}

#~
Supports filesystem operations
~#
bundle System.IO.Filesystem {	
	#~
	Provides file operations
	~#
	class File {
		@handle : Int;
		@name : System.String;
		
		#~
		Default constructor
		@param name filename
		~#
		New(name : System.String) {
			Parent();
			@name := name;
		}
		
		#~
		Gets the filename
		@return filename
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Checks of the file is open
		@return true if the file was opened, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			FILE_IS_OPEN;
		}

		#~
		Seeks to a point in the file
		@param p seek offset
		@return true if operation was successful, false otherwise
		~#
		method : public : Seek(p : Int) ~ Bool {
			FILE_SEEK;
		}
		
		#~
		Rewinds the seek pointer
		~#
		method : public : Rewind() ~ Nil {
			FILE_REWIND;
		}

		#~
		Check if seek pointer is at the end-of-file
		@return true if at the end-of-file, false otherwise
		~#
		method : public : IsEoF() ~ Bool {
			FILE_EOF;
		}

		#~
		Flushes the file buffer
		~#
		method : public : Flush() ~ Nil {
			FILE_FLUSH;
		}

		#~
		Gets the full path name for file
		@param n filename
		@return full path name, Nil otherwise
		~#
		function : GetFullName(n : System.String) ~ System.String {
			FILE_FULL_PATH;
		}

		#~
		Gets the full path name for file
		@return full path name, Nil otherwise
		~#
		method : public : GetFullName() ~ System.String {
			return GetFullName(@name);;
		}

		#~
		Gets a temporary filename
		@return temporary filename
		~#
		function : GetTempName() ~ System.String {
			FILE_TEMP_NAME;
		}

		#~
		Returns the size of the file
		@param n filename
		@return size of the file
		~#
		function : Size(n : System.String) ~ Int {
			FILE_SIZE;
		}		

		#~
		Returns the size of the file
		@return size of the file
		~#
		method : public : Size() ~ Int {
			return Size(@name);
		}
		
		#~
		Returns the time in which the file was created
		@param n filename
		@return create date
		~#
		function : CreateTime(n : System.String) ~ Date {
			return CreateTime(n, false);
		}

		#~
		Returns the time in which the file was created
		@return create date
		~#
		method : public : CreateTime() ~ Date {
			return CreateTime(@name, false);
		}

		#~
		Returns the time in which the file was created
		@param n filename
		@param gmt true if GMT
		@return create date
		~#
		function : CreateTime(n : System.String, gmt : Bool) ~ Date {
			day : Int; 
			month : Int; 
			year : Int; 
			hours : Int; 
			mins : Int; 
			secs : Int; 

			FILE_CREATE_TIME;

			return Date->New(day, month, year, hours, mins, secs, gmt);
		}

		#~
		Returns the time in which the file was created
		@param gmt true if GMT
		@return create date
		~#
		method : public : CreateTime(gmt : Bool) ~ Date {	
			return CreateTime(@name, gmt);
		}

		#~
		Returns the time in which the file was modified 
		@param n filename
		@return modified date
		~#
		function : ModifiedTime(n : System.String) ~ Date {
			return ModifiedTime(n, false);
		}

		#~
		Returns the time in which the file was modified 
		@param n filename
		@param gmt true if GMT
		@return modified date
		~#
		function : ModifiedTime(n : System.String, gmt : Bool) ~ Date {
			day : Int; 
			month : Int; 
			year : Int; 
			hours : Int; 
			mins : Int; 
			secs : Int; 

			FILE_MODIFIED_TIME;

			return Date->New(day, month, year, hours, mins, secs, gmt);
		}		

		#~
		Returns the time in which the file was accessed 
		@param n filename
		@return accessed date
		~#
		function : AccessedTime(n : System.String) ~ Date {
			return AccessedTime(n, false);
		}

		#~
		Returns the time in which the file was accessed 
		@return accessed date
		~#
		method : public : AccessedTime() ~ Date {
			return AccessedTime(@name, false);
		}

		#~
		Returns the time in which the file was accessed 
		@param n filename
		@param gmt true if GMT
		@return accessed date
		~#
		function : AccessedTime(n : System.String, gmt : Bool) ~ Date {
			day : Int;
			month : Int;
			year : Int;
			hours : Int;
			mins : Int;
			secs : Int;
			
			FILE_ACCESSED_TIME;
			
			return Date->New(day, month, year, hours, mins, secs, gmt);
		}

		#~
		Returns the time in which the file was accessed 
		@param gmt true if GMT
		@return accessed date
		~#
		method : public : AccessedTime(gmt : Bool) ~ Date {
			return AccessedTime(@name, gmt);
		}
		
		#~
		Deletes the file
		@param n filename
		@return true if file was deleted, false otherwise
		~#
		function : Delete(n : System.String) ~ Bool {
			FILE_DELETE;
		}

		#~
		Deletes a file
		@return true if file was deleted
		~#
		method : public : Delete() ~ Bool {
			if(Delete(@name)) {
				@handle := 0;
				return true;
			};

			return false;
		}
		
		#~
		Gets the file owner name
		@param n filename
		@return file owner name
		~#
		function : Owner(n : System.String) ~ System.String {
			FILE_ACCOUNT_OWNER;
		}

		#~
		Gets the file owner name
		@return file owner name
		~#
		method : public : Owner() ~ System.String {
			return Owner(@name);
		}

		#~
		Gets the file group name
		@param n filename
		@return file group name
		~#
		function : Group(n : System.String) ~ System.String {
			FILE_GROUP_OWNER;
		}

		#~
		Gets the file group name
		@return file group name
		~#
		method : public : Group() ~ System.String {
			return Group(@name);
		}

		#~
		Checks if a file can be read-only
		@param n filename
		@return true if file can be read-only
		~#
		function : IsReadWrite(n : System.String) ~ Bool {
			FILE_CAN_READ_WRITE;
		}

		#~
		Checks if a file can be read-only
		@return true if file can be read-only
		~#
		method : public : IsReadWrite() ~ Bool {
			return IsReadWrite(@name);
		}

		#~
		Checks if a file can be read
		@param n filename
		@return true if file can be read
		~#
		function : IsReadOnly(n : System.String) ~ Bool {
			FILE_CAN_READ_ONLY;
		}

		#~
		Checks if a file can be read
		@return true if file can be read
		~#
		method : public : IsReadOnly() ~ Bool {
			return IsReadOnly(@name);
		}
		
		#~
		Checks if a file can be written
		@param n filename
		@return true if file can be written
		~#
		function : IsWriteOnly(n : System.String) ~ Bool {
			FILE_CAN_WRITE_ONLY;
		}

		#~
		Checks if a file can be written
		@return true if file can be written
		~#
		method : public : IsWriteOnly() ~ Bool {
			return IsWriteOnly(@name);
		}
		
		#~
		Checks if a file exists
		@param n filename
		@return true if file exists
		~#
		function : Exists(n : System.String) ~ Bool {
			FILE_EXISTS;
		}

		#~
		Checks if a file exists
		@return true if file exists
		~#
		method : public : Exists() ~ Bool {
			return Exists(@name);
		}
		
		#~
		Renames a file
		@param o original filename
		@param n new filename
		@return true if file was renamed
		~#
		function : Rename(o : System.String, n : System.String) ~ Bool {
			FILE_RENAME;
		}

		#~
		Copies a file
		@param s source filename
		@param d destination filename
		@return true if file was copied
		~#
		function : Copy(s : System.String, d : System.String) ~ Bool {
			return Copy(s, d, false);
		}

		#~
		Copies a file
		@param s source filename
		@param d destination filename
		@param o true to overwrite existing file, false otherwise
		@return true if file was copied
		~#
		function : Copy(s : System.String, d : System.String, o : Bool) ~ Bool {
			FILE_COPY;
		}
	}

	#~
	Supports file read operations
	~#
	class FileReader from File implements System.IO.InputStream {
		#~
		Default constructor.
		@param name filename
		~#
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_READ;
		}	

		#~
		Closes the file
		~#
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			FILE_IN_BYTE;
		}

		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_IN_CHAR_ARY;
		}

		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_IN_BYTE_ARY;
		}

		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadLine() ~ System.String {
			if(IsEoF()) {
				return Nil;
			};

			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			FILE_IN_STRING;
		}
		
		#~
		Reads a file's contents into a string
		@param name filename
		@return character string, Nil if file is not found
		~#
		function : ReadFile(name : String) ~ String {
			len := File->Size(name);
			if(len > 0) {
				buffer := Char->New[len + 1];
				input := FileReader->New(name);
				if(input->IsOpen()) {
					input->ReadBuffer(0, len, buffer);
					input->Close();
					
					return String->New(buffer);
				};
			};
	
			return Nil;
		}
		
		#~
		Reads a file's contents into byte array
		@param name filename
		@return byte array, Nil if file is not found
		~#
		function : ReadBinaryFile(name : String) ~ Byte[] {
			len := File->Size(name);
			buffer := Byte->New[len];
			input := FileReader->New(name);
			if(input->IsOpen()) {
				input->ReadBuffer(0, len, buffer);
				input->Close();
				
				return buffer;
			};
			
			return Nil;
		}
	}
	
	#~
	Supports file write operations
	~#
	class FileWriter from File implements System.IO.OutputStream {
		#~
		Opens a new file.
		@param name filename
		~#
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_WRITE;
		}	
		
		#~
		Opens a new file or appends to an existing one.
		@param name filename
		@param append if true, opens a file for appending otherwise creates a new file
		~#
		New(name : System.String, append : Bool) {
			Parent(name);
			if(append) {
				FILE_OPEN_APPEND;
			}
			else {
				FILE_OPEN_WRITE;
			};
		}

		#~
		Creates a temporary file
		~#
		function : Temp() ~ FileWriter {
			return System.IO.Filesystem.FileWriter->New(GetTempName());
		}

		#~
		Write string to file
		@param name filename
		@param content string to write
		@return true if successful, false otherwise
		~#
		function : WriteFile(name : String, content : String) ~ Bool {
			writer : FileWriter := FileWriter->New(name);
			if(writer->IsOpen()) {
				writer->WriteString(content);
				writer->Close();				
				return true;
			};

			return false;
		}

		#~
		Write bytes to file
		@param name filename
		@param content to write
		@return true if successful, false otherwise
		~#
		function : WriteFile(name : String, content : Byte[]) ~ Bool {
			writer : FileWriter := FileWriter->New(name);
			if(writer->IsOpen()) {
				writer->WriteBuffer(content);
				writer->Close();				
				return true;
			};

			return false;
		}
		
		#~
		Closes a file
		~#
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			FILE_OUT_BYTE;
		}

		#~
		Writes bytes from a buffer
		@param buffer output buffer
		@return true if successful, false otherwise
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);	
		}

		#~
		Writes bytes from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer output buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_OUT_BYTE_ARY;
		}
		
		#~
		Writes characters from a buffer
		@param buffer output buffer
		@return true if successful, false otherwise
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);	
		}

		#~
		Writes characters from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_OUT_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			FILE_OUT_STRING;
		}
	}
	
	#~
	Supports file read and write operations
	~#
	class FileReaderWriter from File implements System.IO.InputStream, System.IO.OutputStream {
		#~
		Default constructor.
		@param name filename
		~#
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_READ_WRITE;
		}	

		#~
		Closes the file
		~#
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			FILE_IN_BYTE;
		}

		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_IN_CHAR_ARY;
		}

		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_IN_BYTE_ARY;
		}

		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadLine() ~ System.String {
			if(IsEoF()) {
				return Nil;
			};

			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			FILE_IN_STRING;
		}
		
		#~
		Reads a file's contents into a string
		@param name filename
		@return character string, Nil if file is not found
		~#
		function : ReadFile(name : String) ~ String {
			len := File->Size(name);
			if(len > 0) {
				buffer := Char->New[len + 1];
				input := FileReader->New(name);
				if(input->IsOpen()) {
					input->ReadBuffer(0, len, buffer);
					input->Close();
					
					return String->New(buffer);
				};
			};
	
			return Nil;
		}
		
		#~
		Reads a file's contents into byte array
		@param name filename
		@return byte array, Nil if file is not found
		~#
		function : ReadBinaryFile(name : String) ~ Byte[] {
			len := File->Size(name);
			buffer := Byte->New[len];
			input := FileReader->New(name);
			if(input->IsOpen()) {
				input->ReadBuffer(0, len, buffer);
				input->Close();
				
				return buffer;
			};
			
			return Nil;
		}
		
		#~
		Creates a temporary file
		~#
		function : Temp() ~ FileWriter {
			return System.IO.Filesystem.FileWriter->New(GetTempName());
		}

		#~
		Write string to file
		@param name filename
		@param content string to write
		@return true if successful, false otherwise
		~#
		function : WriteFile(name : String, content : String) ~ Bool {
			writer : FileWriter := FileWriter->New(name);
			if(writer->IsOpen()) {
				writer->WriteString(content);
				writer->Close();				
				return true;
			};

			return false;
		}

		#~
		Write bytes to file
		@param name filename
		@param content to write
		@return true if successful, false otherwise
		~#
		function : WriteFile(name : String, content : Byte[]) ~ Bool {
			writer : FileWriter := FileWriter->New(name);
			if(writer->IsOpen()) {
				writer->WriteBuffer(content);
				writer->Close();				
				return true;
			};

			return false;
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			FILE_OUT_BYTE;
		}

		#~
		Writes bytes from a buffer
		@param buffer output buffer
		@return true if successful, false otherwise
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);	
		}

		#~
		Writes bytes from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer output buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_OUT_BYTE_ARY;
		}
		
		#~
		Writes characters from a buffer
		@param buffer output buffer
		@return true if successful, false otherwise
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);	
		}

		#~
		Writes characters from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_OUT_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			FILE_OUT_STRING;
		}
	}

	#~
	Logs messages to temporary files
	~#
	class Logger {
		@instance : static : Logger;
		
		@directory : String;

		@info_mutex : ThreadMutex;
		@info_file : String;

		@warn_mutex : ThreadMutex;
		@warn_file : String;

		@err_mutex : ThreadMutex;
		@err_file : String;
		
		New : private () {
			Parent();		
			@directory := Runtime->GetTempDir()->ReplaceAll("\\", "/");

			@info_file := "";
			@info_file->Append(@directory);
			if(<>@info_file->EndsWith('/')) {
				@info_file->Append('/');
			};
			@info_file->Append("objk-info-");
			@info_file->Append(RandomPrefix());
			@info_file->Append(".log");
			@info_mutex := ThreadMutex->New("info-log");

			@warn_file := "";
			@warn_file->Append(@directory);
			if(<>@warn_file->EndsWith('/')) {
				@warn_file->Append('/');
			};
			@warn_file->Append("objk-warn-");
			@warn_file->Append(RandomPrefix());
			@warn_file->Append(".log");
			@warn_mutex := ThreadMutex->New("warn-log");

			@err_file := "";
			@err_file->Append(@directory);
			@err_file->Append("/objk-err-");
			@err_file->Append(RandomPrefix());
			@err_file->Append(".log");
			@err_mutex := ThreadMutex->New("err-log");
		}

		method : RandomPrefix() ~ String {
			str := "";

			each(i : 8) {
				if(Int->Random(10) % 2 = 0) {
					str->Append(Int->Random('a', 'z')->As(Char));
				}
				else {
					str->Append(Int->Random('0', '9')->As(Char));
				};
			};

			return str;
		}

		#~
		Gets an instance of the logger
		@return logger instance
		~#
		function : Instance() ~ Logger {
			if(@instance = Nil) {
				@instance := Logger->New();
			};

			return @instance;
		}

		#~
		Logs an informational message
		@param message message to log
		@return true if message is logged, false otherwise
		~#
		method : public : Info(message : String) ~ Bool {
			critical(@info_mutex) {
				out := FileWriter->New(@info_file, true);
				if(out <> Nil) {
					header := "[";
					header->Append(Date->New()->ToShortString());
					header->Append("]: ");
					header->Append(message);
					header->Append("\r\n");
					out->WriteString(header);
				}
				else {
					return false;
				};
				out->Close();
			};			
			
			return true;
		}

		#~
		Logs a warning message
		@param message message to log
		@return true if message is logged, false otherwise
		~#
		method : public : Warn(message : String) ~ Bool {
			critical(@warn_mutex) {
				out := FileWriter->New(@warn_file, true);
				if(out <> Nil) {
					header := "[";
					header->Append(Date->New()->ToShortString());
					header->Append("]: ");
					header->Append(message);
					header->Append("\r\n");
					out->WriteString(header);
				}
				else {
					return false;
				};
				out->Close();
			};			
			
			return true;
		}

		#~
		Logs an error message
		@param message message to log
		@return true if message is logged, false otherwise
		~#
		method : public : Error(message : String) ~ Bool {
			critical(@err_mutex) {
				out := FileWriter->New(@err_file, true);
				if(out <> Nil) {
					header := "[";
					header->Append(Date->New()->ToShortString());
					header->Append("]: ");
					header->Append(message);
					header->Append("\r\n");
					out->WriteString(header);
				}
				else {
					return false;
				};
				out->Close();
			};			
			
			return true;
		}

		#~
		Clears the info log file
		@return true if message is logged, false otherwise
		~#
		method : public : ClearInfo() ~ Nil {
			critical(@info_mutex) {
				File->Delete(@info_file);
			};
		}

		#~
		Clears the warning log file
		@return true if message is logged, false otherwise
		~#
		method : public : ClearWarn() ~ Nil {
			critical(@warn_mutex) {
				File->Delete(@warn_file);
			};
		}

		#~
		Clears the error log file
		@return true if message is logged, false otherwise
		~#
		method : public : ClearError() ~ Nil {
			critical(@err_mutex) {
				File->Delete(@err_file);
			};
		}

		#~
		Gets the logging directory
		@return logging directory
		~#
		method : public : GetDirectory() ~ String {
			return @directory;
		}

		#~
		Gets path to warning file
		@return path to warning file
		~#
		method : public : GetWarnFile() ~ String {
			return @warn_file;
		}

		#~
		Gets path to information file
		@return path to information file
		~#
		method : public : GetInfoFile() ~ String {
			return @info_file;
		}

		#~
		Gets path to error file
		@return path to error file
		~#
		method : public : GetErrorFile() ~ String {
			return @err_file;
		}
	}

	#~
	Provides directory operations
	~#
	class Directory {
		#~
		Renames a directory
		@param o original directory
		@param n new directory
		@return true if directory was renamed
		~#
		function : Rename(o : System.String, n : System.String) ~ Bool {
			if(System.IO.Filesystem.Directory->Exists(o)) {
				return System.IO.Filesystem.File->Rename(o, n);
			};

			return false;
		}

		#~
		Copies a directory
		@param s source directory
		@param d destination directory
		@return true if file was copied
		~#
		function : Copy(s : System.String, d : System.String) ~ Bool {
			return Copy(s, d, false);
		}

		#~
		Copies a directory
		@param s source directory
		@param d destination directory
		@param r recursive copy
		@return true if file was copied
		~#
		function : Copy(s : System.String, d : System.String, r : Bool) ~ Bool {
			DIR_COPY;
		}

		#~
		Creates a directory
		@param n directory name
		@return true if directory was created 
		~#
		function : Create(n : System.String) ~ Bool {
			DIR_CREATE;
		}

		#~
		Returns the system's temporary directory
		@return system's temporary directory
		~#
		function : GetTemp() ~ String {
			return Runtime->GetProperty("tmp_dir");
		}

		#~
		Returns the current user's working directory
		@return current user's working directory
		~#
		function : GetUser() ~ String {
			return Runtime->GetProperty("user_dir");
		}

		#~
		Returns the current working directory
		@return current working directory
		~#
		function : GetWorking() ~ String {
			DIR_GET_CUR;
		}

		#~
		Sets the current working directory
		@param name name of directory
		@return true if successful, false otherwise
		~#
		function : SetWorking(name : String) ~ Bool {
			DIR_SET_CUR;
		}
		
		#~
		Returns the installation directory
		@return installation directory
		~#
		function : GetInstall() ~ String {
			return Runtime->GetProperty("install_dir");
		}

		#~
		Gets the native directory slash
		@return native directory slash
		~#
		function : GetSlash() ~ Char {
			DIR_SLASH;
		}
		
		#~
		Creates a directory path
		@param n directory path name
		@return true if directory path was created 
		~#
		function : CreatePath(n : String) ~ Bool {	
			sub_dirs := n->Split("/");
			if(sub_dirs->Size() = 0) {
				sub_dirs := n->Split("\\");
			};		
			
			if(sub_dirs->Size() > 0) {
				is_okay := true;
				
				i := 0;
				path := "";
				if(sub_dirs->Size() > 1 & (sub_dirs[0]->Has(':') | sub_dirs[0]->IsEmpty())) {
					sub_dir := sub_dirs[0];
					sub_dir->Append('/');
					sub_dir->Append(sub_dirs[1]);
					
					is_okay := Exists(sub_dir);
					if(<>is_okay) {
						is_okay := Create(sub_dir);
					};
					path->Append(sub_dir);
					path->Append('/');
					i := 2;
				};
				
				for(j := i; j < sub_dirs->Size() & is_okay; j += 1;) {
					path->Append(sub_dirs[j]);
					path->Append('/');
					
					is_okay := Exists(path);
					if(<>is_okay) {
						is_okay := Create(path);
					};
				};
				
				return is_okay;
			};
			
			return false;
		}
		
		#~
		Checks to see if the given directory exists
		@param n directory name
		@return true if directory exists
		~#
		function : Exists(n : System.String) ~ Bool {
			DIR_EXISTS;
		}
		
		#~
		List of directory content
		@param n directory name
		@return list of directory content
		~#
		function : List(n : System.String) ~ System.String[] {
			DIR_LIST;
		}

		#~
		Deletes the directory and all sub-directories
		@param n directory
		@return number of files and directories deleted, 0 if directory was not present
		~#
		function : Delete(n : System.String) ~ Int {
			DIR_DELETE;
		}
	}

	#~
	Provides hard link filesystem operations
	~#
	class HardLink {
		#~
		Creates a hard link
		@param l link path name
		@param t target path name
		@return true if hard link was created 
		~#
		function : Create(l : System.String, t : System.String) ~ Bool {
			HARD_LINK_CREATE;
		}

		#~
		Deletes the hard link
		@param n path to hard link
		@return true if file was deleted, false otherwise
		~#
		function : Delete(n : System.String) ~ Bool {
			FILE_DELETE;
		}
	}

	#~
	Provides symbolic link filesystem operations
	~#
	class SymbolicLink {
		#~
		Creates a symbolic link
		@param l link path name
		@param t target path name
		@return true if symbolic link was created 
		~#
		function : Create(l : System.String, t : System.String) ~ Bool {
			SYM_LINK_CREATE;
		}

		#~
		Copies a symbolic link
		@param s source symbolic link
		@param d destination symbolic link
		@return true if link was copied
		~#
		function : Copy(s : System.String, d : System.String) ~ Bool {
			SYM_LINK_COPY;
		}

		#~
		Returns the path location that the symbolic link refers to
		@param n symbolic link path
		@return path the symbolic link refers to
		~#
		function : Location(n : System.String) ~ Bool {
			SYM_LINK_LOC;
		}

		#~
		Checks to see if the given symbolic link exists
		@param n symbolic link name
		@return true if symbolic link exists
		~#
		function : Exists(n : System.String) ~ Bool {
			SYM_LINK_EXISTS;
		}

		#~
		Deletes the symbolic link
		@param n path to symbolic link
		@return true if file was deleted, false otherwise
		~#
		function : Delete(n : System.String) ~ Bool {
			FILE_DELETE;
		}
	}
}

#~
Provides network support
~#
bundle System.IO.Net {
	#~
	TCP/IP socket
	~#
	class TCPSocket implements System.IO.InputStream, System.IO.OutputStream {
		@handle : Int;
		@address : System.String;
		@port : Int;
		
		#~
		Default constructor
		@param address network address
		@param port network port
		~#
		New(address : System.String, port : Int) {
			Parent();
			@address := address;
			@port := port;
			SOCK_TCP_CONNECT;
		}

		#~
		Returns the connected network address
		@return return network address
		~#
		method : public : GetAddress() ~ String {
			return @address;
		}
		
		#~
		Returns the connected network port
		@return return network port
		~#
		method : public : GetPort() ~ Int {
			return @port;
		}

		#~
		Returns rather the socket is open
		@return true if socket is open, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			SOCK_TCP_IS_CONNECTED;
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_OUT_BYTE;
		}

		#~
		Checks if read/write data is available
		@return true if data is available, false otherwise
		~#
		method : public : Select(is_write : Bool) ~ Bool {
			SOCK_TCP_SELECT;
		}
		
		#~
		Writes bytes from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}

		#~
		Writes bytes from a byte buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_OUT_BYTE_ARY;
		}

		#~
		Writes characters from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_OUT_CHAR_ARY;
		}
		
		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_IN_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_OUT_STRING;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadLine() ~ System.String {
			if(<>IsOpen()) {
				return Nil;
			};

			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_IN_STRING;
		}

		#~
		Reads the host name
		@return socket host name
		~#
		function : HostName() ~  System.String {
			SOCK_TCP_HOST_NAME;
		}

		#~
		List of resolved IP addresses
		@param n address name
		@return list of IP addresses
		~#
		function : Resolve(n : System.String) ~ System.String[] {
			SOCK_TCP_RESOLVE_NAME;
		}
	
		#~
		Flushes the output buffer. This is a no-opt given
		this socket is not backed by an output buffer.
		~#
		method : public : Flush() ~ Nil {}
		
		#~
		Closes the socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}

		#~
		Get the last error
		@return last error message, or Nil of no error
		~#
		function : GetLastError() ~ String {
			SOCK_IP_ERROR;
		}
	}
	
	#~
	Secure SSL TCP/IP socket
	~#
	class TCPSecureSocket implements System.IO.InputStream, System.IO.OutputStream {
		@ctx : Int;
		@bio : Int;
		@cert : Int;
		@is_open : Bool;
		@address : System.String;
		@port : Int;
		@pem : String;

		#~
		Default constructor
		@param address network address
		@param port network port
		@param pem the Privacy Enhanced Mail file (optional)		
		~#
		New(address : System.String, port : Int, pem : String := Nil) {
			Parent();
			@address := address;
			@port := port;
			@pem := pem;

			SOCK_TCP_SSL_CONNECT;
		}

		#~
		Returns the connected network address
		@return return network address
		~#
		method : public : GetAddress() ~ String {
			return @address;
		}

		#~
		Gets the X.509 certificate issuer name
		@return certificate issuer name
		~#
		method : public : GetIssuer() ~ String {
			SOCK_TCP_SSL_ISSUER;
		}

		#~
		Gets the X.509 certificate subject name
		@return certificate subject name
		~#
		method : public : GetSubject() ~ String {
			SOCK_TCP_SSL_SUBJECT;
		}

		#~
		Checks if read/write data is available
		@return true if data is available, false otherwise
		~#
		method : public : Select(is_write : Bool) ~ Bool {
			SOCK_TCP_SSL_SELECT;
		}
		
		#~
		Returns the connected network port
		@return return network port
		~#
		method : public : GetPort() ~ Int {
			return @port;
		}

		#~
		Returns rather the socket is open
		@return true if socket is open, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			return @is_open;		
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_SSL_OUT_BYTE;
		}
		
		#~
		Writes bytes from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}

		#~
		Writes bytes from a byte buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_SSL_OUT_BYTE_ARY;
		}

		#~
		Writes characters from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_SSL_OUT_CHAR_ARY;
		}
		
		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_SSL_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_SSL_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_SSL_IN_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_SSL_OUT_STRING;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : native : ReadLine() ~ System.String {
			if(<>IsOpen()) {
				return Nil;
			};

			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_SSL_IN_STRING;
		}

		#~
		Flushes the output buffer. This is a no-opt given
		this socket is not backed by an output buffer.
		~#
		method : public : Flush() ~ Nil {}

		#~
		Get the last error
		@return last error message, or Nil of no error
		~#
		function : GetLastError() ~ String {
			SOCK_TCP_SSL_ERROR;
		}

		#~
		Closes the socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_SSL_CLOSE;
		}
	}

	#~
	UDP/IP socket
	~#
	class UDPSocket implements System.IO.InputStream, System.IO.OutputStream {
		@sock : Int;
		@addr : Int;
		@address : System.String;
		@port : Int;
		
		#~
		Default constructor
		@param address network address
		@param port network port
		~#
		New(address : System.String, port : Int) {
			Parent();
			@address := address;
			@port := port;
			SOCK_UDP_CREATE;
		}

		#~
		Returns the connected network address
		@return return network address
		~#
		method : public : GetAddress() ~ String {
			return @address;
		}
		
		#~
		Returns the connected network port
		@return return network port
		~#
		method : public : GetPort() ~ Int {
			return @port;
		}

		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_UDP_OUT_BYTE;
		}
		
		#~
		Writes bytes from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}

		#~
		Writes bytes from a byte buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_UDP_OUT_BYTE_ARY;
		}

		#~
		Writes characters from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_UDP_OUT_CHAR_ARY;
		}
		
		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			SOCK_UDP_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_UDP_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_UDP_IN_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_UDP_OUT_STRING;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadLine() ~ System.String {
			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_UDP_IN_STRING;
		}
	
		#~
		Flushes the output buffer. This is a no-opt given
		this socket is not backed by an output buffer.
		~#
		method : public : Flush() ~ Nil {}
		
		#~
		Closes the socket
		~#
		method : public : Close() ~ Nil {
			SOCK_UDP_CLOSE;
		}

		#~
		Get the last error
		@return last error message, or Nil of no error
		~#
		function : GetLastError() ~ String {
			SOCK_IP_ERROR;
		}
	}
	
	#~
	TCP/IP Server socket
	~#
	class TCPSocketServer {
		@handle : Int;
		@port : Int;

		#~
		Default constructor
		@param port server port
		~#
		New(port : Int) {
		  Parent();
		  @port := port;
		  SOCK_TCP_BIND;
		}
	
		#~
		Listens for incoming client connections
		@param backlog maximum length to queue pending connections
		@return true if client successfully connects, false otherwise
		~#
		method : public : Listen(backlog : Int) ~ Bool {
			SOCK_TCP_LISTEN;
		}
	
		#~
		Accepts a client connection
		@return client socket interface
		~#
		method : public : Accept() ~ TCPSocket {
			SOCK_TCP_ACCEPT;
		}
	
		#~
		Closes the server socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}

		#~
		Get the last error
		@return last error message, or Nil of no error
		~#
		function : GetLastError() ~ String {
			SOCK_IP_ERROR;
		}
	}

	#~
	Secure TCP/IP Server socket
	~#
	class TCPSecureSocketServer {
		@server : Int;
		@bio : Int;
		@ctx : Int;
		@cert : String;
		@key : String;
		@passwd : String;
		@port : Int;

		#~
		Default constructor
		@param cert path to ssl cert
		@param key path to ssl key
		@param passwd private key password
		@param port server port
		~#
		New(cert : String, key : String, passwd : String, port : Int) {
		  Parent();
		  @cert := cert;
		  @key := key;
		  @passwd := passwd;
		  @port := port;
		}
	
		#~
		Listens for incoming client connections
		@return true if client successfully connects, false otherwise
		~#
		method : public : Listen() ~ Bool {
			SOCK_TCP_SSL_LISTEN;
		}
	
		#~
		Accepts a client connection
		@return client socket interface
		~#
		method : public : Accept() ~ TCPSecureSocket {
			SOCK_TCP_SSL_ACCEPT;
		}

		#~
		Gets the X.509 certificate's issuer name
		@return certificate issuer name
		~#
		method : public : GetIssuer() ~ String {
			SOCK_TCP_SSL_ISSUER;
		}

		#~
		Gets the X.509 certificate subject name
		@return certificate subject name
		~#
		method : public : GetSubject() ~ String {
			SOCK_TCP_SSL_SUBJECT;
		}

		#~
		Get the last error
		@return last error message, or Nil of no error
		~#
		function : GetLastError() ~ String {
			SOCK_TCP_SSL_ERROR;
		}
		
		#~
		Closes the server socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_SSL_SRV_CLOSE;
		}
	}

	#~
	UDP/IP Server socket
	~#
	class UDPSocketServer {
		@sock : Int;
		@addr : Int;
		@port : Int;

		#~
		Default constructor
		@param port server port
		@param bind bind to port on creation, default is true
		~#
		New(port : Int, bind : Bool := true) {
		  Parent();
		  @port := port;

		  if(bind) {
		  	Bind();
		  };
		}
	
		#~
		Binds the UDP server socket
		@return true if successfully bound, false otherwise
		~#
		method : public : Bind() ~ Bool {
			if(<>IsBound()) {
				SOCK_UDP_BIND;
			};
		}

		#~
		Checks if the UDP server socket is bound
		@return true if successfully bound, false otherwise
		~#
		method : public : IsBound() ~ Bool {
			return @sock > -1 & @addr <> 0;
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_UDP_OUT_BYTE;
		}
		
		#~
		Writes bytes from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}

		#~
		Writes bytes from a byte buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_UDP_OUT_BYTE_ARY;
		}

		#~
		Writes characters from a byte buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_UDP_OUT_CHAR_ARY;
		}
		
		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			SOCK_UDP_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_UDP_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_UDP_IN_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_UDP_OUT_STRING;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadLine() ~ System.String {
			buffer : Char[] := Char->New[8192];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_UDP_IN_STRING;
		}
	
		#~
		Flushes the output buffer. This is a no-opt given
		this socket is not backed by an output buffer.
		~#
		method : public : Flush() ~ Nil {}
		
		#~
		Closes the server socket
		~#
		method : public : Close() ~ Nil {
			SOCK_UDP_CLOSE;
		}

		#~
		Get the last error
		@return last error message, or Nil of no error
		~#
		function : GetLastError() ~ String {
			SOCK_IP_ERROR;
		}
	}
}

#~
Allow programmers to introspect the runtime elements
~#
bundle System.Introspection {
	#~
	Represents a runtime class
	~#
	class Class {
		@name : String;
		@methods : Method[];
	
		#~
		Creates an instance of the given class. The class must have a 
		zero-parameter constructor to support this operation.
		@param name class type name
		@return newly instantiated object instance
		~#
		function : Instance(name : System.String) ~ System.Base {
			LOAD_NEW_OBJ_INST;
		}
	
		#~
		Checks rather the class has been loaded
		@return returns true if the class has been loaded, false otherwise
		~#
		method : public : IsLoaded() ~ Bool {
			return @methods <> Nil;
		}
		
		#~
		Returns the type name of the class
		@return type name of the class
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns an array of associated methods
		@return array of associated methods
		~#
		method : public : GetMethods() ~ Method[] {
			return @methods;
		}
		
		#~
		Returns the number of methods associated 
		with the class
		@return number of methods associated with the class
		~#
		method : public : GetMethodNumber() ~ Int {
			if(@methods <> Nil) {
				return @methods->Size();
			};

			return 0;
		}
	}
	
	#~
	Represents a runtime method or function
	~#
	class Method {
		@native_mthd_ptr : Int;
		@cls : Class;
		@name : String;
		@parameters : DataType[];
		@rtrn_type  : DataType;
	
		#~
		Returns the class associated with this method
		@return associated class
		~#
		method : public : GetClass() ~ Class {
			return @cls;
		}

		#~
		Returns the name of the method
		@return name of the method
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns an array of method parameters
		@return array of method parameters
		~#
		method : public : GetParameters() ~ DataType[] {
			return @parameters;
		}
		
		#~
		Returns the method's return type
		@return method's return type
		~#
		method : public : GetReturn() ~ DataType {
			return @rtrn_type;
		}
	}
	
	#~
	Represents a runtime data type
	~#
	class DataType {
		#~
		Data type types<br/>
		<p><pre>DataType->TypeId</pre></p>
		@class DataType
		~#
		enum TypeId := -60 {
			BOOL,
			BYTE,
			CHAR,
			INT,
			FLOAT,
			CLASS,
			FUNC
		}

		@type  : DataType->TypeId;
		@cls_name : String;
		@dimension : Int;
		
		#~
		Returns the data type's type
		@return data type's type
		~#
		method : public : GetType() ~ DataType->TypeId {
			return @type;
		}
		
		#~
		Returns array dimension size of the data type. Will
		return 0 if type is a scalar
		@return array dimension size of the data type
		~#
		method : public : GetDimension() ~ Int {
			return @dimension;
		}
		
		#~
		Returns array the class type name
		@return class type name
		~#
		method : public : GetClassName() ~ String {
			return @cls_name;
		}
	}
}
