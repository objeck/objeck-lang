#~~
# Json parsing library
# Copyright (c) 2012-2024
# Music: Hustler's Ambition
~~#

use Collection;

#~
Support for parsing JSON strings and documents (-lib json.obl)
~#
bundle Data.JSON {
	#~
	Stack driven JSON builder

	```
builder := JsonBuilder->New();
money := builder->PushObject();

money->Insert("type", "usd");
money->Insert("amount", "1013");

deposits := JsonElement->New(JsonElement->JsonType->ARRAY);
deposits->Add(115);
deposits->Add(318);
deposits->Add(580);
money->Insert("deposits", deposits);

builder->Pop()->ToString()->PrintLine();
	```
	~#
	class JsonBuilder {
		@stack : Stack<JsonElement>;

		#~
		Constructor
		~#
		New() {
			@stack := Stack->New()<JsonElement>;
		}

		#~
		Size of element stack
		~#
		method : public : Size() ~ Int {
			return @stack->Size();
		}

		#~
		Pushes an object element on the stack
		~#
		method : public : PushObject() ~ JsonBuilder {
			if(@stack->IsEmpty()) {
				@stack->Push(JsonElement->New(JsonType->OBJECT));
			}
			else if(@stack->Top()->GetType() = JsonType->ARRAY) {
				elem := JsonElement->New(JsonType->OBJECT);
				@stack->Top()->Add(elem);
				@stack->Push(elem);
			};

			return @self;
		}

		#~
		Pushes an object element on the stack
		@param name object name
		~#
		method : public : PushObject(name : String) ~ JsonBuilder {
			if(@stack->IsEmpty()) {
				@stack->Push(JsonElement->New(JsonType->OBJECT, name));
			}
			else if(@stack->Top()->GetType() = JsonType->ARRAY) {
				elem := JsonElement->New(JsonType->OBJECT);
				@stack->Top()->Add(elem);
				@stack->Push(elem);
			}
			else if(@stack->Top()->GetType() = JsonType->OBJECT) {
				elem := @stack->Top()->AddChild(name);
				@stack->Top()->Add(elem);
				@stack->Push(elem);
			};

			return @self;
		}

		#~
		Pushes an array element on the stack
		~#
		method : public : PushArray() ~ JsonBuilder {
			if(@stack->IsEmpty()) {
				@stack->Push(JsonElement->New(JsonType->ARRAY));
			}
			else {
				elem := JsonElement->New(JsonType->ARRAY);
				@stack->Top()->Add(elem);
				@stack->Push(elem);
			};

			return @self;
		}

		#~
		Pops a value
		@return popped element
		~#
		method : public : Pop() ~ JsonElement {
			if(@stack->IsEmpty()) {
				return Nil;
			};

			elem := @stack->Top();
			@stack->Pop();
			return elem;
		}

		#~
		Pop all values
		@return last popped element
		~#
		method : public : PopAll() ~ JsonElement {
			if(@stack->IsEmpty()) {
				return Nil;
			};

			while(@stack->Size() <> 1) {
				@stack->Pop();
			};

			elem := @stack->Top();
			@stack->Pop();
			return elem;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : String) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->ARRAY) {
				return Nil;
			};

			@stack->Top()->Add(value);
			return @self;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : Int) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->ARRAY) {
				return Nil;
			};

			@stack->Top()->Add(value);
			return @self;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : Float) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->ARRAY) {
				return Nil;
			};

			@stack->Top()->Add(value);
			return @self;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : Bool) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->ARRAY) {
				return Nil;
			};

			@stack->Top()->Add(value);
			return @self;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : JsonElement) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->ARRAY) {
				return Nil;
			};

			@stack->Top()->Add(value);
			return @self;
		}

		#~
		Insert an element
		@param name element name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : Int) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->OBJECT) {
				return Nil;
			};

			@stack->Top()->Insert(name, value);
			return @self;
		}

		#~
		Insert an element
		@param name element name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : Float) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->OBJECT) {
				return Nil;
			};
			
			@stack->Top()->Insert(name, value);
			return @self;
		}

		#~
		Insert an element
		@param name element name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : String) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->OBJECT) {
				return Nil;
			};
			
			@stack->Top()->Insert(name, value);
			return @self;
		}

		#~
		Insert an element
		@param name element name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : Bool) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->OBJECT) {
				return Nil;
			};
			
			@stack->Top()->Insert(name, value);
			return @self;
		}

		#~
		Insert an element
		@param name element name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : JsonElement) ~ JsonBuilder {
			if(@stack->IsEmpty() | @stack->Top()->GetType() <> JsonType->OBJECT) {
				return Nil;
			};
			
			@stack->Top()->Insert(name, value);
			return @self;
		}
	}

	#~
	Support for JSON parsing

	```
doc := Web.HTTP.HttpsClient->QuickGet(Web.HTTP.Url->New("https://dummyjson.com/carts"));
if(doc <> Nil) {
   parser := Data.JSON.JsonParser->New(String->New(doc));
   if(parser->Parse()) {
      carts := parser->GetRoot()->Get("carts");
      if(carts->Size() > 0) {
         cart := carts->Get(Int->Random(carts->Size()));
         cart_id := cart->Get("id")->GetInt();
         "cart id={$cart_id}\n---"->PrintLine();
         products := cart->Get("products");
         each(product := products) {
            product_id := product->Get("id")->GetInt();
            product_title := product->Get("title")->GetString();
            "\tid={$product_id}, title: '{$product_title}'"->PrintLine();
         };
      };
   };
};
	```
	~#
	class JsonParser {
		@input : Char[];
		@input_index : Int;

		@tokens : Token[];
		@cur_token : Token;
		@token_read_pos : Int;
		@token_write_pos : Int;
		@tokens_max : Int;

		@root : JsonElement;
		@error_msg : String;
		
		#~
		Constructor
		@param stream_in JSON string to process
		~#
		New(stream_in : String) {
			@input := stream_in->Trim()->ToCharArray();
			@input_index := 0;

			@tokens_max := 32;
			@tokens := Token->New[@tokens_max];
		}

		#~
		Constructor
		@param stream_in JSON character stream
		~#
		New(stream_in : Char[]) {
			@input := stream_in->ToString()->Trim()->ToCharArray();
			@input_index := 0;

			@tokens_max := 32;
			@tokens := Token->New[@tokens_max];
		}

		#~
		Constructor
		@param stream_in JSON byte stream
		~#
		New(stream_in : Byte[]) {
			@input := stream_in->ToString()->Trim()->ToCharArray();
			@input_index := 0;

			@tokens_max := 32;
			@tokens := Token->New[@tokens_max];
		}

		#~
		Parses JSON text
		@param text JSON text
		@return root document element
		~#
		function : TextToElement(text : String) ~ JsonElement {
			parser := JsonParser->New(text);
			if(parser->Parse()) {
				return parser->GetRoot();
			};
	
			return Nil;
		}
		
		#~
		Parses a Json string
		@return true is successful, false otherwise
		~#
		method : public : Parse() ~ Bool {
			NextToken();
			if(@cur_token->GetType() <> Token->Type->OTHER) {
# "--- Start Parsing --"->PrintLine();
				@root := ParseValue();
# "--- End Parsing --"->PrintLine();				
				return @root <> Nil;
			};
			
			return false;
    	}

    	#~
		Get the current parsing error
		@return parsing error, Nil if none
		~#
		method : public : GetError() ~ String {
			return @error_msg;
		}

    	#~
		Get document root
		@return root Json element
		~#
		method : public : GetRoot() ~ JsonElement {
			return @root;
		}
		
		method : ParseValue() ~ JsonElement {
			element : JsonElement;
			
			select(@cur_token->GetType()) {
				label Token->Type->OBR: {
# "array"->PrintLine();
					element := ParseArray();
				}

				label Token->Type->OCBR: {
# "object"->PrintLine();				
					element := ParseObject();						
				}

				label Token->Type->IDENT: {
					element := JsonElement->New(@cur_token->GetValue());
# Console->Print("string=")->PrintLine(@cur_token->GetValue());
					NextToken();
					
				}
				
				label Token->Type->INT_NUM:
				label Token->Type->FLOAT_NUM: {
					element := JsonElement->New(JsonType->NUMBER, @cur_token->GetValue());
# Console->Print("number=")->PrintLine(@cur_token->GetValue());
					NextToken();
				}
				
				label Token->Type->TRUE: {
					element := JsonElement->New(JsonType->TRUE);
# "true"->PrintLine();
					NextToken();
				}
				
				label Token->Type->FALSE: {
					element := JsonElement->New(JsonType->FALSE);
# "false"->PrintLine();
					NextToken();
				}
				
				label Token->Type->NULL: {
					element := JsonElement->New(JsonType->NULL);
# "null"->PrintLine();
					NextToken();
				}
				
				other: {
					@error_msg := @error_msg := "*** Unexpected value *** ";
# @cur_token->GetType()->As(Int)->PrintLine();				
					return Nil;
				}
			};
			
			return element;
		}

		method : ParseObject() ~ JsonElement {
			elements := Map->New()<String, JsonElement>;
			
			NextToken();
			while(@cur_token->GetType() <> Token->Type->EOS & 
				@cur_token->GetType() <> Token->Type->CCBR) {
				
				# parse name
				elem_name : Token;
				if(Match(Token->Type->IDENT) = false) {
					@error_msg := "*** Expected identifier *** ";
# @cur_token->GetType()->As(Int)->PrintLine();				
					return Nil;
				};			
				elem_name := @cur_token;
				NextToken();
				
				if(Match(Token->Type->COLON) = false) {
					@error_msg := "*** Expected ':' *** ";
# @cur_token->GetType()->As(Int)->PrintLine();				
					return Nil;
				};
				NextToken();
				
				# parse value
				value := ParseValue();
				if(value = Nil) {				
					return Nil;
				};
# IO.Console->Print("insert=")->PrintLine(elem_name->GetValue());		
				elements->Insert(elem_name->GetValue(), value);				
				
				# update
				if(Match(Token->Type->COMMA)) {
					NextToken();
# "comma"->PrintLine();
				};
			};
			
			if(Match(Token->Type->CCBR) = false) {
				@error_msg := "*** Expected '}' *** ";
# @cur_token->GetType()->As(Int)->PrintLine();				
				return Nil;
			};
			NextToken();
			
			return JsonElement->New(elements);
		}

		method : ParseArray() ~ JsonElement {
			elements := Vector->New()<JsonElement>;
			
			NextToken();
			while(@cur_token->GetType() <> Token->Type->EOS & 
				@cur_token->GetType() <> Token->Type->CBR) {
				value := ParseValue();
				if(value = Nil) {
					return Nil;
				};
				elements->AddBack(value);
				
				# update
				if(Match(Token->Type->COMMA)) {
					NextToken();
# "comma"->PrintLine();
				};
			};
			
			if(Match(Token->Type->CBR) = false) {
				@error_msg := "*** Expected ']' *** ";
# @cur_token->GetType()->As(Int)->PrintLine();				
				return Nil;
			};
			NextToken();
			
			return JsonElement->New(elements);
		}

		method : Match(token : Token->Type) ~ Bool {
			return @cur_token->GetType() = token;
		}

		method : AddToken(token : Token) ~ Nil {
	 		@tokens[@token_write_pos++] := token;
	 	}

	 	method : NextToken() ~ Nil {
	 		if(@cur_token = Nil | @token_read_pos >= @tokens_max) {
				Scan();
	 		}
	 		else {
	 			@cur_token := @tokens[@token_read_pos++];
	 		};
		}

		method : native : Scan() ~ Nil {			
			if(@input <> Nil) {
				

				# TODO: add-in line numbers
				
				@token_read_pos := @token_write_pos := 0;

				while(@token_write_pos < @tokens_max) {
					if(@input_index < @input->Size()) {
						# skip whitespace
						if(@input_index < @input->Size()) {
							char := @input[@input_index];
							while(@input_index < @input->Size() & (char = '\r' | char = '\n' | char = '\t' | char = ' ' | char = '\f' | char = '\v')) {
								char := @input[++@input_index];
							};
						};
						# comment
						if(@input_index + 1 < @input->Size() & @input[@input_index] = '/' & @input[@input_index + 1] = '/') {
							@input_index += 2;
							while(@input_index < @input->Size() & (@input[@input_index] <> '\r' & @input[@input_index] <> '\n')) {
								# update
								@input_index += 1;
							};
						}
						# token
						else {
							# parse string
							if(@input_index < @input->Size() & (@input[@input_index] = '"' | @input[@input_index]->IsChar())) {
								len : Int; offset : Int;
								if(@input[@input_index] = '"') {
									@input_index += 1;
									offset := @input_index;
									end := false;
									escape := false;
									while(@input_index < @input->Size() & end = false) {
										if(@input[@input_index] = '"' & escape = false) {
											# done
											end := true;
										}
										else if(@input[@input_index] = '\\') {
											escape := true;
											# update
											@input_index += 1;
										}
										else {
											escape := false;
											# update
											@input_index += 1;
										};
									};
									len := @input_index - offset;
									# update
									@input_index += 1;
								}
								else {				
									offset := @input_index;
									while(@input_index < @input->Size() & (@input[@input_index]->IsChar() | @input[@input_index] = '_')) {
										# update
										@input_index += 1;
									};
									len := @input_index - offset;
								};
								
								if(len > 0) {
									string := String->New(@input, offset, len);								
									if(string->Equals("true")) {
										AddToken(Token->New(Token->Type->TRUE));
									}
									else if(string->Equals("false")) {
										AddToken(Token->New(Token->Type->FALSE));
									}
									else if(string->Equals("null")) {
										AddToken(Token->New(Token->Type->NULL));
									}
									else {							
										AddToken(Token->New(Token->Type->IDENT, string));
									};
								}
								else {
									AddToken(Token->New(Token->Type->IDENT, ""));
								};
							}
							# parse number
							else if(@input_index < @input->Size() & (@input[@input_index]->IsDigit() | @input[@input_index] = '-' | @input[@input_index] = '.')) {
								offset := @input_index;
								minus_token_count := 0;
								dot_token_count := 0;

								# TODO: e digits
								while(@input_index < @input->Size() & 
									(@input[@input_index]->IsDigit() | @input[@input_index] = '-' | @input[@input_index] = '.' | @input[@input_index] = 'e' | @input[@input_index] = 'E')) {
									if(@input[@input_index] = '-') {
										minus_token_count += 1;
									}
									else if(@input[@input_index] = '.') {
										dot_token_count += 1;
									};
									# update
									@input_index += 1;
								};
								len := @input_index - offset;

								if(len > 0) {
									string := String->New(@input, offset, len);
									if(dot_token_count = 1 & minus_token_count < 3) {
										AddToken(Token->New(Token->Type->FLOAT_NUM, string));
									}
									else if(dot_token_count = 0 & minus_token_count < 3) {
										AddToken(Token->New(Token->Type->INT_NUM, string));
									}
									else {
										AddToken(Token->New(Token->Type->BAD_NUM, string));
									};
								}
								else {
									AddToken(Token->New(Token->Type->BAD_NUM, ""));
								};
							}
							# parse character
							else if(@input_index < @input->Size()) {
								select(@input[@input_index]) {
									label '[': {
										AddToken(Token->New(Token->Type->OBR));
									}
			
									label ']': {
										AddToken(Token->New(Token->Type->CBR));
									}

									label '{': {
										AddToken(Token->New(Token->Type->OCBR));
									}
			
									label '}': {
										AddToken(Token->New(Token->Type->CCBR));
									}

									label ',': {
										AddToken(Token->New(Token->Type->COMMA));
									}

									label ':': {
										AddToken(Token->New(Token->Type->COLON));
									}

									other: {
										AddToken(Token->New(Token->Type->OTHER));
									}
								};
								# update
								@input_index += 1;
							};
						};	
					}
					else {
						AddToken(Token->New(Token->Type->OTHER));
					};				
				};

				@cur_token := @tokens[@token_read_pos++];
			};
	 	}

		method : DumpTokens(tokens : Vector<Token>) ~ Nil {
			if(tokens->Size() > 0) {
				each(i : tokens) {
					select(tokens->Get(i)->As(Token)->GetType()) {
						label Token->Type->IDENT: {
							IO.Console->Print("token=IDENT, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
						}

						label Token->Type->INT_NUM: {
							IO.Console->Print("token=INTEGER, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
						}

						label Token->Type->FLOAT_NUM: {
							IO.Console->Print("token=FLOAT, value=")->PrintLine(tokens->Get(i)->As(Token)->GetValue());
						}

						label Token->Type->OBR: {
							"token='['"->PrintLine();
						}

						label Token->Type->CBR: {
							"token=']'"->PrintLine();
						}            

						label Token->Type->OCBR: {
							"token='{'"->PrintLine();
						}

						label Token->Type->CCBR: {
							"token='}'"->PrintLine();
						}

						label Token->Type->PREN: {
							"token='''"->PrintLine();
						}

						label Token->Type->COLON: {
							"token=':'"->PrintLine();
						}

						label Token->Type->COMMA: {
							"token=','"->PrintLine();
						}

						label Token->Type->OTHER: 
						label Token->Type->BAD_NUM: {
							"token=OTHER"->PrintLine();
						}						
					};
				};
			};
		}
	}

	#~
	JSON value element
	~#
	class JsonElement {
		@type : JsonType;
		@value : String;
		@array_elems : Vector<JsonElement>;
		@map_elems : Map<String, JsonElement>;

		#~
		JSON element type
		@class JsonElement
		~#
		enum JsonType {
			STRING,
			NUMBER,
			TRUE,
			FALSE,
			NULL,
			ARRAY,
			OBJECT,
			OTHER
		}
		
		#~
		Constructor
		@param type Json element type
		~#
		New(type : JsonElement->JsonType) {
			select(type) {
				label JsonElement->JsonType->TRUE {
					@type := type;	
					@value := "true";
				}

				label JsonElement->JsonType->FALSE {
					@type := type;	
					@value := "false";
				}

				label JsonElement->JsonType->NULL {
					@type := type;	
					@value := "";
				}

				label JsonElement->JsonType->OBJECT {
					@type := type;
					@map_elems := Map->New()<String, JsonElement>;
				}

				label JsonElement->JsonType->ARRAY {
					@type := type;
					@array_elems := Vector->New()<JsonElement>;
				}   

				other {
					@type := JsonElement->JsonType->OTHER;
				}
			};
		}
		
		#~
		Constructor
		@param type Json element type
		@param value Json string value
		~#
		New(type : JsonElement->JsonType, value : String) {
			if(type = JsonElement->JsonType->STRING | type = JsonElement->JsonType->NUMBER) {
				@type := type;	
				@value := value;				
			}
			else {
				@type := JsonElement->JsonType->OTHER;
			};
		}

		#~
		Constructor
		@param value Json string value
		~#
		New(value : String) {
			@type := JsonElement->JsonType->STRING;	
			@value := value;
		}
		
		#~
		Constructor
		@param value Json integer value
		~#
		New(value : Int) {
			@type := JsonElement->JsonType->NUMBER;	
			@value := value->ToString();
		}

		#~
		Constructor
		@param value Json float value
		~#
		New(value : Float) {
			@type := JsonElement->JsonType->NUMBER;	
			@value := value->ToString();
		}

		#~
		Constructor
		@param array_elems Json array value
		~#
		New(array_elems : Vector<JsonElement>) {
			@type := JsonElement->JsonType->ARRAY;
			@array_elems := array_elems;
		}
		
		#~
		Constructor
		@param map_elems Json object (names/values)
		~#
		New(map_elems : Map<String, JsonElement>) {
			@type := JsonElement->JsonType->OBJECT;
			@map_elems := map_elems;
		}
		
		#~
		Gets the type
		@return type
		~#
		method : public : GetType() ~ JsonElement->JsonType {
			return @type;
		}

		#~
		Checks for 'null' JSON value
		@return true if 'null', false otherwise
		~#
		method : public : IsNull() ~ Bool {
			return @type = JsonType->NULL;
		}
		
		#~
		Checks for 'null' JSON value
		@param elem element to check
		@return true if 'null', false otherwise
		~#
		function : public : IsNull(elem : JsonElement) ~ Bool {
			if(elem = Nil | elem->GetType() = JsonType->NULL) {
				return true;
			};
			
			return false;
		}

		#~
		Gets the string value
		@return string value
		~#
		method : public : GetValue() ~ String {
			return GetString();
		}

		#~
		Gets the string value
		@return string value
		~#
		method : public : GetString() ~ String {
			if(@value <> Nil) {
				return @value;
			};
			
			return "";
		}

		#~
		Gets the integer value
		@return integer value
		~#
		method : public : GetInt() ~ Int {
			if(@value <> Nil) {
				return @value->ToInt();
			};
			
			return 0;
		}

		#~
		Gets the float value
		@return float value
		~#
		method : public : GetFloat() ~ Float {
			if(@value <> Nil) {
				return @value->ToFloat();
			};
			
			return 0.0;
		}

		#~
		Gets the float value
		@return float value
		~#
		method : public : GetBool() ~ Bool {
			if(@value <> Nil) {
				return @value->ToBool();
			};
			
			return false;
		}
		
		#~
		Gets an indexed value from an array type
		@param index index
		@return indexed value
		~#
		method : public : Get(index : Int) ~ JsonElement {
			if(@array_elems <> Nil & index < @array_elems->Size()) {
				return @array_elems->Get(index);
			};
			
			return Nil;
		}

		#~
		Check to see if the indexed value exists
		@param index index
		@return true if exists, false otherwise
		~#
		method : public : Has(index : Int) ~ Bool {
			return Get(index) = Nil ? false : true;
		}

		#~
		Gets a named value from an object type
		@param name element name
		@return element value
		~#
		method : public : Get(name : String) ~ JsonElement {
			if(@map_elems <> Nil) {
				return @map_elems->Find(name);
			};
			
			return Nil;
		}

		#~
		Check to see if the indexed value exists
		@param name element name
		@return true if exists, false otherwise
		~#
		method : public : Has(name : String) ~ Bool {
			return Get(name) = Nil ? false : true;
		}
		
		#~
		Adds an element
		@param elem element
		@return true if successful, false otherwise
		~#
		method : public : Add(elem : JsonElement) ~ Bool {
			if(@type = JsonElement->JsonType->ARRAY) {
				if(elem = Nil) {
					@array_elems->AddBack(JsonElement->New(JsonElement->JsonType->NULL));
				}
				else {
					@array_elems->AddBack(elem);
				};

				return true;
			};

			return false;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : String) ~ Bool {
			if(@type = JsonElement->JsonType->ARRAY) {
				@array_elems->AddBack(JsonElement->New(value));
				return true;
			};

			return false;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : Int) ~ Bool {
			if(@type = JsonElement->JsonType->ARRAY) {
				@array_elems->AddBack(JsonElement->New(value));
				return true;
			};

			return false;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : Float) ~ Bool {
			if(@type = JsonElement->JsonType->ARRAY) {
				@array_elems->AddBack(JsonElement->New(value));
				return true;
			};

			return false;
		}

		#~
		Adds a value
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Add(value : Bool) ~ Bool {
			if(@type = JsonElement->JsonType->ARRAY) {
				if(value) {
					@array_elems->AddBack(JsonElement->New(JsonElement->JsonType->TRUE));
				}
				else {
					@array_elems->AddBack(JsonElement->New(JsonElement->JsonType->FALSE));
				};

				return true;
			};

			return false;
		}

		#~
		Adds a class child node
		@param name class name
		@return child class
		~#
		method : public : AddChild(name : String) ~ JsonElement {        
			if(@type = JsonElement->JsonType->OBJECT) {
				elem := JsonElement->New(JsonElement->JsonType->OBJECT);
				@map_elems->Insert(name, elem);

				return elem;
			};

			return Nil;
		}

		#~
		Insert an element
		@param name element name
		@param elem element
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, elem : JsonElement) ~ Bool {        
			if(@type = JsonElement->JsonType->OBJECT) {
				if(elem = Nil) {
					@map_elems->Insert(name, JsonElement->New(JsonElement->JsonType->NULL));
				}
				else {
					@map_elems->Insert(name, elem);
				};

				return true;
			};

			return false;
		}

		#~
		Inserts a value
		@param name value name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : String) ~ Bool {        
			if(@type = JsonElement->JsonType->OBJECT) {
				@map_elems->Insert(name, JsonElement->New(value));
				return true;
			};

			return false;
		}

		#~
		Inserts a value
		@param name value name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : Int) ~ Bool {        
			if(@type = JsonElement->JsonType->OBJECT) {
				@map_elems->Insert(name, JsonElement->New(value));
				return true;
			};

			return false;
		}

		#~
		Inserts a value
		@param name value name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : Float) ~ Bool {        
			if(@type = JsonElement->JsonType->OBJECT) {
				@map_elems->Insert(name, JsonElement->New(value));
				return true;
			};

			return false;
		}

		#~
		Inserts a value
		@param name value name
		@param value value
		@return true if successful, false otherwise
		~#
		method : public : Insert(name : String, value : Bool) ~ Bool {        
			if(@type = JsonElement->JsonType->OBJECT) {
				if(value) {
					@map_elems->Insert(name, JsonElement->New(JsonElement->JsonType->TRUE));
				}
				else {
					@map_elems->Insert(name, JsonElement->New(JsonElement->JsonType->FALSE));
				};

				return true;
			};

			return false;
		}
        
		#~
		General decoding for Json strings		
		@param str encoded string
		@return decoded string
		~#
		function : native : Decode(str : String) ~ String {
			buffer := String->New();

			each(i : str) {
				c := str->Get(i);
				if(c = '\\' & i + 1 < str->Size()) {
					i += 1;
					select(str->Get(i)) {
						label 'b': {
							buffer->Append(0x10->As(Char));
						}

						label 'f': {
							buffer->Append(0x14->As(Char));
						}

						label 'n': {
							buffer->Append('\n');
						}

						label 'r': {
							buffer->Append('\r');
						}

						label 't': {
							buffer->Append('\t');
						}

						label '\\': {
							buffer->Append('\\');
						}

						label '/': {
							buffer->Append('/');
						}

						label '"': {
							buffer->Append('"');
						}

						label 'u': {
							i += 1;
							if(i + 4 < str->Size()) {
								str_code := str->SubString(i, 4);
								if(<>str_code->IsEmpty()) {
									buffer->Append("0x{$str_code}"->ToInt()->As(Char));
								};
								i += 3;
							}
							else {
								buffer->Append(str->Get(i));
							};
						}
					};
				}
				else {
					buffer->Append(c);
				};
			};

			return buffer;
		}

		#~
		General encoding for JSON strings		
		@param str decoded string
		@return encoding string
		~#
		function : native : Encode(str : String) ~ String {
			buffer := String->New();

			each(i : str) {
				c := str->Get(i);

				if(c > 127) {
					str_hex := c->As(Int)->ToHexString();
					buffer->Append("\\u{$str_hex}");
				}
				else {
					select(c) {
						label 0x10: {
							buffer->Append("\\b");
						}

						label 0x14: {
							buffer->Append("\\f");
						}

						label '\n': {
							buffer->Append("\\n");
						}

						label '\r': {
							buffer->Append("\\r");
						}

						label '\t': {
							buffer->Append("\\t");
						}

						label '\\': {
							buffer->Append("\\\\");
						}

						label '/': {
							buffer->Append("\\/");
						}

						label '"': {
							buffer->Append("\\\"");
						}

						other: {
							buffer->Append(c);
						}
					};
				};
			};

			return buffer;
		}
		
		#~
		Gets the names of object attributes
		@return object attribute names
		~#
		method : public : GetNames() ~ Vector<String> {
			if(@map_elems <> Nil) {
				return @map_elems->GetKeys()<String>;
			};
			
			return Nil;
		}
		
		#~
		Gets the size of an array or object value
		@return size of an array or object value
		~#
		method : public : Size() ~ Int {
			if(@array_elems <> Nil) {
				return @array_elems->Size();
			};
			
			if(@map_elems <> Nil) {
				return @map_elems->Size();
			};
			
			return 0;
		}

		#~
		Checks a node's type
		@param elem element to check
		@param type type to check
		@return true of matching, false otherwise
		~#
		function : public : MatchType(elem : JsonElement, type : JsonElement->JsonType) ~ Bool {
			if(elem <> Nil & elem->GetType() = type) {
				return true;
			};
			
			return false;
		}
		
		#~
		Checks a node's type
		@param elem element to check
		@param value value to check
		@return true of matching, false otherwise
		~#
		function : public : MatchValue(elem : JsonElement, value : String) ~ Bool {
			if(elem <> Nil & elem->GetType() = JsonElement->JsonType->STRING & elem->GetValue()->Equals(value)) {
				return true;
			};
			
			return false;
		}
		
		#~
		Stringify the JSON element
		@return JSON string
		~#
		method : public : ToString() ~ String {
			output := String->New();
			Format(output, false, 0);		
			return output;
		}

		#~
		Stringify and format the JSON element
		@return formatted JSON string
		~#
		method : public : ToFormattedString() ~ String {
			output := String->New();
			Format(output, true, 0);		
			return output;
		}
		
		method : Format(output : String, pretty : Bool, depth : Int) ~ Nil {
			select(@type) {
				label JsonElement->JsonType->STRING: {
					if(@value <> Nil) {
						output->Append('"');
						output->Append(@value);
						output->Append('"');
					};
				}

				label JsonElement->JsonType->NUMBER: {
					if(@value <> Nil) {
						output->Append(@value);
					};
				}
				
				label JsonElement->JsonType->TRUE: {
					output->Append("true");
				}

				label JsonElement->JsonType->FALSE: {
					output->Append("false");
				}
				
				label JsonElement->JsonType->NULL: {
					output->Append("null");
				}

				label JsonElement->JsonType->ARRAY: {
					if(@array_elems <> Nil) {
						output->Append('[');
						if(pretty) {
							output->Append('\n');
							depth += 1;
							FormatPadding(output, depth);
						};

						each(i : @array_elems) {
							@array_elems->Get(i)->Format(output, pretty, depth);
							if(i + 1 < @array_elems->Size()) {
								output->Append(',');
								if(pretty) {
									output->Append('\n');
									FormatPadding(output, depth);
								};
							};
						};

						if(pretty) {
							output->Append('\n');
							depth -= 1;
							FormatPadding(output, depth);
						};
						output->Append(']');
					};
				}

				label JsonElement->JsonType->OBJECT: {
					if(@map_elems <> Nil) {
						output->Append('{');
						if(pretty) {
							output->Append('\n');
							depth += 1;
							FormatPadding(output, depth);
						};

						keys := @map_elems->GetKeys()<String>;
						each(i : keys) {
							key := keys->Get(i);
							value := @map_elems->Find(key);	

							output->Append('"');
							output->Append(key);
							output->Append("\":");
							if(pretty) {
								output->Append(' ');
							};

							value->As(JsonElement)->Format(output, pretty, depth);
							if(i + 1 < @map_elems->Size()) {
								output->Append(',');
								if(pretty) {
									output->Append('\n');
									FormatPadding(output, depth);
								};
							};
						};

						if(pretty) {
							output->Append('\n');
							depth -= 1;
							FormatPadding(output, depth);
						};
						output->Append('}');

					};
				}
			};
		}

		method : FormatPadding(output : String, depth : Int) ~ Nil {
			each(i : depth) {
				output->Append('\t');
			};
		}
		
		#~
		Queries the object graph. Object attributes referenced by '/' while array elements are referenced by '[index]'. Example "cars/[last]/make".
		@param path query path
		@return matching element
		~#
		method : public : FindElements(path : String) ~ JsonElement {					
			filters := path->Split("/");
			if(filters->Size() > 0) {
				element := @self;
				for(i := 0; i < filters->Size() & element <> Nil; i += 1;) {
					element := FindElement(filters[i], element);
				};
				
				return element;
			}
			else {
				return FindElement(path, @self);
			};
			
			return Nil;
		}
		
		method : FindElement(filter : String, node : JsonElement) ~ JsonElement {
			# array
			if(filter->StartsWith('[') & filter->EndsWith(']') & node->GetType() = JsonElement->JsonType->ARRAY) {
				end := filter->Find(']');
				index := filter->SubString(1, end - 1);
				
				offset : Int;
				if(index->Equals("first")) {
					offset := 0;
				}
				else if(index->Equals("last")) {
					offset := node->Size() - 1;
				}
				else {
					offset := index->ToInt();
				};
				
				if(offset > -1 & offset < node->Size()) {
					return node->Get(offset);
				};
			}
			# object
			else if(node->GetType() = JsonElement->JsonType->OBJECT) {
				return node->Get(filter);
			};
			
			return Nil;
		}
	}
	
	# token class
	class Token {
		@type : Token->Type;
		@value : String;
		
		enum Type {
			IDENT,
			INT_NUM,
			FLOAT_NUM,
			BAD_NUM,
			TRUE,
			FALSE,
			NULL,
			COMMA,
			OBR,
			CBR,
			OCBR,
			CCBR,
			PREN,
			COLON,
			OTHER,
			EOS
		}
		
		New(type : Token->Type, value : String) {
			@type := type;
			@value := value;
		}
			
		New(type : Token->Type) {
			@type := type;
			@value := Nil;
		}

		method : public : GetType() ~ Token->Type {
			return @type;
		}

		method : public : GetValue() ~ String {
			return @value;
		}
	}
}

#~
Support for e JSON Schema metadata (-lib json)
~#
bundle Data.JSON.Scheme {
	#~
	Function type definition 
	~#
	class FunctionType implements Compare {
		@name: String;
		@desc: String;
		@params : Set<ParameterType>;
		@req_params : String[];

		New(func_type_json : JsonElement) {

			@name := func_type_json->Get("name")->GetString();
			@desc := func_type_json->Get("description")->GetString();

			# get properties by name
			@params := Set->New()<ParameterType>;

			params_json := func_type_json->FindElements("parameters/properties");
			param_names := params_json->GetNames();
			each(param_name in param_names) {
				param_json := params_json->Get(param_name);

				param_type := param_json->Get("type")->GetString();
				param_desc := param_json->Get("description")->GetString();

				param : ParameterType;
				if(param_type->Equals("string")) {
					param := ParameterType->New(param_name, ParameterType->Type->STRING, param_desc);
				}
				else if(param_type->Equals("number")) {
					param := ParameterType->New(param_name, ParameterType->Type->NUMBER, param_desc);
				}
				else if(param_type->Equals("integer")) {
					param := ParameterType->New(param_name, ParameterType->Type->INTEGER, param_desc);
				}
				else if(param_type->Equals("object")) {
					param := ParameterType->New(param_name, ParameterType->Type->OBJECT, param_desc);
				}
				else if(param_type->Equals("boolean")) {
					param := ParameterType->New(param_name, ParameterType->Type->BOOLEAN, param_desc);
				};

				@params->Insert(param);
				
				# "param_name='{$param_name}', param_type={$param_type}, param_desc='{$param_desc}'"->PrintLine();
			};

			required_parms := func_type_json->FindElements("parameters/required");
			@req_params := String->New[required_parms->Size()];
			each(i : required_parms) {
				required_parm := required_parms->Get(i);
				@req_params[i] := required_parm->GetString();
			}
			# TODO: parse and set values
		}

		#~
		Constructor
		@param name function name
		@param params parameters to add to JSON object
		@param req_params required parameters 
		~#
		New(name : String, params : Set<ParameterType>, req_params : String[]) {
			@name := name;
			@req_params := req_params;
			@params := params;
		}

		#~
		Constructor
		@param name function name
		@param params parameters to add to JSON object
		~#
		New(name : String, params : Set<ParameterType>) {
			@name := name;
			@params := params;
		}

		#~
		Constructor
		@param name function name
		@param params parameters to add to JSON object
		@param desc description 
		~#
		New(name : String, params : Set<ParameterType>, desc : String) {
			@name := name;
			@params := params;
			@desc := desc;
		}

		#~
		Constructor
		@param name function name
		@param params parameters to add to JSON object
		@param req_params required parameters 
		@param desc description 
		~#
		New(name : String, params : Set<ParameterType>, req_params : String[], desc : String) {
			@name := name;
			@req_params := req_params;
			@params := params;
			@desc := desc;
		}

		#~
		Get the function name
		@return function name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get the function description
		@return function description
		~#
		method : public : GetDesc() ~ String {
			return @desc;
		}
		
		#~
		Get function parameters
		@return function parameters
		~#
		method : public : GetParams() ~ Set<ParameterType> {
			return @params;
		}

		#~
		Get the required function parameters
		@return required function parameters
		~#
		method : public : GetRequiredParams() ~ String[] {
			return @req_params;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			return @name->Compare(rhs);
		}

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @name->HashID();
		}

		#~
		JSON element representation 
		@return JSON element representation
		~# 
		method : public : ToJson() ~ JsonElement {
			func_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			func_obj_json->Insert("name", @name);
			func_obj_json->Insert("description", @desc);
			
			# JSON parameters
			prop_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			if(@params <> Nil) {
				param_values := @params->GetKeys()<ParameterType>;
				each(param_value in param_values) {
					param_name := param_value->GetName();
					param_obj_json := param_value->ToJson();

					prop_obj_json->Insert(param_name, param_obj_json);
				};
			};

			params_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
			if(@req_params <> Nil) {
				req_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
				each(req_param in @req_params) {
					req_array_json->Add(req_param)
				};
				params_obj_json->Insert("required", req_array_json);
			};
			params_obj_json->Insert("type", "object");
			params_obj_json->Insert("properties", prop_obj_json);

			func_obj_json->Insert("parameters", params_obj_json);

			return func_obj_json;
		}

		#~
		JSON string representation 
		@return JSON string representation
		~# 
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}

	#~
	Function parameter type definition 
	~#
	class ParameterType implements Compare {
		@name : String;
		@type : ParameterType->Type;
		@desc : String;
		@props : Set<ParameterType>;
		@req_params : String[];
		@is_array : Bool;
		@is_add_props : Bool;

		#~
		JSON function parameter type 
		~#
		enum Type {
			STRING,
			NUMBER,
			INTEGER,
			OBJECT,
			BOOLEAN
		}

		New : private(param_type_json : JsonElement) {
			# TODO: parse and set values
		}

		#~
		Constructor
		@param name function parameter name
		@param type parameter type
		~#
		New(name : String, type : ParameterType->Type) {
			@name := name;
			@type := type;
		}

		#~
		Constructor
		@param name function parameter name
		@param type parameter type
		@param desc description 
		~#
		New(name : String, type : ParameterType->Type, desc : String) {
			@name := name;
			@type := type;
			@desc := desc;
		}

		#~
		Constructor
		@param name function parameter name
		@param props set of named parameter properties 
		~#
		New(name : String, props : Set<ParameterType>) {
			@name := name;
			@type := ParameterType->Type->OBJECT;
			@props := props;
		}

		#~
		Constructor
		@param name function parameter name
		@param props set of named parameter properties 
		@param req_params require parameters
		~#
		New(name : String, props : Set<ParameterType>, req_params : String[]) {
			@name := name;
			@type := ParameterType->Type->OBJECT;
			@props := props;
			@req_params := req_params;
		}

		#~
		Constructor
		@param name function parameter name
		@param props set of named parameter properties 
		@param req_params require parameters
		@param desc description 
		~#
		New(name : String, props : Set<ParameterType>, req_params : String[], desc : String) {
			@name := name;
			@type := ParameterType->Type->OBJECT;
			@props := props;
			@req_params := req_params;
			@desc := desc;
		}

		method : public : SetArray(is_array : Bool) ~ Nil {
			@is_array := is_array;
		}

		method : public : IsArray() ~ Bool {
			return @is_array;
		}

		method : public : SetAdditionalProps(is_add_props : Bool) ~ Nil {
			@is_add_props := is_add_props;
		}

		method : public : IsAdditionalProps() ~ Bool {
			return @is_add_props;
		}

		#~
		Get the function name
		@return function name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Get the function description
		@return function description
		~#
		method : public : GetDesc() ~ String {
			return @desc;
		}

		#~
		Set the function description
		@param desc sets function description
		~#
		method : public : SetDesc(desc : String) ~ Nil {
			@desc := desc;
		}

		#~
		Get parameter type
		@return parameter type
		~#
		method : public : GetType() ~ ParameterType->Type {
			return @type;
		}

		#~
		Set parameter type
		@param type parameter type
		~#
		method : public : SetType(type : ParameterType->Type) ~ Nil {
			@type := type;
		}

		#~
		Get parameter properties object descriptions
		@return properties object descriptions
		~#
		method : public : GetProps() ~ Set<ParameterType> {
			return @props;
		}

		#~
		Set properties
		@param props properties
		~#
		method : public : SetProps(props : Set<ParameterType>) ~ Nil {
			@props := props;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			return @name->Compare(rhs);
		}

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @name->HashID();
		}

		#~
		JSON element representation 
		@return JSON element representation
		~# 
		method : public : ToJson() ~ JsonElement {
			param_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			if(@is_add_props) {
				param_obj_json->Insert("additionalProperties", false);
			};

			if(@is_array) {
				items_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);

				if(@desc <> Nil) {
					items_obj_json->Insert("description", @desc);
				};

				if(@name <> Nil) {
					items_obj_json->Insert("name", @name);
				};

				if(@desc <> Nil) {
					items_obj_json->Insert("description", @desc);
				};

				select(@type) {
					label ParameterType->Type->STRING {
						items_obj_json->Insert("type", "string");
					}

					label ParameterType->Type->NUMBER {
						items_obj_json->Insert("type", "number");
					}

					label ParameterType->Type->INTEGER {
						items_obj_json->Insert("type", "integer");
					}

					label ParameterType->Type->BOOLEAN {
						items_obj_json->Insert("type", "boolean");
					}

					label ParameterType->Type->OBJECT {
						items_obj_json->Insert("type", "object");
					}

					other {
						items_obj_json->Insert("type", Nil);
					}
				};

				param_obj_json->Insert("items", items_obj_json);
				param_obj_json->Insert("type", "array");
			}
			else {
				if(@desc <> Nil) {
					param_obj_json->Insert("description", @desc);
				};

				if(@name <> Nil) {
					param_obj_json->Insert("name", @name);
				};

				if(@desc <> Nil) {
					param_obj_json->Insert("description", @desc);
				};

				select(@type) {
					label ParameterType->Type->STRING {
						param_obj_json->Insert("type", "string");
					}

					label ParameterType->Type->NUMBER {
						param_obj_json->Insert("type", "number");
					}

					label ParameterType->Type->INTEGER {
						param_obj_json->Insert("type", "integer");
					}

					label ParameterType->Type->BOOLEAN {
						param_obj_json->Insert("type", "boolean");
					}

					label ParameterType->Type->OBJECT {
						param_obj_json->Insert("type", "object");

						prop_obj_json := JsonElement->New(JsonElement->JsonType->OBJECT);
						prop_values := @props->GetKeys()<ParameterType>;
						each(prop_value in prop_values) {				
							prop_obj_json->Insert(prop_value->GetName(), prop_value->ToJson());
						}
						param_obj_json->Insert("properties", prop_obj_json);

						if(@req_params <> Nil) {
							req_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
							each(req_param in @req_params) {
								req_array_json->Add(req_param);
							};
							param_obj_json->Insert("required", req_array_json);
						};
					}

					other {
						param_obj_json->Insert("type", Nil);
					}
				};
			};

			return param_obj_json;
		}

		#~
		JSON string representation 
		@return JSON string representation
		~# 
		method : public : ToString() ~ String {
			return ToJson()->ToString();
		}
	}
}