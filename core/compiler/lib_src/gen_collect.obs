#~~
# Core collections for Objeck
# Copyright (c) 2019-2023 Randy Hollines
# 
# credits:
# - H.W. Lang - merge sort implementation based on his work
# - Arne Andersson - map classes uses a red-black tree variant he created
~~#

#~
Generic collections (-lib gen_collect)
~#	
bundle Collection.Generic {
	#~
	Object MRU/LRU cache
	~#
	class Cache<K : Compare, S> {
		@type : Cache->Type;
		@max : Int;
		@cache : Map<K, S>;
		@priority : CompareList<K>;

		#~
		Cache type
		~#
		enum Type {
			LRU,
			MRU
		}

		#~
		Default constructor
		@param type MRU or LRU cache
		@param max cache max size
		~#
		New(type : Cache->Type, max : Int) {
			@type := type;
			@max := max;
			@cache := Map->New()<K, S>;
			@priority := CompareList->New()<K>;
		}

		#~
		Inserts a value into the hash
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : S) ~ Bool {
			if(@priority->Size() < @max) {
				@priority->Rewind();
				found := @priority->Find(key);
				if(found <> Nil) {
					@priority->Remove();
				}
				else {
					@cache->Insert(key, value);
					@priority->AddFront(key);
				};

				return true;
			}
			else if(Remove()) {
				@priority->AddFront(key);
				@cache->Insert(key, value);

				return true;
			};

			return false;
		}

		#~
		Removes a value from the cache
		@param key key for value to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			if(@cache->Has(key)) {
				@priority->Find(key);
				@priority->Remove();
				@cache->Remove(key);

				return true;
			};

			return false;
		}

		method : Remove() ~ Bool {
			if(<>@priority->IsEmpty()) {
				removed : K;

				if(@type = Cache->Type->LRU) {
					removed := @priority->Back();
					@priority->RemoveBack();
				}
				else {
					removed := @priority->Front();
					@priority->RemoveFront();
				};
				@cache->Remove(removed);
				
				return true;
			};
			
			return false;
		}

		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @cache->GetKeys()<K>;
		}

		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~ Vector<S> {
			return @cache->GetValues()<S>;
		}

		#~
		Gets a collection of key/value pairs
		@return vector of key/value pairs
		~#
		method : public : GetKeyValues() ~ Vector<Pair<K, S>> {
			return @cache->GetKeyValues()<Pair<K, S>>;
		}

		#~
		Searches for a value in cache
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : Find(key : K) ~ S {
			return @cache->Find(key);
		}

		#~
		Checks for a value in a cache
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return @cache->Find(key) <> Nil;
		}

		#~
		Size of cache
		@return size of cache
		~#
		method : public : Size() ~ Int {
			return @cache->Size();
		}

		#~
		Checks to see if the cache is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @cache->IsEmpty();
		}

		#~
		Clears the cache
		~#
		method : public : Empty() ~ Nil {
			@cache->Empty();
			@priority->Empty();
		}
	}
	
	#~
	Generic pair
	~#
	class Pair<F : Compare, S> implements System.Compare  {
		@first : F;
		@second : S;

		#~
		Default constructor
		@param first compare object
		@param second object
		~#
		New(first : F, second : S) {
			@first := first;
			@second := second;
		}

		#~
		Compares two objects based upon first value
		@param first compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(first : System.Compare) ~ Int {
			return @first->Compare(first);
		}
		
		#~
		Returns the class default hash ID
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @first->GetInstanceID();
		}

		#~
		Gets the first value
		@return first value
		~#
		method : public : GetFirst() ~ F {
			return @first;
		}

		#~
		Sets the first value
		@param first first value
		~#
		method : public : SetFirst(first : F) ~ Nil {
			@first := first;
		}

		#~
		Gets the second value
		@return second value
		~#
		method : public : GetSecond() ~ S {
			return @second;
		}

		#~
		Sets the second value
		@param second second value
		~#
		method : public : SetSecond(second : S) ~ Nil {
			@second := second;
		}
	}

	#~
	Hash table of generics 
	~#
	class Hash<K : Compare, V> {
		@buckets : CompareList[]<K>;
		@size : Int;
		@capacity : Int;
		@auto_resize : Bool;

		#~
		Hash table capacity: SMALL <= 64 items, MEDIUM <= 256, LARGE <= 2048, EX-LARGE >= 8192
		~#
		consts Capacity {
			SMALL := 83,
			MEDIUM := 331,
			LARGE := 2609,
			EX_LARGE := 10211
		}
		
		#~
		Default constructor 
		~#
		New() {
			@capacity := Capacity->SMALL;
			@buckets := CompareList->New[@capacity]<K>;
			@auto_resize := true;
			@size := 0;
		}
		
		#~
		Default constructor 
		@param capacity capacity of hash table
		~#
		New(capacity : Hash->Capacity) {
			@capacity := capacity;
			@buckets := CompareList->New[@capacity]<K>;
			@auto_resize := true;
			@size := 0;
		}
		
		#~
		Inserts a value into the hash
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			if(@auto_resize) {
				select(@size + 1) {
					label 65: {
						Resize(Hash->Capacity->MEDIUM);
					}

					label 257: {
						Resize(Hash->Capacity->LARGE);
					}

					label 2049: {
						Resize(Hash->Capacity->EX_LARGE);
					}
				};
			};

			hash := (key->HashID() % @buckets->Size())->Abs();
			list := @buckets[hash];
			if(list = Nil) {
				list := CompareList->New()<K>;
				@buckets[hash] := list;
			};
			list->AddBack(HashPair->New(key->As(Compare), value)<V>);
			@size += 1;
		}

		#~
		Searches for a value in a hash
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : native : Find(key : K) ~ V {
			hash := (key->HashID() % @buckets->Size())->Abs();
			list := @buckets[hash];
			if(list <> Nil) {
				list->Rewind();
				while(list->More()) {
					pair : HashPair<V> := list->Get()<V>;
					if(pair->Compare(key) = 0) {
						return pair->Get();
					};
					list->Next();
				};

				return Nil;
			};

			return Nil;
		}

		#~
		Gets the hash table capacity
		@return hash table capacity
		~#
		method : public : Capacity() ~ Hash->Capacity {
			return @capacity;
		}

		#~
		Resizes the hash table
		@param capacity table capacity
		@param auto_resize true for hash table auto resizing, false otherwise
		~#
		method : public : native : Resize(capacity : Hash->Capacity, auto_resize : Bool := true) ~ Nil {
			@capacity := capacity;
			@auto_resize := auto_resize;

			temp_buckets := CompareList->New[@capacity]<K>;
			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						# get key/value
						pair : HashPair<V> := list->Get()<V>;
						
						# insert key/value
						hash := (pair->GetKey()->HashID() % temp_buckets->Size())->Abs();
						list := temp_buckets[hash];
						if(list = Nil) {
							list := CompareList->New()<K>;
							temp_buckets[hash] := list;
						};
						list->AddBack(pair);
						list->Next();
					};
				};
			};

			@buckets := temp_buckets;
		}
		
		#~
		Checks for a value in a hash
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			result := Find(key);
			return result <> Nil;
		}
		
		#~
		Removes a value from the hash
		@param key key for value to remove
		~#
		method : public : native : Remove(key : K) ~ Bool {
			hash := (key->HashID() % @buckets->Size())->Abs();
			list := @buckets[hash];
			if(list <> Nil) {
				list->Rewind();
				while(list->More()) {
					pair : HashPair<V> := list->Get()<V>;
					if(pair->Compare(key) = 0) {
						list->Remove();
						@size -= 1;

						if(@auto_resize) {
							select(@size) {
								label 64: {
									Resize(Hash->Capacity->SMALL);
								}

								label 256: {
									Resize(Hash->Capacity->MEDIUM);
								}

								label 2048: {
									Resize(Hash->Capacity->LARGE);
								}
							};
						};

						return true;
					};

					list->Next();
				};

				return false;
			};

			return false;
		}
		
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : native : GetKeys() ~ Vector<K> {
			keys := Vector->New()<K>;
			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						pair : HashPair<V> := list->Get()<V>;
						keys->AddBack(pair->GetKey());
						list->Next();
					};
				};
			};
			
			return keys;
		}
		
		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : native : GetValues() ~ Vector<V> {
			values := Vector->New()<V>;
			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						pair : HashPair<V> := list->Get()<V>;
						values->AddBack(pair->Get());
						list->Next();
					};
				};
			};
			
			return values;
		}

		#~
		Gets a collection of key/value pairs
		@return vector of key/value pairs
		~#
		method : public : GetKeyValues() ~ Vector<Pair<K,V>> {
			values := Vector->New()<Pair<K,V>>;

			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						pair : HashPair<V> := list->Get()<V>;

						k : K := pair->GetKey();
						v : V := pair->Get();

						values->AddBack(Pair->New(k, v)<K,V>);
						
						list->Next();
					};
				};
			};
			
			return values;
		}
		
		#~
		Clears the map
		~#
		method : public : Empty() ~ Nil {
			@buckets := CompareList->New[@capacity]<K>;
			@size := 0;
		}

		#~
		Checks to see if the hash table is empty
		@return true if empty, false otherwise
		~#
		method : public: IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of map
		@return size of map
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class : private : HashPair<V> implements Compare, Clone {
		@key : Compare;
		@value : V;

		New(key : Compare, value : V) {
			Parent();
			@key := key;
			@value := value;
		}

		method : public : Compare(rhs : Compare) ~ Int {		
			return @key->Compare(rhs);
		}

		method : public : Clone() ~ Compare {
			return HashPair->New(@key, @value)<V>;
		}

		method : public : HashID() ~ Int {
			return @key->HashID();
		}
		
		method : public : GetKey() ~ Compare {
			return @key;
		}

		method : public : Get() ~ V {
			return @value;
		}
	}
	
	#~
	Growable stack of generics
	~#
	class Stack<H> {
		@values : Vector<H>;
		
		#~
		Default constructor 
		~#
		New() {
			@values := Vector->New()<H>	;
		}

		#~
		Pushes a value onto the stack
		@param value to push
		~#
		method : public: Push(value : H) ~ Nil {
			@values->AddBack(value);
		}
		
		#~
		Pushes a value from the stack
		@return popped valued, Nil if stack is empty
		~#
		method : public : Pop() ~ H {
			if(@values->Size() > 0) {
				value : H := @values->Get(@values->Size() - 1);
				@values->RemoveBack();
				
				return value;
			};
			
			return Nil;
		}
		
		#~
		Check the top of the stack
		@return value on the top of stack, Nil if stack is empty
		~#
		method : public: Top() ~ H {
			if(@values->Size() > 0) {
				return @values->Get(@values->Size() - 1);
			};
			
			return Nil;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values->Empty();
		}
		
		#~
		Checks to see if the stack is empty
		@return true if empty, false otherwise
		~#
		method : public: IsEmpty() ~ Bool {
			return @values->Size() = 0;
		}

		#~
		Size of stack
		@return size of stack
		~#
		method : public: Size() ~ Int {
			return @values->Size();
		}
	}

	#~
	Queue of generics
	~#
	class Queue<H> {
		@queue : List<H>;
		
		#~
		Default constructor 
		~#
		New() {
			@queue := List->New()<H>;
		}

		#~
		Adds a value to the back of the queue
		@param value value to add
		~#
		method : public: Add(value : H) ~ Nil {
			@queue->AddBack(value);
		}
		
		#~
		Removes a value from the front of the queue
		@return value removed
		~#
		method : public : Remove() ~ H {
			if(@queue->Size() > 0) {
				value := @queue->Front();
				@queue->RemoveFront();
				return value;
			};
			
			return Nil;
		}
		
		#~
		Get the value from the head of the queue
		@return head value, Nil if queue is empty
		~#
		method : public: Head() ~ H {
			if(@queue->Size() > 0) {
				return @queue->Front();
			};
			
			return Nil;
		}
		
		#~
		Clears the queue
		~#
		method : public : Empty() ~ Nil {
			@queue->Empty();
		}
		
		#~
		Checks to see if the queue is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @queue->IsEmpty();
		}
		
		#~
		Size of queue
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @queue->Size();
		}
	}

	#~
	Forward iterator of comparables
	~#
	class CompareForwardIterator<H : Compare> {
		@node : CompareListNode<H>;
		@list : CompareList<H>;
		
		New(node : CompareListNode<H>, list : CompareList<H>) {
			@node := node;
			@list := list;
		}

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@node <> Nil) {
				@node := @node->GetNext();
			};
		}

		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			if(@node <> Nil) {
				return true;
			};

			return false;
		}

		#~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	Backward iterator of comparables
	~#
	class CompareBackwardIterator<H : Compare> {
	    @node : CompareListNode<H>;
	    @list : CompareList<H>;

	    New(node : CompareListNode<H>, list : CompareList<H>) {
	            @node := node;
	            @list := list;
	    }

	    #~
		Advances the pointer Backward
		~#
	    method : public : Next() ~ Nil {
	            if(@node <> Nil) {
	                    @node := @node->GetPrevious();
	            };
	    }

	    #~
		Checks to see the pointer can be advanced Backward
		@return true if pointer can be advanced, false otherwise
		~#
	    method : public : More() ~ Bool {
	            if(@node <> Nil) {
	                    return true;
	            };

	            return false;
	    }

	    #~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	List of comparable generics
	~#
	class CompareList<H : Compare> {
		@size : Int;
		@head : CompareListNode<H>;
		@tail : CompareListNode<H>;
		@cursor : CompareListNode<H>;

		#~
		Default constructor 
		~#
		New() {
			@size := 0;
		}

		#~
		Instance of a forward iterator
		@return forward iterator
		~#
		method : public : ForwardIterator() ~ CompareForwardIterator<H> {
			return CompareForwardIterator->New(@head, @self)<H>;
		}

		#~
		Instance of a backward iterator
		@return Backward iterator
		~#
		method : public : BackwardIterator() ~ CompareBackwardIterator<H> {
			return CompareBackwardIterator->New(@tail, @self)<H>;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : native : AddBack(value : H) ~ Nil {
			node := CompareListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size += 1;
		}
	
		#~
		Removes the last value from the list
		~#
		method : public : RemoveBack() ~ Nil {
			Forward();
			Remove();
		}

		#~
		Adds a value to the front
		@param value value to prepend 
		~#
		method : public : native : AddFront(value : H) ~ Nil {
			node := CompareListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
			};
			@size += 1;
		}
		
		#~
		Removes the first value from the list
		~#
		method : public : RemoveFront() ~ Nil {
			Rewind();
			Remove();
		}

		#~
		Moves the pointer to the start of the list
		~#
		method : public : Rewind() ~ Nil {
			@cursor := @head;
		}		

		#~
		Moves the pointer to the end of the list
		~#
		method : public : Forward() ~ Nil {
			@cursor := @tail;
		}		

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		#~
		Retreats the pointer
		~#
		method : public : Previous() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		#~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}

		#~
		Maps the given function to each value in the list 
		@param f function to apply
		@return newly calculated list
		~#
		method : public : Map(f : (H) ~ H) ~ CompareList<H> {
			list : CompareList<H> := CompareList->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				list->AddBack(f(start->Get()));
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered list
		~#
		method : public : Filter(f : (H) ~ Bool) ~ CompareList<H> {
			list : CompareList<H> := CompareList->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				if(f(start->Get())) {
					list->AddBack(start->Get());
				};
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		List of all but first element
		@return all but first element
		~#
		method : public : Rest() ~ CompareList<H> {
			list : CompareList<H> := CompareList->New()<H>;
			
			if(@head <> Nil) {
				start := @head->GetNext();
				while(start <> Nil) {
					list->AddBack(start->Get());
					start := start->GetNext();
				};

				list->Rewind();
			};

			return list;
		}

		#~
		Searches for a value
		@param value value to check for
		@return true if value is found, false otherwise
		~#
		method : public : Has(value : H) ~ Bool {
			start := @head;
			end := @tail;
			
			while(start <> end) {
				if(value->Compare(start->Get()) = 0) {
					return true;
				}
				else if(value->Compare(end->Get()) = 0) {
					return true;
				};
				
				start := start->GetNext();
				end := end->GetPrevious();
			};
			
			if(start <> Nil & value->Compare(start->Get()) = 0) {
				return true;
			}; 

			return false;
		}
		
		#~
		Finds a value in the list and sets the pointer
		@param value value to search for
		@return value that's found
		~#
		method : public : Find(value : H) ~ H {
			@cursor := @head;
			while(@cursor <> Nil) {
				if(value->Compare(@cursor->Get()) = 0) {
					return value;
				};
				@cursor := @cursor->GetNext();
			};
			
			return Nil;
		}
		
		#~
		Inserts a value into the list based upon the pointer location
		@param value value to insert
		~#
		method : public : native : Insert(value : H) ~ Bool {
			if(@cursor <> Nil & @head <> Nil & @tail <> Nil) {
				node := CompareListNode->New(value)<H>;
				if(@cursor = @head & @cursor = @tail) {
			 		@head->SetNext(node);
			 		node->SetPrevious(@head);
			 		@tail := node;
			 	}
			 	else if(@cursor = @tail) {
			 		@tail->SetNext(node);
			 		node->SetPrevious(@tail);
			 		@tail := node;
			 	}
			 	else {
					@cursor->GetNext()->SetPrevious(node);
					node->SetNext(@cursor->GetNext());
			 		@cursor->SetNext(node);
			 		node->SetPrevious(@cursor);
			 	};
			 	@size += 1;
				
				return true;
			}
			else if(@head = Nil & @tail = Nil) {
				AddBack(value);
				return true;
			};
			
			return false;
		}
		
		#~
		Removes the element at the pointer position
		~#
		method : public : native : Remove() ~ Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetPrevious();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Removes the element at the pointer position
		@param node node
		~#
		method : public : native : Remove(node : CompareListNode<H>) ~ Nil {
			if(node <> Nil) {
				if(node->GetPrevious() <> Nil) {
					node->GetPrevious()->SetNext(node->GetNext());
				};
				if(node = @head & node = @tail) {
			 		node := node->GetNext();
			 		@head := node;
			 		@tail := node;
			 	}
			 	else if(node = @head) {
			 		node := node->GetNext();
			 		@head := node;
			 	}
			 	else if(node = @tail) {
			 		node := node->GetPrevious();
			 		@tail := node;
			 	}
			 	else {
			 		node := node->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Checks to see if the pointer is at the front of the list
		@return true if pointer is at the front of the list, false otherwise
		~#
		method : public : IsFront() ~ Bool {
			return @cursor = @head;
		}		
		
		#~
		Checks to see if the pointer is at the end of the list
		@return true if pointer is at the end of the list, false otherwise
		~#
		method : public : IsBack() ~ Bool {
			return @cursor = @tail;
		}
		
		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @cursor <> Nil;
		}

		#~
		Returns the first element in the list
		@return first element in the list, 0.0 if the list is empty
		~#
		method : public : Front() ~ H {
			if(@head <> Nil) {
				return @head->Get();
			};

			return Nil;
		}

		#~
		Returns the last element in the list
		@return last element in the list, 0.0 if the list is empty
		~#
		method : public : Back() ~ H {
			if(@tail <> Nil) {
				return @tail->Get();
			};

			return Nil;
		}

		#~
		Clears the list
		~#
		method : public : Empty() ~ Nil {
			@size := 0;
			@head := Nil;
			@tail := Nil;
			@cursor := Nil;
		}
		
		#~
		Checks to see if the list is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of list
		@return size of list
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class : private : CompareListNode<H : Compare> {
		@value : H;
		@next : CompareListNode<H>;
		@previous: CompareListNode<H>;

		New(value : H) {
			@value := value;
		}
		
		method : public : Set(value : H) ~ Nil {
			@value := value;
		}
	
		method : public : Get() ~ H {
			return @value;
		}

		method : public : SetNext(next :  CompareListNode<H>) ~ Nil {
			@next := next;
		}
	
		method : public : GetNext() ~ CompareListNode<H> {
			return @next;
		}

		method : public : SetPrevious(previous :  CompareListNode<H>) ~ Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious() ~ CompareListNode<H> {
			return @previous;
		}
	}

	#~
	Forward iterator
	~#
	class ForwardIterator<H> {
		@node : ListNode<H>;
		@list : List<H>;
		
		New(node : ListNode<H>, list : List<H>) {
			@node := node;
			@list := list;
		}

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@node <> Nil) {
				@node := @node->GetNext();
			};
		}

		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @node <> Nil;
		}

		#~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	Backward iterator
	~#
	class BackwardIterator<H> {
	    @node : ListNode<H>;
	    @list : List<H>;

	    New(node : ListNode<H>, list : List<H>) {
	            @node := node;
	            @list := list;
	    }

	    #~
		Advances the pointer Backward
		~#
	    method : public : Next() ~ Nil {
	            if(@node <> Nil) {
	                    @node := @node->GetPrevious();
	            };
	    }

	    #~
		Checks to see the pointer can be advanced Backward
		@return true if pointer can be advanced, false otherwise
		~#
	    method : public : More() ~ Bool {
	            if(@node <> Nil) {
	                    return true;
	            };

	            return false;
	    }

	    #~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	List of generics
	~#
	class List<H> {
		@size : Int;
		@head : ListNode<H>;
		@tail : ListNode<H>;
		@cursor : ListNode<H>;

		#~
		Default constructor 
		~#
		New() {
			@size := 0;
		}

		#~
		Instance of a forward iterator
		@return forward iterator
		~#
		method : public : ForwardIterator() ~ ForwardIterator<H> {
			return ForwardIterator->New(@head, @self)<H>;
		}

		#~
		Instance of a backward iterator
		@return Backward iterator
		~#
		method : public : BackwardIterator() ~ BackwardIterator<H> {
			return BackwardIterator->New(@tail, @self)<H>;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : native : AddBack(value : H) ~ Nil {
			node := ListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size += 1;
		}

		#~
		Maps the given function to each value in the list 
		@param f function to apply
		@return newly calculated list
		~#
		method : public : Map(f : (H) ~ H) ~ List<H> {
			list : List<H> := List->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				list->AddBack(f(start->Get()));
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (H) ~ Nil) ~ List<H> {
			start := @head;
			while(start <> Nil) {
				f(start->Get());
				start := start->GetNext();
			};
			return @self;
		}

		#~
		Returns a limited list
		@param l limit
		@return limited list
		~#
		method : public : Limit(l : Int) ~ List<H> {
			list := List->New()<H>;
			
			if(l > -1) {
				i := 0;
				start := @head;
				while(i < l & start <> Nil) {
					list->AddBack(start->Get());
					start := start->GetNext();
					i += 1;
				};
			};

			list->Rewind();
			return list;
		}

		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered list
		~#
		method : public : Filter(f : (H) ~ Bool) ~ List<H> {
			list : List<H> := List->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				if(f(start->Get())) {
					list->AddBack(start->Get());
				};
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		List of all but first element
		@return all but first element
		~#
		method : public : Rest() ~ List<H> {
			list : List<H> := List->New()<H>;
			
			if(@head <> Nil) {
				start := @head->GetNext();
				while(start <> Nil) {
					list->AddBack(start->Get());
					start := start->GetNext();
				};

				list->Rewind();
			};

			return list;
		}
		
		#~
		Removes the last value from the list
		~#
		method : public : RemoveBack() ~ Nil {
			Forward();
			Remove();
		}

		#~
		Adds a value to the front
		@param value value to prepend 
		~#
		method : public : native : AddFront(value : H) ~ Nil {
			node := ListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
			};
			@size += 1;
		}
		
		#~
		Removes the first value from the list
		~#
		method : public : RemoveFront() ~ Nil {
			Rewind();
			Remove();
		}

		#~
		Moves the pointer to the start of the list
		~#
		method : public : Rewind() ~ Nil {
			@cursor := @head;
		}		

		#~
		Moves the pointer to the end of the list
		~#
		method : public : Forward() ~ Nil {
			@cursor := @tail;
		}		

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		#~
		Retreats the pointer
		~#
		method : public : Previous() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		#~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}
				
		#~
		Inserts a value into the list based upon the pointer location
		@param value value to insert
		~#
		method : public : native : Insert(value : H) ~ Bool {
			if(@cursor <> Nil & @head <> Nil & @tail <> Nil) {
				node := ListNode->New(value)<H>;
				if(@cursor = @head & @cursor = @tail) {
			 		@head->SetNext(node);
			 		node->SetPrevious(@head);
			 		@tail := node;
			 	}
			 	else if(@cursor = @tail) {
			 		@tail->SetNext(node);
			 		node->SetPrevious(@tail);
			 		@tail := node;
			 	}
			 	else {
					@cursor->GetNext()->SetPrevious(node);
					node->SetNext(@cursor->GetNext());
			 		@cursor->SetNext(node);
			 		node->SetPrevious(@cursor);
			 	};
			 	@size += 1;
				
				return true;
			}
			else if(@head = Nil & @tail = Nil) {
				AddBack(value);
				return true;
			};
			
			return false;
		}
		
		#~
		Removes the element at the pointer position
		~#
		method : public : native : Remove() ~ Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetPrevious();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size -= 1;
			};
		}

		method : public : native : Remove(node : ListNode<H>) ~ Nil {
			if(node <> Nil) {
				if(node->GetPrevious() <> Nil) {
					node->GetPrevious()->SetNext(node->GetNext());
				};
				if(node = @head & node = @tail) {
			 		node := node->GetNext();
			 		@head := node;
			 		@tail := node;
			 	}
			 	else if(node = @head) {
			 		node := node->GetNext();
			 		@head := node;
			 	}
			 	else if(node = @tail) {
			 		node := node->GetPrevious();
			 		@tail := node;
			 	}
			 	else {
			 		node := node->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Checks to see if the pointer is at the front of the list
		@return true if pointer is at the front of the list, false otherwise
		~#
		method : public : IsFront() ~ Bool {
			return @cursor = @head;
		}		
		
		#~
		Checks to see if the pointer is at the end of the list
		@return true if pointer is at the end of the list, false otherwise
		~#
		method : public : IsBack() ~ Bool {
			return @cursor = @tail;
		}
		
		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @cursor <> Nil;
		}

		#~
		Returns the first element in the list
		@return first element in the list, 0.0 if the list is empty
		~#
		method : public : Front() ~ H {
			if(@head <> Nil) {
				return @head->Get();
			};

			return Nil;
		}

		#~
		Returns the last element in the list
		@return last element in the list, 0.0 if the list is empty
		~#
		method : public : Back() ~ H {
			if(@tail <> Nil) {
				return @tail->Get();
			};

			return Nil;
		}

		#~
		Clears the list
		~#
		method : public : Empty() ~ Nil {
			@size := 0;
			@head := Nil;
			@tail := Nil;
			@cursor := Nil;
		}
		
		#~
		Checks to see if the list is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of list
		@return size of list
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class : private : ListNode<H> {
		@value : H;
		@next : ListNode<H>;
		@previous: ListNode<H>;

		New(value : H) {
			@value := value;
		}
		
		method : public : Set(value : H) ~ Nil {
			@value := value;
		}
	
		method : public : Get() ~ H {
			return @value;
		}

		method : public : SetNext(next :  ListNode<H>) ~ Nil {
			@next := next;
		}
	
		method : public : GetNext() ~ ListNode<H> {
			return @next;
		}

		method : public : SetPrevious(previous :  ListNode<H>) ~ Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious() ~ ListNode<H> {
			return @previous;
		}
	}
	
	#~
	Growable array of generics
	~#
	class Vector<H> {
		@values : H[];
		@size : Int;
		
		#~
		Default constructor 
		~#
		New() {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : H[]) {
			@values := H->New[values->Size()];
			@size := values->Size();
			Runtime->Copy(@values, 0, values, 0, @size);
 		}

		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : Vector<H>) {
			@values := values->ToArray();
			@size := values->Size();
		}

		method : Expand() ~ Nil {
			if(@size >= @values->Size()) {
				temp : H[] := H->New[@size << 1];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
		}

		#~
		Compresses the Vector freeing unused memory
		~#
		method : public : Compress() ~ Nil {
			temp : H[] := H->New[@size];
			Runtime->Copy(temp, 0, @values, 0, @size);
			@values := temp;
		}

		#~
		Maps the given function to each value in the vector 
		@param f function to apply
		@return newly calculated vector
		~#
		method : public : Map(f : (H) ~ H) ~ Vector<H> {
			array : H[] := H->New[@size];
			for(i : Int := 0; i < @size; i += 1;) {
				array[i] := f(@values[i]);
			};
      
			return Vector->New(array)<H>;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (H) ~ Nil) ~ Vector<H> {
			for(i : Int := 0; i < @size; i += 1;) {
				f(@values[i]);
			};
			return @self;
		}

		#~
		Returns a limited list
		@param l limit
		@return limited list
		~#
		method : public : Limit(l : Int) ~ Vector<H> {
			array := H->New[@size];

			if(l > -1 & l < @size) {
				array := H->New[l];
				for(i : Int := 0; i < l; i += 1;) {
					array[i] := @values[i];
				};
				return Vector->New(array)<H>;
			};
      		
			return Vector->New()<H>;
		}
		
		#~
		Swap two values in the vector
		@param a first value
		@param b second value
		@return true if values were swapped
		~#
		method : public : Swap(a : Int, b : Int) ~ Bool {
			if(a < -1 | b < -1 | a > @size | b > @size) {
				return false;
			};
			
			temp := @values[a];
			@values[a] := @values[b];
			@values[b] := temp;
			
			return true;
		}

		#~
		Adds a vector of values to the end of the vector
		@param values values to append 
		~#
		method : public : AddBack(values : Vector<H>) ~ Nil {
			max := values->Size() + @size;
			if(max >= @values->Size()) {
				temp : H[] := H->New[max << 1];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
			
			temp := values->ToArray();
			Runtime->Copy(@values, @size, temp, 0, temp->Size());
			@size := max;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : AddBack(value : H) ~ Nil {
			Expand();
			@values[@size] := value;
			@size += 1;
		}

		#~
		Removes the last value
		@return value
		~#
		method : public : RemoveBack() ~ H {
			if(@size > 0) {
				@size -= 1;
				return @values[@size];
			};
	
			return Nil;
		}
		
		#~
		Removes an indexed value
		@param i index
		@return value
		~#
		method : public : Remove(i : Int) ~ H {
			if(i > -1 & i < @size) {
				temp := H->New[@values->Size()];
				Runtime->Copy(temp, 0, @values, 0, i);
				Runtime->Copy(temp, i, @values, i + 1, @size - i - 1);
				value := @values[i];
				@values := temp;
				@size -= 1;
				return value;
			};
			
			return Nil;
		}

		#~
		Gets an indexed value
		@param index index
		@return value
		~#
		method : public : Get(index : Int) ~ H {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		#~
		Sets an indexed value
		@param value value
		@param index index
		~#
		method : public : Set(value : H, index : Int) ~ Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Size of vector
		@return size of vector
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Converts the vector into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array : H[] := H->New[@size];
			Runtime->Copy(array, 0, @values, 0, @size);
			return array;
		}
	}

	#~
	Growable array of comparable generics
	~#
	class CompareVector<H : Compare> {
		@values : H[];
		@size : Int;
		
		#~
		Default constructor 
		~#
		New() {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : H[]) {
			@values := H->New[values->Size()];
			@size := values->Size();
			Runtime->Copy(@values, 0, values, 0, @size);
 		}

		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : Vector<H>) {
			@values := values->ToArray();
			@size := values->Size();
		}

		method : Expand() ~ Nil {
			if(@size >= @values->Size()) {
				temp : H[] := H->New[@size << 1];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
		}
		
		#~
		Compresses the Vector freeing unused memory
		~#
		method : public : Compress() ~ Nil {
			temp : H[] := H->New[@size];
			Runtime->Copy(temp, 0, @values, 0, @size);
			@values := temp;
		}

		#~
		Maps the given function to each value in the vector 
		@param f function to apply
		@return newly calculated vector
		~#
		method : public : Map(f : (H) ~ H) ~ CompareVector<H> {
			array : H[] := H->New[@size];

			for(i : Int := 0; i < @size; i += 1;) {
				array[i] := f(@values[i]);
			};
      
			return CompareVector->New(array)<H>;
		}

		#~
		Returns a limited list
		@param l limit
		@return limited list
		~#
		method : public : Limit(l : Int) ~ CompareVector<H> {
			array := H->New[@size];

			if(l > -1 & l < @size) {
				array := H->New[l];
				for(i : Int := 0; i < l; i += 1;) {
					array[i] := @values[i];
				};
				return CompareVector->New(array)<H>;
			};
      		
			return CompareVector->New()<H>;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (H) ~ Nil) ~ CompareVector<H> {
			for(i : Int := 0; i < @size; i += 1;) {
				f(@values[i]);
			};
			return @self;
		}

		#~
		Adds a vector of values to the end of the vector
		@param values values to append 
		~#
		method : public : AddBack(values : Vector<H>) ~ Nil {
			max := values->Size() + @size;
			if(max >= @values->Size()) {
				temp : H[] := H->New[max << 1];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
			
			temp := values->ToArray();
			Runtime->Copy(@values, @size, temp, 0, temp->Size());
			@size := max;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : AddBack(value : H) ~ Nil {
			Expand();
			@values[@size] := value;
			@size += 1;
		}

		#~
		Removes the last value
		@return value
		~#
		method : public : RemoveBack() ~ H {
			if(@size > 0) {
				@size -= 1;
				return @values[@size];
			};
	
			return Nil;
		}
		
		#~
		Removes an indexed value
		@param i index
		@return value
		~#
		method : public : Remove(i : Int) ~ H {
			if(i > -1 & i < @size) {
				temp := H->New[@values->Size()];
				Runtime->Copy(temp, 0, @values, 0, i);
				Runtime->Copy(temp, i, @values, i + 1, @size - i - 1);
				value := @values[i];
				@values := temp;
				@size -= 1;
				return value;
			};
			
			return Nil;
		}

		#~
		Gets an indexed value
		@param index index
		@return value
		~#
		method : public : Get(index : Int) ~ H {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		#~
		Sets an indexed value
		@param value value
		@param index index
		~#
		method : public : Set(value : H, index : Int) ~ Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values := H->New[8];
			@size := 0;
		}
		
		#~
		Size of vector
		@return size of vector
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Sorts the values in the vector
		~#	
		method : public : native : Sort() ~ Nil {
			a : H[] := @values;
			b : H[] := H->New[@size];
			MergeSort(0, @size - 1, a, b);
		}
		
		method : MergeSort(low : Int, hi : Int, a : H[], b : H[]) ~ Nil {
			if(low < hi) {
				mid := (low + hi) >> 1;
				MergeSort(low, mid, a, b);
				MergeSort(mid + 1, hi, a, b);
				Merge(low, mid, hi, a, b);
			};	
		}
		
		method : native : Merge(low : Int, mid : Int, hi : Int, a : H[], b : H[]) ~ Nil {
			# copy both halves of a to auxiliary array b
			for(i := low; i <= hi; i += 1;) {
				b[i] := a[i];
			};

			i := low; 
			j := mid + 1; 
			k := low;
			
			# copy back next-greatest element at each time
			while(i <= mid & j <= hi) {
				if(b[i]->Compare(b[j]) < 0 | b[i]->Compare(b[j]) = 0) {
					a[k] := b[i];
					k := k + 1;
					i += 1;
				}
				else {
					a[k] := b[j];
					k := k + 1;
					j := j + 1;
				};
			};
			
			# copy back remaining elements of first half (if any)
			while(i <= mid) {
				a[k] := b[i];
				k := k + 1;
				i += 1;
			};
		}

		#~
		Finds a given value in the vector via linear search
		@param value value to search for
		@return index of found value, -1 if not found
		~#
		method : public : Find(value : H) ~ Int {
         for(i := 0; i < @size; i += 1;) {
            if(@values[i]->Compare(value) = 0) {
               return i;
            };
         };

         return -1;
      }
		
		#~
		Performs a binary search O(log n)
		@param value value to search for
		@return index of found value, -1 if not found
		~#
		method : public : native : BinarySearch(value : H) ~ Int {
			low := 0;
			high := @size - 1;

			while(low <= high) {
				mid := (low + high) >> 1;
      	
				if(@values[mid]->Compare(value) > 0) {
					high := mid - 1;
				}
				else if(@values[mid]->Compare(value) < 0) {
					low := mid + 1;
				}
				else {
					return mid;
				};
			};

			return -1;
		}
		
		#~
		Check of the given value is in the vector
		@param value value to check for
		@return true if found, false otherwise
		~#
		method : public : Has(value : H) ~ Bool {
			for(i : Int := 0; i < @size; i += 1;) {
				if(@values[i]->Compare(value) = 0) {
					return true;
				};
			};
			
			return false;
		}
		
		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered vector
		~#
		method : public : Filter(f : (H) ~ Bool) ~ CompareVector<H> {
			filtered := CompareVector->New()<H>;
			
			for(i : Int := 0; i < @size; i += 1;) {
				if(f(@values[i])) {
					filtered->AddBack(@values[i]);
				};
			};
			
			return filtered;
		}
		
		#~
		Converts the vector into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array : H[] := H->New[@size];
			Runtime->Copy(array, 0, @values, 0, @size);
			return array;
		}
	}
	
	#~
	Balanced tree of generics
	~#
	class Map<K : Compare, V> {
		@root : TreeNode<K, V>;
		@last : TreeNode<K, V>;
		@size : Int;

		#~
		Default constructor 
		~#
		New() {
			@root := Nil;
			@size := 0;	
		}		

		method : native : Skew(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node = Nil | node->GetLeft() = Nil) {
				return node;
			};
				
			if(node->GetLeft()->GetLevel() = node->GetLevel()) {
				left : TreeNode<K, V> := node->GetLeft();
				node->SetLeft(left->GetRight());
				left->SetRight(node);
				return left;
			};
			
			return node;
		}

		#~
		Size of queue
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the map is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}

		#~
		Clears the map
		~#
		method : public : Empty() ~ Nil {
			@root := Nil;
			@last := Nil;
			@size := 0;
		}
		
		method : native : Split(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node = Nil | node->GetRight() = Nil | 
					node->GetRight()->GetRight() = Nil) {
				return node;
			};

			if(node->GetRight()->GetRight()->GetLevel() = node->GetLevel()) {
				right : TreeNode<K, V> := node->GetRight();
				node->SetRight(right->GetLeft());
				right->SetLeft(node);
				right->SetLevel(right->GetLevel() + 1);
				
				return right;
			};
			
			return node;
		}
		
		#~
		Creates a map from a vector of keys and values
		@param keys keys
		@param values values
		@return map of key/value pairs
		~#
		function : Zip(keys : CompareVector<K>, values : Vector<V>) ~ Map<K,V> {			
			if(keys->Size() = values->Size()) {
				zip := Map->New()<K,V>;
				each(i : keys) {
					zip->Insert(keys->Get(i), values->Get(i));
				};
				return zip;
			};

			return Nil;
		}

		#~
		Searches for a value in a map
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : Find(key : K) ~ V {
			return Find(key, @root);
		}
		
		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return Find(key, @root) <> Nil;
		}
		
		method : Find(key : K, node : Collection.Generic.TreeNode<K, V>) ~ V {
			if(node <> Nil) {
				if(key->Compare(node->GetKey()) < 0) {
					return Find(key, node->GetLeft());
				}
				else if(key->Compare(node->GetKey()) > 0) {
					return Find(key, node->GetRight());
				}
				else {
					return node->Get();		
				};
			};
			
			return Nil;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (K, V) ~ Nil) ~ Map<K, V> {
			Each(@root, f);
			return @self;
		}

		method : Each(node : Collection.Generic.TreeNode<K, V>, f : (K, V) ~ Nil) ~ Nil {
			if(node <> Nil) {
				# process left 
				Each(node->GetLeft(), f);
				
				key := node->GetKey()->As(Clone)->Clone();
				value := node->Get();
				f(key->As(Compare), value);
				
				# process right
				Each(node->GetRight(), f);
			};
        }
        
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~  Collection.Generic.Vector<K> {
			vector := Vector->New()<K>;
			GetKeys(@root, vector);
			return vector;
		}

		method : GetKeys(node : Collection.Generic.TreeNode<K, V>, vector : Collection.Generic.Vector<K>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetKeys(node->GetLeft(), vector);
				
				key : K := node->GetKey();
				vector->AddBack(key);
				
				# process right
				GetKeys(node->GetRight(), vector);
			};
		}
        
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeyValues() ~  Collection.Generic.Vector<Pair<K,V>> {
			vector := Vector->New()<Pair<K,V>>;
			GetKeyValues(@root, vector);
			return vector;
		}

		method : GetKeyValues(node : Collection.Generic.TreeNode<K, V>, vector : Collection.Generic.Vector<Pair<K,V>>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetKeyValues(node->GetLeft(), vector);
				
				key : K := node->GetKey();
                value : V := node->Get();
                
				vector->AddBack(Pair->New(key, value)<K,V>);
				
				# process right
				GetKeyValues(node->GetRight(), vector);
			};
		}
        
		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~  Collection.Generic.Vector<V> {
			vector := Vector->New()<V>;
			GetValues(@root, vector);
			return vector;
		}

		method : GetValues(node : Collection.Generic.TreeNode<K, V>, vector : Collection.Generic.Vector<V>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetValues(node->GetLeft(), vector);
				
				value : V := node->Get();
				vector->AddBack(value);
				
				# process right
				GetValues(node->GetRight(), vector);
			};
		}
        
		#~
		Inserts a value into the map
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			if(@root = Nil) {
				@root := Insert(key, value, Nil->As(Collection.Generic.TreeNode<K, V>));
			}
			else {
				@root := Insert(key, value, @root);
			};
		}
		
		method : Insert(key : K, value : V, node : Collection.Generic.TreeNode<K, V>) ~  Collection.Generic.TreeNode<K, V> {
			if(node = Nil) {
				node := TreeNode->New(key, value, 1)<K, V>;
				@size += 1;
			}
			else {
				if(key->Compare(node->GetKey()) < 0) {
					node->SetLeft(Insert(key, value, node->GetLeft()));
				}
				else if(key->Compare(node->GetKey()) > 0) {
					node->SetRight(Insert(key, value, node->GetRight()));
				}
				else {
					return node;		
				};
				node := Skew(node);
				node := Split(node);
			};	
			
			return node;
		}
		
		#~
		Removes a value from the map
		@param key key for value to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			if(@root->GetLeft() = Nil & @root->GetRight() = Nil & key->Compare(@root->GetKey()) = 0) {
				@root := Nil;
				@size := 0;
				return true;
			};
			
			node := Remove(key, @root);
			if(node = Nil) {
				return false;
			};
			
			@root := node;
			@size -= 1;
			return true;
		}
		
		method : native : Remove(key : K, node : Collection.Generic.TreeNode<K, V>) ~  Collection.Generic.TreeNode<K, V> {
			if(node = Nil) {
				return Nil;
			};

			if(key->Compare(node->GetKey()) < 0) {
				node->SetLeft(Remove(key, node->GetLeft()));
			}
			else if(key->Compare(node->GetKey()) > 0) {
				node->SetRight(Remove(key, node->GetRight()));
			}
			else {
				if(node->GetLeft() = Nil & node->GetRight() = Nil) {
					return Nil;
				}
				else if(node->GetLeft() = Nil) {
					temp : TreeNode<K, V> := Successor(node);
					node->SetRight(Remove(temp->GetKey(), node->GetRight()));
					node := temp;
				} 
				else {
					temp : TreeNode<K, V> := Predecessor(node);
					node->SetLeft(Remove(temp->GetKey(), node->GetLeft()));
					node := temp;
				};
				
			};
			
			# rebalanced
			node := DecreaseLevel(node);				
			node := Skew(node);
			node->SetRight(Skew(node->GetRight()));
			if(node->GetRight() <> Nil & node->GetRight()->GetRight() <> Nil) {
				node->GetRight()->SetRight(Skew(node->GetRight()->GetRight()));
			};	
			node := Split(node);								
			node->SetRight(Split(node->GetRight()));

			return node;
		}
		
		method : Predecessor(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetLeft() <> Nil) {
				left : TreeNode<K, V> := node->GetLeft();
				while(left->GetLeft() <> Nil) {
					left := left->GetLeft();
				};

				return left;
			};

			return node;
		}

		method : Successor(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetRight() <> Nil) {
				right : TreeNode<K, V> := node->GetRight();
				while(right->GetRight() <> Nil) {
					right := right->GetRight();
				};

				return right;
			};

			return node;
		}

		 method : DecreaseLevel(node : Collection.Generic.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetLeft() <> Nil & node->GetRight() <> Nil) {
				left : Int := node->GetLeft()->GetLevel();
				right : Int := node->GetRight()->GetLevel();
				value : Int := Int->Min(left, right);
			
				if(value < node->GetLevel()) {
					node->SetLevel(value);
					if(value < node->GetRight()->GetLevel()) {
						node->GetRight()->SetLevel(value);
					};
				};
			};
			
			return node;
		}
		
		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered map
		~#
		method : public : Filter(f : (K) ~ Bool) ~ Map<K, V> {
			filtered := Map->New()<K, V>;
			
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				if(f(key)) {
					value := Find(key);
					filtered->Insert(key, value);
				};
			};
			
			return filtered;
		}
	}
	
	class : private : TreeNode<K : Compare, V> {
		@key : K;
		@value : V;
		@left : TreeNode<K, V>;
		@right : TreeNode<K, V>;
		@level : Int;
		
		New(key : K, value : V, level : Int) {
			@key := key;
			@value := value;
			@level := level;
			@left := Nil;
			@right := Nil;
		}

		method : public : SetKey(key : K) ~ Nil {
			@key := key;
		}
		
		method : public : GetKey() ~ K {
			return @key;
		}

		method : public : Get() ~ V {
			return @value;
		}
		
		method : public : GetLevel() ~ Int {
			return @level;
		}

		method : public : SetLevel(level : Int) ~ Nil {
			@level := level;
		}

		method : public : GetLeft() ~ TreeNode<K, V> {
			return @left;
		}

		method : public : SetLeft(left : TreeNode<K, V>) ~ Nil {
			@left := left;
		}

		method : public : GetRight() ~ TreeNode<K, V> {
			return @right;
		}

		method : public : SetRight(right : TreeNode<K, V>) ~ Nil {
			@right := right;
		}
	}
	
	#~
	Set of objects
	~#
	class Set<K : Compare> {
		@map : Map<K, Base>;

		#~
		Default constructor 
		~#
		New() {
			@map := Map->New()<K, Base>;
		}

		#~
		Inserts a key into the set
		@param key key
		~#
		method : public : Insert(key : K) ~ Nil {
			@map->Insert(key, Base->New());
		}
		
		#~
		Removes a key from the set
		@param key key for value to remove
		@return true if removed, false otherwise		
		~#
		method : public : Remove(key : K) ~ Bool {
			return @map->Remove(key);
		}
    
    	#~
		Checks for key in set
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return @map->Find(key) <> Nil;
		}
    
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @map->GetKeys();
		}

		#~
		Clears the set
		~#
		method : public : Empty() ~ Nil {
			@map->Empty();
		}

		#~
		Checks to see if the set is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @map->IsEmpty();
		}
		
		#~
		Size of map
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @map->Size();
		}
	}

	#~
	Binary tree that holds multiple values with the same key
	~#
	class MultiMap<K : Compare, V> {
		@map : Map<K, Vector<V> >;

		#~
		Default constructor 
		~#
		New() {
			@map := Map->New()<K, Vector<V> >;
		}

		#~
		Inserts a value into the map
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			values := Find(key);
			if(values = Nil) {
				values := Vector->New()<V>;
				@map->Insert(key, values);
			};

			values->AddBack(value);
		}

		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#	
		method : public : Find(key : K) ~ Vector<V> {
			return @map->Find(key);
		}

		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @map->GetKeys();
		}

		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~ Vector<V> {
			values := Vector->New()<V>;

			keys := @map->GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				local_values := @map->Find(key)<V>;
				each(j : local_values) {
					values->AddBack(local_values->Get(j));
				};
			};

			return values;
		}

		#~
		Checks to see if the map is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @map->Size() = 0;
		}

		#~
		Clears the set
		~#
		method : public : Empty() ~ Nil {
			@map->Empty();
		}

		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return Find(key) <> Nil;
		}

		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filter vector
		~#
		method : public : Filter(f : (K) ~ Bool) ~ MultiMap<K, V> {
			filtered := MultiMap->New()<K, V>;
			
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				if(f(key)) {
					values := Find(key);
					each(j : values) {
						filtered->Insert(key, values->Get(j));
					};
				};
			};
			
			return filtered;
		}

		#~
		Creates a map from a vector of keys and values
		@param keys keys
		@param values values
		@return map of key/value pairs
		~#
		function : Zip(keys : CompareVector<K>, values : Vector<V>) ~ MultiMap<K,V> {			
			if(keys->Size() = values->Size()) {
				zip := MultiMap->New()<K,V>;
				each(i : keys) {
					zip->Insert(keys->Get(i), values->Get(i));
				};
				return zip;
			};

			return Nil;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (K, V) ~ Nil) ~ MultiMap<K, V> {
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i)->As(Clone)->Clone();
				values := Find(key->As(Compare));
				each(j : values) {
					f(key->As(Compare), values->Get(j));
				};
			};
			return @self;
		}

		#~
		Removes a set of values from the map
		@param key key for values to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			return @map->Remove(key);
		}
		
		#~
		Size of unique keys
		@return size of unique keys
		~#
		method : public : Size() ~ Int {
			return @map->Size();
		}

		#~
		Size of values
		@return size of values
		~#
		method : public : TotalSize() ~ Int {
			return @map->GetValues()->Size();
		}
	}

	class Func2Composer<X, R> {
		@func : Func2Holder<X, R>;

		New(first : Func2Holder<X, R>) {
			@func := first;
		}

		method : public : Apply(x : X) ~ R {		
			func := @func->Get();
			return func(x);
		}

		method : public : Compose(before : Func2Holder<Base, X>) ~ Func2Composer<Base, R> {
			return Nil;
		}
	}
}
