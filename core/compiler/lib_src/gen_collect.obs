#~~
# Generic collections for Objeck
# Copyright (c) 2024 Randy Hollines
# 
# credits:
# - H.W. Lang - merge sort implementation based on his work
# - Arne Andersson - map classes use a red-black tree variant he created
# - Snark Bait - heap implementation based on his work
~#

#~
Tuple classes (-lib gen_collect)
~#	
bundle Collection.Tuple {
	#~
	Tuple class that supports 2 values
	~#
	class Pair<A, B> {
		@a : A;
		@b : B;

		#~
		Constructor.
		@param a first parameter
		@param b second parameter
		~#
		New(a : A, b : B) {
			@a := a;
			@b := b;
		}

		#~
		Returns the first value
		@return first value
		~#
		method : public : GetFirst() ~ A {
			return @a;
		}

		#~
		Returns the second value
		@return second value
		~#
		method : public : GetSecond() ~ B {
			return @b;
		}

		#~
		Formats tuple into a string
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			if(@a = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@a->TypeOf(Stringify)) {
					buffer->Append(@a->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@a->GetInstanceID()->ToHexString());
				};
			}

			buffer += ',';

			if(@b = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@b->TypeOf(Stringify)) {
					buffer->Append(@b->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@b->GetInstanceID()->ToHexString());
				};
			}

			buffer += "]";

			return buffer;
		}
	}
	
	#~
	Tuple class that supports 3 values
	~#
	class Triplet<A, B, C> {
		@a : A;
		@b : B;
		@c : C;

		#~
		Constructor.
		@param a first parameter
		@param b second parameter
		@param c third parameter
		~#
		New(a : A, b : B, c : C) {
			@a := a;
			@b := b;
			@c := c;
		}

		#~
		Returns the first value
		@return first value
		~#
		method : public : GetFirst() ~ A {
			return @a;
		}

		#~
		Returns the second value
		@return second value
		~#
		method : public : GetSecond() ~ B {
			return @b;
		}

		#~
		Returns the third value
		@return third value
		~#
		method : public : GetThird() ~ C {
			return @c;
		}

		#~
		Formats tuple into a string
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			if(@a = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@a->TypeOf(Stringify)) {
					buffer->Append(@a->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@a->GetInstanceID()->ToHexString());
				};
			};

			buffer += ',';

			if(@b = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@b->TypeOf(Stringify)) {
					buffer->Append(@b->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@b->GetInstanceID()->ToHexString());
				};
			};

			buffer += ',';

			if(@c = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@c->TypeOf(Stringify)) {
					buffer->Append(@c->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@c->GetInstanceID()->ToHexString());
				};
			};

			buffer += "]";

			return buffer;
		}
	}
	
	#~
	Tuple class that supports 4 values
	~#
	class Quartet<A, B, C, D> {
		@a : A;
		@b : B;
		@c : C;
		@d : D;

		#~
		Constructor.
		@param a first parameter
		@param b second parameter
		@param c third parameter
		@param d forth parameter
		~#
		New(a : A, b : B, c : C, d : D) {
			@a := a;
			@b := b;
			@c := c;
			@d := d;
		}

		#~
		Returns the first value
		@return first value
		~#
		method : public : GetFirst() ~ A {
			return @a;
		}

		#~
		Returns the second value
		@return second value
		~#
		method : public : GetSecond() ~ B {
			return @b;
		}

		#~
		Returns the third value
		@return third value
		~#
		method : public : GetThird() ~ C {
			return @c;
		}

		#~
		Returns the forth value
		@return forth value
		~#
		method : public : GetForth() ~ D {
			return @d;
		}

		#~
		Formats tuple into a string
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			if(@a = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@a->TypeOf(Stringify)) {
					buffer->Append(@a->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@a->GetInstanceID()->ToHexString());
				};
			};
			buffer += ',';

			if(@b = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@b->TypeOf(Stringify)) {
					buffer->Append(@b->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@b->GetInstanceID()->ToHexString());
				};
			};

			buffer += ',';

			if(@c = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@c->TypeOf(Stringify)) {
					buffer->Append(@c->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@c->GetInstanceID()->ToHexString());
				};
			};
			buffer += ',';

			if(@d = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@d->TypeOf(Stringify)) {
					buffer->Append(@d->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@d->GetInstanceID()->ToHexString());
				};
			};

			buffer += "]";

			return buffer;
		}
	}

	#~
	Quintet class that supports 5 values
	~#
	class Quintet <A, B, C, D, E> {
		@a : A;
		@b : B;
		@c : C;
		@d : D;
		@e : E;

		#~
		Constructor.
		@param a first parameter
		@param b second parameter
		@param c third parameter
		@param d forth parameter
		@param e fifth parameter
		~#
		New(a : A, b : B, c : C, d : D, e : E) {
			@a := a;
			@b := b;
			@c := c;
			@d := d;
			@e := e;
		}

		#~
		Returns the first value
		@return first value
		~#
		method : public : GetFirst() ~ A {
			return @a;
		}

		#~
		Returns the second value
		@return second value
		~#
		method : public : GetSecond() ~ B {
			return @b;
		}

		#~
		Returns the third value
		@return third value
		~#
		method : public : GetThird() ~ C {
			return @c;
		}

		#~
		Returns the forth value
		@return forth value
		~#
		method : public : GetForth() ~ D {
			return @d;
		}

		#~
		Returns the fith value
		@return fith value
		~#
		method : public : GetFith() ~ E {
			return @e;
		}

		#~
		Formats tuple into a string
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			if(@a = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@a->TypeOf(Stringify)) {
					buffer->Append(@a->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@a->GetInstanceID()->ToHexString());
				};
			};
			buffer += ',';

			if(@b = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@b->TypeOf(Stringify)) {
					buffer->Append(@b->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@b->GetInstanceID()->ToHexString());
				};
			};

			buffer += ',';

			if(@c = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@c->TypeOf(Stringify)) {
					buffer->Append(@c->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@c->GetInstanceID()->ToHexString());
				};
			};
			buffer += ',';

			if(@d = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@d->TypeOf(Stringify)) {
					buffer->Append(@d->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@d->GetInstanceID()->ToHexString());
				};
			};
			buffer += ',';

			if(@e = Nil) {
				buffer += "<Nil>";
			}
			else {
				if(@e->TypeOf(Stringify)) {
					buffer->Append(@e->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(@e->GetInstanceID()->ToHexString());
				};
			};
			
			buffer += "]";

			return buffer;
		}
	}
}

#~
Generic collection framework (-lib gen_collect)
~#	
bundle Collection {
	#~
	Generic binary heap

```
heap := Collection.Heap->New(Collection.Heap->Order->MIN)<IntRef>;
        
heap->Insert(IntRef->New(3));
heap->Insert(IntRef->New(1));
heap->Insert(IntRef->New(9));
heap->Insert(IntRef->New(8));
heap->Insert(IntRef->New(6));
heap->Insert(IntRef->New(2));

while(<>heap->IsEmpty()) {
   heap->Pop()->PrintLine();
};
```
	~#
	class Heap<H : Compare> {
		@heap : H[];
		@length : Int;
		@min : Bool;

		#~
		Heap sort order
		@class Heap
		~#
		enum Order {
			MIN,
			MAX
		}

		#~
		Constructor
		@param array array of values to insert
		@param order sort order
		~#
		New(array : H[], order : Heap->Order) {
			@heap := H->New[5];
			@length := 0;
			@min := order = Heap->Order->MIN ? true : false;

			each(elem in array) {
				Insert(elem);
			};
		}

	   #~
		Constructor
		@param order sort order
		~#
		New(order : Heap->Order) {
			@heap := H->New[5];
			@length := 0;
			@min := order = Heap->Order->MIN ? true : false;
		}

		#~
		Returns a list of non-Nil values
		@return list of values
		~#
		method : public : ToArray() ~ H[] {        
			buffer := H->New[@length];

			i := 0;
			each(elem := @heap) {
				if(elem <> Nil) {
					buffer[i++] := elem;
				};
			};

			return buffer;
		}

		#~
		Returns the heap capacity
		@return heap capacity
		~#
		method : public : Capacity() ~ Int {
			return @heap->Size();
		}

		#~
		Inserts a value into the heap and extends the heap size if necessary
		@param value value to insert
		~#
		method : public : Insert(value : H) ~ Nil {
			if(@length >= @heap->Size() - 1) {
				@heap := Resize();
			};

			@length++;
			@heap[@length] := value;

			ShiftUp();
		}

		#~
		Pop either the smallest or largest value depending upon the sort order
		@return smallest or largest value
		~#
		method : public : Pop() ~ H {
			result := Top();
			if(result = Nil) {
				return Nil;
			};

			Swap(1, @length);
			@heap[@length] := Nil;
			@length--;

			ShiftDown();

			return result;
		}

		#~
		Searches and pops the given value
		@param value value to remove
		@return true if successful, false otherwise
		~#
		method : public : Pop(value : H) ~ Bool {
			each(i : @heap) {
				elem := @heap[i];
				if(elem <> Nil) {
					if(value->Compare(elem) = 0) {
						Swap(i, @length);
						@heap[@length] := Nil;
						@length--;

						ShiftDown();

						return true;
					};
				};
			};

			return false;
		}

		#~
		Checks to see if the heap is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @length <= 0;
		}

		#~
		Check the top of the stack
		@return value on the top of stack, Nil if stack is empty
		~#
		method : public : Top() ~ H {
			if(IsEmpty()) {
				return Nil;
			};

			return @heap[1];
		}

		#~
		Size of heap, including Nil values
		@return size of heap
		~#
		method : public : Size() ~ Int {
			return @length;
		}

		method : Resize() ~ H[] {
			temp := H->New[@heap->Size() + @heap->Size() / 2];

			each(i : @heap) {
				elem := @heap[i];
				temp[i] := elem;
			};

			return temp;
		}

		method : ShiftUp() ~ Nil {
			index := @length;
			if(@min) {
				while(HasParent(index) & (GetParent(index)->Compare(@heap[index]) > 0)) {
					Swap(index, GetParentIndex(index));
					index := GetParentIndex(index);
				}   
			}
			else {
				while(HasParent(index) & (GetParent(index)->Compare(@heap[index]) < 0)) {
					Swap(index, GetParentIndex(index));
					index := GetParentIndex(index);
				};  
			};
		}

		method : ShiftDown() ~ Nil {
			index := 1;
			if(@min) {
				while(HasLeftChild((index))) {
					smaller := GetLeftIndex(index);
					if(HasRightChild(index) & @heap[GetLeftIndex(index)]->Compare(@heap[GetRightIndex(index)]) > 0) {
						smaller := GetRightIndex(index);
					}

					if(@heap[index]->Compare(@heap[smaller]) > 0) {
						Swap(index, smaller);
					}
					else {
						break;
					};
					index := smaller;
				}               
			}
			else {
				while(HasLeftChild((index))) {
					larger := GetLeftIndex(index);
					if(HasRightChild(index) & @heap[GetLeftIndex(index)]->Compare(@heap[GetRightIndex(index)]) < 0) {
						larger := GetRightIndex(index);
					}

					if(@heap[index]->Compare(@heap[larger]) < 0) {
						Swap(index, larger);
					}
					else { 
						break;
					};
					index := larger;
				}               
			}
		}

		method : HasParent(i : Int) ~ Bool {
			return i > 1;
		}

		method : GetLeftIndex(i : Int)  ~ Int {
			return i * 2;
		}

		method : GetRightIndex(i : Int) ~ Int {
			return i * 2 + 1;
		}

		method : HasLeftChild(i : Int) ~ Bool {
			return GetLeftIndex(i) <= @length;
		}

		method : HasRightChild(i : Int) ~ Bool {
			return GetRightIndex(i) <= @length;
		}

		method : GetParentIndex(i : Int) ~ Int {
			return i / 2;
		}

		method : GetParent(i : Int) ~ H {
			return @heap[GetParentIndex(i)];
		}

		method : Swap(index1 : Int, index2 : Int) ~ Nil {
			temp := @heap[index1];
			@heap[index1] := @heap[index2];
			@heap[index2] := temp;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			for(i := 0; i < @heap->Size(); i += 1;) {
				elem := @heap[i];

				if(elem <> Nil) {
					if(elem->TypeOf(Stringify)) {
						buffer->Append(elem->As(System.Stringify)->ToString());
					}
					else {
						buffer->Append(elem->GetInstanceID()->ToHexString());
					};

					if(i + 1 < @heap->Size() & @heap[i + 1] <> Nil) {
						buffer->Append(',');
					};
				};
			};
			buffer->Append(']')

			return buffer;
		}
	}

	#~
	MRU/LRU object cache
	
	```
cache := Collection.Cache->New(Cache->Type->LRU, 3)<IntRef, String>;
cache->Insert(415, "San Francisco");
cache->Insert(925, "East Bay");
cache->Insert(650, "Mountain View");

cache->Find(650)->PrintLine();
cache->Find(650)->PrintLine();

cache->Find(415)->PrintLine();

cache->Find(925)->PrintLine();
cache->Find(925)->PrintLine();

cache->Insert(510, "Oakland");
cache->Find(510)->PrintLine();
cache->Find(510)->PrintLine();
cache->Find(510)->PrintLine();

"---"->PrintLine();
values := cache->GetKeys()<IntRef>;
each(value := values) {
   value->PrintLine();
};
	```	
	~#
	class Cache<K : Compare, S> {
		@type : Cache->Type;
		@max : Int;
		@cache : Map<K, S>;
		@priority : CompareList<K>;

		#~
		Cache type
		@class Cache
		~#
		enum Type {
			LRU,
			MRU
		}

		#~
		Default constructor
		@param type MRU or LRU cache
		@param max cache max size
		~#
		New(type : Cache->Type, max : Int) {
			@type := type;
			@max := max;
			@cache := Map->New()<K, S>;
			@priority := CompareList->New()<K>;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			return @cache->ToString();
		}

		#~
		Inserts a value into the hash
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : S) ~ Bool {
			if(key = Nil) {
				return false;
			};

			if(@priority->Size() < @max) {
				@priority->Rewind();
				found := @priority->Find(key);
				if(found <> Nil) {
					@priority->Remove();
				}
				else {
					@cache->Insert(key, value);
					@priority->AddFront(key);
				};

				return true;
			}
			else if(Remove()) {
				@priority->AddFront(key);
				@cache->Insert(key, value);

				return true;
			};

			return false;
		}

		#~
		Removes a value from the cache
		@param key key for value to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			if(@cache->Has(key)) {
				@priority->Find(key);
				@priority->Remove();
				@cache->Remove(key);

				return true;
			};

			return false;
		}

		method : Remove() ~ Bool {
			if(<>@priority->IsEmpty()) {
				removed : K;

				if(@type = Cache->Type->LRU) {
					removed := @priority->Back();
					@priority->RemoveBack();
				}
				else {
					removed := @priority->Front();
					@priority->RemoveFront();
				};
				@cache->Remove(removed);
				
				return true;
			};
			
			return false;
		}

		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @cache->GetKeys()<K>;
		}

		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~ Vector<S> {
			return @cache->GetValues()<S>;
		}

		#~
		Gets a collection of key/value pairs
		@return vector of key/value pairs
		~#
		method : public : GetKeyValues() ~ Vector<Pair<K, S>> {
			return @cache->GetKeyValues()<Pair<K, S>>;
		}

		#~
		Searches for a value in cache
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : Find(key : K) ~ S {
			return @cache->Find(key);
		}

		#~
		Checks for a value in a cache
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return @cache->Find(key) <> Nil;
		}

		#~
		Size of cache
		@return size of cache
		~#
		method : public : Size() ~ Int {
			return @cache->Size();
		}

		#~
		Checks to see if the cache is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @cache->IsEmpty();
		}

		#~
		Clears the cache
		~#
		method : public : Empty() ~ Nil {
			@cache->Empty();
			@priority->Empty();
		}
	}
	
	#~
	Collection pair
	~#
	class Pair<F : Compare, S> implements System.Compare, System.Stringify {
		@first : F;
		@second : S;

		#~
		Default constructor
		@param first compare object
		@param second object
		~#
		New(first : F, second : S) {
			@first := first;
			@second := second;
		}

		#~
		Compares two objects based upon first value
		@param first compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(first : System.Compare) ~ Int {
			return @first->Compare(first);
		}
		
		#~
		Returns the class default hash ID
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @first->GetInstanceID();
		}

		#~
		Gets the first value
		@return first value
		~#
		method : public : GetFirst() ~ F {
			return @first;
		}

		#~
		Sets the first value
		@param first first value
		~#
		method : public : SetFirst(first : F) ~ Nil {
			@first := first;
		}

		#~
		Gets the second value
		@return second value
		~#
		method : public : GetSecond() ~ S {
			return @second;
		}

		#~
		Sets the second value
		@param second second value
		~#
		method : public : SetSecond(second : S) ~ Nil {
			@second := second;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "{";

			if(@first->TypeOf(Stringify)) {
				buffer->Append(@first->As(System.Stringify)->ToString());
			}
			# use instance ID instead
			else {
				buffer->Append(@first->GetInstanceID()->ToHexString());
			};

			buffer += ',';

			if(@second->TypeOf(Stringify)) {
				buffer->Append(@second->As(System.Stringify)->ToString());
			}
			# use instance ID instead
			else {
				buffer->Append(@second->GetInstanceID()->ToHexString());
			};

			buffer += "}";

			return buffer;
		}
	}

	#~
	Hash unordered table of generics
	
	```
# insert elements
hash := Collection.Hash->New()<IntRef, String>;
hash->Insert(415, "San Francisco");
hash->Insert(510, "Oakland");
hash->Insert(925, "East Bay");

# get size
hash->Size()->PrintLine();

# get value by key
hash->Find(510)->PrintLine();

# get key/values
key_values := hash->GetKeyValues()<Pair<IntRef, String>>;
each(key_value := key_values) {
   key_value->GetFirst()->PrintLine();
};

# get values
values := hash->GetValues()<String>;
each(value := values) {
   value->PrintLine();
};

# check for key
hash->Has(408)->PrintLine();
    ```
	~#
	class Hash<K : Compare, V> {
		@buckets : CompareList[]<K>;
		@size : Int;
		@capacity : Int;
		@auto_resize : Bool;

		#~
		Hash table capacity. Load factors: SMALL=500, MEDIUM=9k, LARGE=900k, EX_LARGE=9M, HUGE=90M
		@class Hash
		~#
		consts Capacity {
			SMALL := 769,
			MEDIUM := 12289,
			LARGE := 1572869,
			EX_LARGE := 12582917,
			HUGE := 100663319
		}
		
		#~
		Default constructor 
		@param auto_resize if true, automatically resized the hash table
		~#
		New(auto_resize : Bool := true) {
			@auto_resize := auto_resize;

			@capacity := Capacity->SMALL;
			@buckets := CompareList->New[@capacity]<K>;
			@size := 0;
		}
		
		#~
		Default constructor 
		@param capacity capacity of hash table
		@param auto_resize if true, automatically resized the hash table
		~#
		New(capacity : Hash->Capacity, auto_resize : Bool := true) {
			@capacity := capacity;
			@auto_resize := auto_resize;
			
			@buckets := CompareList->New[@capacity]<K>;
			@size := 0;
		}
		
		#~
		Converts a vector pairs to a hash
		@param pairs vector of pairs
		@return hashed pairs
		~#
		function : Dict(pairs : Vector<Collection.Tuple.Pair<K, V>>) ~ Hash<K, V> {
			dict := Hash->New()<K, V>;

			each(pair in pairs) {
				k := pair->GetFirst();
				v := pair->GetSecond();
				dict->Insert(k, v);
			};

			return dict;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			pairs := GetKeyValues()<Pair<K,V>>;
			each(i : pairs) {
				# get string value if instance implements 'Stringify'
				pair := pairs->Get(i)<Pair<K,V>>;

				key := pair->GetFirst();
				if(key->TypeOf(Stringify)) {
					buffer->Append('(');
					buffer->Append(key->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append('(');
					buffer->Append(key->GetInstanceID()->ToHexString());
				};

				buffer->Append(':');

				value := pair->GetSecond();
				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
					buffer->Append(')');
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
					buffer->Append(')');
				};

				# add comma
				if(i + 1 < pairs->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}
		
		#~
		Inserts a value into the hash
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			if(key = Nil) {
				return;
			};

			if(@auto_resize) {
				select(@size + 1) {
					label 32: {
						Resize(Hash->Capacity->MEDIUM);
					}

					label 256: {
						Resize(Hash->Capacity->LARGE);
					}

					label 2048: {
						Resize(Hash->Capacity->EX_LARGE);
					}

					label 16384: {
						Resize(Hash->Capacity->HUGE);
					}
				};
			};

			hash := (key->HashID() % @buckets->Size())->Abs();
			list := @buckets[hash];
			if(list = Nil) {
				list := CompareList->New()<K>;
				@buckets[hash] := list;
			};

			list->AddBack(HashPair->New(key->As(Compare), value)<V>);
			@size += 1;
		}

		#~
		Searches for a value in a hash
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : native : Find(key : K) ~ V {
			hash := (key->HashID() % @buckets->Size())->Abs();
			list := @buckets[hash];
			if(list <> Nil) {
				list->Rewind();
				while(list->More()) {
					pair : HashPair<V> := list->Get()<V>;
					if(pair->Compare(key) = 0) {
						return pair->Get();
					};
					list->Next();
				};

				return Nil;
			};

			return Nil;
		}

		#~
		Gets the hash table capacity
		@return hash table capacity
		~#
		method : public : GetCapacity() ~ Hash->Capacity {
			return @capacity;
		}

		#~
		Sets hash table capacity
		@param capacity hash table capacity
		~#
		method : public : SetCapacity(capacity : Hash->Capacity) ~ Nil {
			@capacity := capacity;
		}

		#~
		Gets auto-resize setting
		@return true if auto-resize is set, false otherwise
		~#
		method : public : IsAutoResize() ~ Bool {
			return @auto_resize;
		}

		#~
		Set auto-resize setting
		@param auto_resize true if auto-resize is enable, false otherwise
		~#
		method : public : SetAutoResize(auto_resize : Bool) ~ Nil {
			@auto_resize := auto_resize;
		}

		#~
		Resizes the hash table
		@param capacity table capacity
		@param auto_resize true for hash table auto resizing, false otherwise
		~#
		method : public : native : Resize(capacity : Hash->Capacity, auto_resize : Bool := true) ~ Nil {
			@capacity := capacity;
			@auto_resize := auto_resize;

			temp_buckets := CompareList->New[@capacity]<K>;
			for(i := 0; i < @buckets->Size(); i += 1;) {
				list := @buckets[i];
				if(list <> Nil) {
					list->Rewind();
					while(list->More()) {
						# get key/value
						pair : HashPair<V> := list->Get()<V>;
						
						# insert key/value
						hash := (pair->GetKey()->HashID() % temp_buckets->Size())->Abs();

						temp_list := temp_buckets[hash];
						if(temp_list = Nil) {
							temp_list := CompareList->New()<K>;
							temp_buckets[hash] := temp_list;
						};
						temp_list->AddBack(pair);

						list->Next();
					};
				};
			};

			@buckets := temp_buckets;
		}
		
		#~
		Checks for a value in a hash
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			result := Find(key);
			return result <> Nil;
		}
		
		#~
		Removes a value from the hash
		@param key key for value to remove
		~#
		method : public : native : Remove(key : K) ~ Bool {
			hash := (key->HashID() % @buckets->Size())->Abs();
			list := @buckets[hash];
			if(list <> Nil) {
				list->Rewind();
				while(list->More()) {
					pair : HashPair<V> := list->Get()<V>;
					if(pair->Compare(key) = 0) {
						list->Remove();
						@size -= 1;

						if(@auto_resize) {
							select(@size) {
								label 32: {
									Resize(Hash->Capacity->SMALL);
								}

								label 256: {
									Resize(Hash->Capacity->MEDIUM);
								}

								label 2048: {
									Resize(Hash->Capacity->LARGE);
								}

								label 16384: {
									Resize(Hash->Capacity->EX_LARGE);
								}
							};
						};

						return true;
					};

					list->Next();
				};

				return false;
			};

			return false;
		}
		
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : native : GetKeys() ~ Vector<K> {
			keys := Vector->New()<K>;
			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						pair : HashPair<V> := list->Get()<V>;
						keys->AddBack(pair->GetKey());
						list->Next();
					};
				};
			};
			
			return keys;
		}
		
		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : native : GetValues() ~ Vector<V> {
			values := Vector->New()<V>;
			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						pair : HashPair<V> := list->Get()<V>;
						values->AddBack(pair->Get());
						list->Next();
					};
				};
			};
			
			return values;
		}

		#~
		Gets a collection of key/value pairs
		@return vector of key/value pairs
		~#
		method : public : GetKeyValues() ~ Vector<Pair<K,V>> {
			values := Vector->New()<Pair<K,V>>;

			for(i := 0; i < @buckets->Size(); i += 1;) {
				if(@buckets[i] <> Nil) {
					list := @buckets[i];
					list->Rewind();
					while(list->More()) {
						pair : HashPair<V> := list->Get()<V>;

						k : K := pair->GetKey();
						v : V := pair->Get();

						values->AddBack(Pair->New(k, v)<K,V>);
						
						list->Next();
					};
				};
			};
			
			return values;
		}
		
		#~
		Clears the map
		~#
		method : public : Empty() ~ Nil {
			@buckets := CompareList->New[@capacity]<K>;
			@size := 0;
		}

		#~
		Checks to see if the hash table is empty
		@return true if empty, false otherwise
		~#
		method : public: IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of map
		@return size of map
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class : private : HashPair<V> implements Compare, Clone {
		@key : Compare;
		@value : V;

		New(key : Compare, value : V) {
			Parent();
			@key := key;
			@value := value;
		}

		method : public : Compare(rhs : Compare) ~ Int {		
			return @key->Compare(rhs);
		}

		method : public : Clone() ~ Compare {
			return HashPair->New(@key, @value)<V>;
		}

		method : public : HashID() ~ Int {
			return @key->HashID();
		}
		
		method : public : GetKey() ~ Compare {
			return @key;
		}

		method : public : Get() ~ V {
			return @value;
		}
	}
	
	#~
	Growable stack of generics
	~#
	class Stack<H> {
		@head : ListNode<H>;
		@size : Int;

		#~
		Default constructor 
		~#
		New() {
		}

		#~
		Converts the stack into an object array
		@return object array
		~#
		method : native : public : ToArray() ~ H[] {
			array := H->New[@size];
			
			i := 0;
			while(@head <> Nil) {
				array[i] := Pop();
				i += 1;
			};
			
			return array;
		}

		#~
		Pushes a value onto the stack
		@param value to push
		~#
		method : public : Push(value : H) ~ Nil {
			if(@head = Nil) {
				@head := ListNode->New(value)<H>;
			}
			else {
				next := ListNode->New(value)<H>;
				next->SetNext(@head);
				@head := next;
			};

			@size += 1;
		}

		#~
		Pops values from the stack
		@param n number of items to pop
		@return popped valued, Nil if stack is empty
		~#
		method : native : public : Pop(n : Int) ~ H {
			value : H;

			if(n > 0) {
				while(@head <> Nil & n < @size) {
					@head := @head->GetNext();
					value := @head->Get();
					@size -= 1;
				};
			};

			return value;
		}

		#~
		Pops a value from the stack
		@return popped valued, Nil if stack is empty
		~#
		method : public : Pop() ~ H {
			value : H;

			if(@head <> Nil) {
				value := @head->Get();
				@head := @head->GetNext();
				@size -= 1;
			};

			return value;
		}

		#~
		Check the top of the stack
		@return value on the top of stack, Nil if stack is empty
		~#
		method : public : Top() ~ H {
			value : H;

			if(@head <> Nil) {
				value := @head->Get();
			};

			return value;
		}

		#~
		Checks to see if the stack is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @head = Nil;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@head := Nil;
		}

		#~
		Size of stack
		@return size of stack
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}
	
	#~
	Queue of generics

	```
# insert elements
queue := Collection.Queue->New()<String>;
queue->AddFront("San Francisco");
queue->AddBack("Oakland");
queue->AddBack("East Bay");
queue->AddBack("Mountain View");

# remove element
queue->RemoveBack();

# get size
queue->Size()->PrintLine();

# get value by key
queue->Back()->PrintLine();
queue->Front()->PrintLine();
	```	
	~#
	class Queue<H> {
		@queue : List<H>;
		
		#~
		Default constructor 
		~#
		New() {
			@queue := List->New()<H>;
		}

		#~
		Converts the queue into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			return @queue->ToArray();
		}

		#~
		Adds a value to the back of the queue
		@param value value to add
		~#
		method : public: AddBack(value : H) ~ Nil {
			@queue->AddBack(value);
		}

		#~
		Adds a value to the front of the queue
		@param value value to add
		~#
		method : public: AddFront(value : H) ~ Nil {
			@queue->AddFront(value);
		}
		
		#~
		Removes a value from the front of the queue
		@return value removed
		~#
		method : public : RemoveFront() ~ H {
			if(@queue->Size() > 0) {
				value := @queue->Front();
				@queue->RemoveFront();
				return value;
			};
			
			return Nil;
		}

		#~
		Removes a value from the back of the queue
		@return value removed
		~#
		method : public : RemoveBack() ~ H {
			if(@queue->Size() > 0) {
				value := @queue->Front();
				@queue->RemoveBack();
				return value;
			};
			
			return Nil;
		}
		
		#~
		Get the value from the front of the queue
		@return head value, Nil if queue is empty
		~#
		method : public: Front() ~ H {
			return @queue->Front();
		}

		#~
		Get the value from the back of the queue
		@return head value, Nil if queue is empty
		~#
		method : public: Back() ~ H {
			return @queue->Back();
		}
		
		#~
		Clears the queue
		~#
		method : public : Empty() ~ Nil {
			@queue->Empty();
		}
		
		#~
		Checks to see if the queue is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @queue->IsEmpty();
		}
		
		#~
		Size of queue
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @queue->Size();
		}
	}

	#~
	Forward iterator of comparables
	~#
	class CompareForwardIterator<H : Compare> {
		@node : CompareListNode<H>;
		@list : CompareList<H>;
		
		New(node : CompareListNode<H>, list : CompareList<H>) {
			@node := node;
			@list := list;
		}

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@node <> Nil) {
				@node := @node->GetNext();
			};
		}

		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			if(@node <> Nil) {
				return true;
			};

			return false;
		}

		#~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	Backward iterator of comparables
	~#
	class CompareBackwardIterator<H : Compare> {
	    @node : CompareListNode<H>;
	    @list : CompareList<H>;

	    New(node : CompareListNode<H>, list : CompareList<H>) {
	            @node := node;
	            @list := list;
	    }

	    #~
		Advances the pointer Backward
		~#
	    method : public : Next() ~ Nil {
	            if(@node <> Nil) {
	                    @node := @node->GetPrevious();
	            };
	    }

	    #~
		Checks to see the pointer can be advanced Backward
		@return true if pointer can be advanced, false otherwise
		~#
	    method : public : More() ~ Bool {
	            if(@node <> Nil) {
	                    return true;
	            };

	            return false;
	    }

	    #~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return current value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	List of comparable generics


	```
function : Example() ~ Nil {	
   # insert elements
   list := Collection.CompareList->New()<FloatRef>;
   list->AddBack(33.3);
   list->AddFront(66.6);
   list->AddBack(99.9);

   # get size
   list->Size()->PrintLine();

   # find value
   list->Has(66.6)->PrintLine();

   # get first and last item
   list->Front()->PrintLine();
   list->Back()->PrintLine();

   # iterate
   while(list->More()) {
      list->Get()->PrintLine();
      list->Next();
   };

   # iterate backward	   
   backwards := list->BackwardIterator()<FloatRef>;
   while(backwards->More()) {
      backwards->Get()->PrintLine();
      backwards->Next();
   };
}
	```
	~#
	class CompareList<H : Compare> {
		@size : Int;
		@head : CompareListNode<H>;
		@tail : CompareListNode<H>;
		@cursor : CompareListNode<H>;

		#~
		Default constructor 
		~#
		New() {
			@size := 0;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			elem := @head;
			while(elem <> Nil) {
				# get string value if instance implements 'Stringify'				
				value := elem->Get();
				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
				};

				# next
				elem := elem->GetNext();

				# add comma, if needed
				if(elem <> Nil) {
					buffer->Append(',');
				};
				
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Converts the list into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array := H->New[@size];

			i := 0;
			start := @head;
			while(start <> Nil) {
				array[i++] := start->Get();
				start := start->GetNext();
			};

			return array;
		}

		#~
		Instance of a forward iterator
		@return forward iterator
		~#
		method : public : ForwardIterator() ~ CompareForwardIterator<H> {
			return CompareForwardIterator->New(@head, @self)<H>;
		}

		#~
		Instance of a backward iterator
		@return Backward iterator
		~#
		method : public : BackwardIterator() ~ CompareBackwardIterator<H> {
			return CompareBackwardIterator->New(@tail, @self)<H>;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : native : AddBack(value : H) ~ Nil {
			node := CompareListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size += 1;
		}
	
		#~
		Removes the last value from the list
		~#
		method : public : RemoveBack() ~ Nil {
			Forward();
			Remove();
		}

		#~
		Adds a value to the front
		@param value value to prepend 
		~#
		method : public : native : AddFront(value : H) ~ Nil {
			node := CompareListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
			};
			@size += 1;
		}
		
		#~
		Removes the first value from the list
		~#
		method : public : RemoveFront() ~ Nil {
			Rewind();
			Remove();
		}

		#~
		Moves the pointer to the start of the list
		~#
		method : public : Rewind() ~ Nil {
			@cursor := @head;
		}		

		#~
		Moves the pointer to the end of the list
		~#
		method : public : Forward() ~ Nil {
			@cursor := @tail;
		}		

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		#~
		Retreats the pointer
		~#
		method : public : Previous() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		#~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}

		#~
		Maps the given function to each value in the list 
		@param f function to apply
		@return newly calculated list
		~#
		method : public : Map(f : (H) ~ H) ~ CompareList<H> {
			list : CompareList<H> := CompareList->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				list->AddBack(f(start->Get()));
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered list
		~#
		method : public : Filter(f : (H) ~ Bool) ~ CompareList<H> {
			list : CompareList<H> := CompareList->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				if(f(start->Get())) {
					list->AddBack(start->Get());
				};
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		Uses the given function to reduce the values
		@param a initial value (i.e. accumulator)
		@param f function to use a reduce
		@return reduced vector
		~#
		method : public : Reduce(a : H, f : (H, H) ~ H) ~ H {
			start := @head->GetNext();
			while(start <> Nil) {
				a := f(a, start->Get());
				start := start->GetNext();
			};

			return a;
		}

		#~
		List of all but first element
		@return all but first element
		~#
		method : public : Rest() ~ CompareList<H> {
			list : CompareList<H> := CompareList->New()<H>;
			
			start := @head->GetNext();
			while(start <> Nil) {
				list->AddBack(start->Get());
				start := start->GetNext();
			};

			list->Rewind();

			return list;
		}

		#~
		Searches for a value
		@param value value to check for
		@return true if value is found, false otherwise
		~#
		method : public : Has(value : H) ~ Bool {
			start := @head;
			end := @tail;
			
			while(start <> end) {
				if(value->Compare(start->Get()) = 0) {
					return true;
				}
				else if(value->Compare(end->Get()) = 0) {
					return true;
				};
				
				start := start->GetNext();
				end := end->GetPrevious();
			};
			
			if(start <> Nil & value->Compare(start->Get()) = 0) {
				return true;
			}; 

			return false;
		}
		
		#~
		Finds a value in the list and sets the pointer
		@param value value to search for
		@return value that's found
		~#
		method : public : Find(value : H) ~ H {
			@cursor := @head;
			while(@cursor <> Nil) {
				if(value->Compare(@cursor->Get()) = 0) {
					return value;
				};
				@cursor := @cursor->GetNext();
			};
			
			return Nil;
		}
		
		#~
		Inserts a value into the list based upon the pointer location
		@param value value to insert
		~#
		method : public : native : Insert(value : H) ~ Bool {
			if(@cursor <> Nil & @head <> Nil & @tail <> Nil) {
				node := CompareListNode->New(value)<H>;
				if(@cursor = @head & @cursor = @tail) {
			 		@head->SetNext(node);
			 		node->SetPrevious(@head);
			 		@tail := node;
			 	}
			 	else if(@cursor = @tail) {
			 		@tail->SetNext(node);
			 		node->SetPrevious(@tail);
			 		@tail := node;
			 	}
			 	else {
					@cursor->GetNext()->SetPrevious(node);
					node->SetNext(@cursor->GetNext());
			 		@cursor->SetNext(node);
			 		node->SetPrevious(@cursor);
			 	};
			 	@size += 1;
				
				return true;
			}
			else if(@head = Nil & @tail = Nil) {
				AddBack(value);
				return true;
			};
			
			return false;
		}
		
		#~
		Removes the element at the pointer position
		~#
		method : public : native : Remove() ~ Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetPrevious();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Removes the element at the pointer position
		@param node node
		~#
		method : public : native : Remove(node : CompareListNode<H>) ~ Nil {
			if(node <> Nil) {
				if(node->GetPrevious() <> Nil) {
					node->GetPrevious()->SetNext(node->GetNext());
				};
				if(node = @head & node = @tail) {
			 		node := node->GetNext();
			 		@head := node;
			 		@tail := node;
			 	}
			 	else if(node = @head) {
			 		node := node->GetNext();
			 		@head := node;
			 	}
			 	else if(node = @tail) {
			 		node := node->GetPrevious();
			 		@tail := node;
			 	}
			 	else {
			 		node := node->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Checks to see if the pointer is at the front of the list
		@return true if pointer is at the front of the list, false otherwise
		~#
		method : public : IsFront() ~ Bool {
			return @cursor = @head;
		}		
		
		#~
		Checks to see if the pointer is at the end of the list
		@return true if pointer is at the end of the list, false otherwise
		~#
		method : public : IsBack() ~ Bool {
			return @cursor = @tail;
		}
		
		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @cursor <> Nil;
		}

		#~
		Returns the first element in the list
		@return first element in the list, Nil if the list is empty
		~#
		method : public : Front() ~ H {
			if(@head <> Nil) {
				return @head->Get();
			};

			return Nil;
		}

		#~
		Returns the last element in the list
		@return last element in the list, Nil if the list is empty
		~#
		method : public : Back() ~ H {
			if(@tail <> Nil) {
				return @tail->Get();
			};

			return Nil;
		}

		#~
		Clears the list
		~#
		method : public : Empty() ~ Nil {
			@size := 0;
			@head := Nil;
			@tail := Nil;
			@cursor := Nil;
		}
		
		#~
		Checks to see if the list is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of list
		@return size of list
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class : private : CompareListNode<H : Compare> {
		@value : H;
		@next : CompareListNode<H>;
		@previous: CompareListNode<H>;

		New(value : H) {
			@value := value;
		}
		
		method : public : Set(value : H) ~ Nil {
			@value := value;
		}
	
		method : public : Get() ~ H {
			return @value;
		}

		method : public : SetNext(next :  CompareListNode<H>) ~ Nil {
			@next := next;
		}
	
		method : public : GetNext() ~ CompareListNode<H> {
			return @next;
		}

		method : public : SetPrevious(previous :  CompareListNode<H>) ~ Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious() ~ CompareListNode<H> {
			return @previous;
		}
	}

	#~
	Forward iterator
	~#
	class ForwardIterator<H> {
		@node : ListNode<H>;
		@list : List<H>;
		
		New(node : ListNode<H>, list : List<H>) {
			@node := node;
			@list := list;
		}

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@node <> Nil) {
				@node := @node->GetNext();
			};
		}

		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @node <> Nil;
		}

		#~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	Backward iterator
	~#
	class BackwardIterator<H> {
	    @node : ListNode<H>;
	    @list : List<H>;

	    New(node : ListNode<H>, list : List<H>) {
	            @node := node;
	            @list := list;
	    }

		#~
		Advances the pointer Backward
		~#
	    method : public : Next() ~ Nil {
	            if(@node <> Nil) {
	                    @node := @node->GetPrevious();
	            };
	    }
	    
		#~
		Checks to see the pointer can be advanced Backward
		@return true if pointer can be advanced, false otherwise
		~#
	    method : public : More() ~ Bool {
	            if(@node <> Nil) {
	                    return true;
	            };

	            return false;
	    }

	    #~
		Removes the element at the pointer position
		~#
	    method : public : Remove() ~ Nil {
	    	@list->Remove(@node);
	    }

	    #~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			return @node->Get();
		}
	}

	#~
	Generic list


	```
function : Example() ~ Nil {	
   # insert elements
   list := Collection.List->New()<FloatRef>;
   list->AddBack(33.3);
   list->AddFront(66.6);
   list->AddBack(99.9);

   # get size
   list->Size()->PrintLine();

   # get first and last item
   list->Front()->PrintLine();
   list->Back()->PrintLine();

   # iterate
   while(list->More()) {
      list->Get()->PrintLine();
      list->Next();
   };

   # iterate backward	   
   backwards := list->BackwardIterator()<FloatRef>;
   while(backwards->More()) {
      backwards->Get()->PrintLine();
      backwards->Next();
   };
}
	```
	~#
	class List<H> {
		@size : Int;
		@head : ListNode<H>;
		@tail : ListNode<H>;
		@cursor : ListNode<H>;

		#~
		Default constructor 
		~#
		New() {
			@size := 0;
		}

		#~
		Converts the list into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array := H->New[@size];

			i := 0;
			start := @head;
			while(start <> Nil) {
				array[i++] := start->Get();
				start := start->GetNext();
			};

			return array;
		}

		#~
		Instance of a forward iterator
		@return forward iterator
		~#
		method : public : ForwardIterator() ~ ForwardIterator<H> {
			return ForwardIterator->New(@head, @self)<H>;
		}

		#~
		Instance of a backward iterator
		@return Backward iterator
		~#
		method : public : BackwardIterator() ~ BackwardIterator<H> {
			return BackwardIterator->New(@tail, @self)<H>;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : native : AddBack(value : H) ~ Nil {
			node := ListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@tail->SetNext(node);
			 	node->SetPrevious(@tail);	
				@tail := node;
			};
			@size += 1;
		}

		#~
		Maps the given function to each value in the list 
		@param f function to apply
		@return newly calculated list
		~#
		method : public : Map(f : (H) ~ H) ~ List<H> {
			list : List<H> := List->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				list->AddBack(f(start->Get()));
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (H) ~ Nil) ~ List<H> {
			start := @head;
			while(start <> Nil) {
				f(start->Get());
				start := start->GetNext();
			};
			return @self;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			elem := @head;
			while(elem <> Nil) {
				# get string value if instance implements 'Stringify'				
				value := elem->Get();
				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
				};

				# next
				elem := elem->GetNext();

				# add comma, if needed
				if(elem <> Nil) {
					buffer->Append(',');
				};
				
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Returns a limited list
		@param l limit
		@return limited list
		~#
		method : public : Limit(l : Int) ~ List<H> {
			list := List->New()<H>;
			
			if(l > -1) {
				i := 0;
				start := @head;
				while(i < l & start <> Nil) {
					list->AddBack(start->Get());
					start := start->GetNext();
					i += 1;
				};
			};

			list->Rewind();
			return list;
		}

		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered list
		~#
		method : public : Filter(f : (H) ~ Bool) ~ List<H> {
			list : List<H> := List->New()<H>;
			
			start := @head;
			while(start <> Nil) {
				if(f(start->Get())) {
					list->AddBack(start->Get());
				};
				start := start->GetNext();
			};

			list->Rewind();
			return list;
		}

		#~
		Uses the given function to reduce the values
		@param a initial value (i.e. accumulator)
		@param f function to use a reduce
		@return reduced vector
		~#
		method : public : Reduce(a : H, f : (H, H) ~ H) ~ H {
			start := @head->GetNext();
			while(start <> Nil) {
				a := f(a, start->Get());
				start := start->GetNext();
			};

			return a;
		}

		#~
		List of all but first element
		@return all but first element
		~#
		method : public : Rest() ~ List<H> {
			list : List<H> := List->New()<H>;
			
			if(@head <> Nil) {
				start := @head->GetNext();
				while(start <> Nil) {
					list->AddBack(start->Get());
					start := start->GetNext();
				};

				list->Rewind();
			};

			return list;
		}
		
		#~
		Removes the last value from the list
		~#
		method : public : RemoveBack() ~ Nil {
			Forward();
			Remove();
		}

		#~
		Adds a value to the front
		@param value value to prepend 
		~#
		method : public : native : AddFront(value : H) ~ Nil {
			node := ListNode->New(value)<H>;
			if(@head = Nil) {
				@head := node;
				@tail := @head;
				@cursor := @head;
			}
			else {
				@head->SetPrevious(node);
				node->SetNext(@head);
				@head := node;
			};
			@size += 1;
		}
		
		#~
		Removes the first value from the list
		~#
		method : public : RemoveFront() ~ Nil {
			Rewind();
			Remove();
		}

		#~
		Moves the pointer to the start of the list
		~#
		method : public : Rewind() ~ Nil {
			@cursor := @head;
		}		

		#~
		Moves the pointer to the end of the list
		~#
		method : public : Forward() ~ Nil {
			@cursor := @tail;
		}		

		#~
		Advances the pointer
		~#
		method : public : Next() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetNext();
			};
		}

		#~
		Retreats the pointer
		~#
		method : public : Previous() ~ Nil {
			if(@cursor <> Nil) {
				@cursor := @cursor->GetPrevious();
			};
		}

		#~
		Gets the value that's currently pointed to
		@return value value
		~#
		method : public : Get() ~ H {
			if(@cursor <> Nil) {
				return @cursor->Get();
			};

			return Nil;
		}
				
		#~
		Inserts a value into the list based upon the pointer location
		@param value value to insert
		~#
		method : public : native : Insert(value : H) ~ Bool {
			if(@cursor <> Nil & @head <> Nil & @tail <> Nil) {
				node := ListNode->New(value)<H>;
				if(@cursor = @head & @cursor = @tail) {
			 		@head->SetNext(node);
			 		node->SetPrevious(@head);
			 		@tail := node;
			 	}
			 	else if(@cursor = @tail) {
			 		@tail->SetNext(node);
			 		node->SetPrevious(@tail);
			 		@tail := node;
			 	}
			 	else {
					@cursor->GetNext()->SetPrevious(node);
					node->SetNext(@cursor->GetNext());
			 		@cursor->SetNext(node);
			 		node->SetPrevious(@cursor);
			 	};
			 	@size += 1;
				
				return true;
			}
			else if(@head = Nil & @tail = Nil) {
				AddBack(value);
				return true;
			};
			
			return false;
		}
		
		#~
		Removes the element at the pointer position
		~#
		method : public : native : Remove() ~ Nil {
			if(@cursor <> Nil) {
				if(@cursor->GetPrevious() <> Nil) {
					@cursor->GetPrevious()->SetNext(@cursor->GetNext());
				};
				if(@cursor = @head & @cursor = @tail) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 		@tail := @cursor;
			 	}
			 	else if(@cursor = @head) {
			 		@cursor := @cursor->GetNext();
			 		@head := @cursor;
			 	}
			 	else if(@cursor = @tail) {
			 		@cursor := @cursor->GetPrevious();
			 		@tail := @cursor;
			 	}
			 	else {
			 		@cursor := @cursor->GetNext();
			 	};
				@size -= 1;
			};
		}

		method : public : native : Remove(node : ListNode<H>) ~ Nil {
			if(node <> Nil) {
				if(node->GetPrevious() <> Nil) {
					node->GetPrevious()->SetNext(node->GetNext());
				};
				if(node = @head & node = @tail) {
			 		node := node->GetNext();
			 		@head := node;
			 		@tail := node;
			 	}
			 	else if(node = @head) {
			 		node := node->GetNext();
			 		@head := node;
			 	}
			 	else if(node = @tail) {
			 		node := node->GetPrevious();
			 		@tail := node;
			 	}
			 	else {
			 		node := node->GetNext();
			 	};
				@size -= 1;
			};
		}

		#~
		Checks to see if the pointer is at the front of the list
		@return true if pointer is at the front of the list, false otherwise
		~#
		method : public : IsFront() ~ Bool {
			return @cursor = @head;
		}		
		
		#~
		Checks to see if the pointer is at the end of the list
		@return true if pointer is at the end of the list, false otherwise
		~#
		method : public : IsBack() ~ Bool {
			return @cursor = @tail;
		}
		
		#~
		Checks to see the pointer can be advanced
		@return true if pointer can be advanced, false otherwise
		~#
		method : public : More() ~ Bool {
			return @cursor <> Nil;
		}

		#~
		Returns the first element in the list
		@return first element in the list, Nil if the list is empty
		~#
		method : public : Front() ~ H {
			if(@head <> Nil) {
				return @head->Get();
			};

			return Nil;
		}

		#~
		Returns the last element in the list
		@return last element in the list, Nil if the list is empty
		~#
		method : public : Back() ~ H {
			if(@tail <> Nil) {
				return @tail->Get();
			};

			return Nil;
		}

		#~
		Clears the list
		~#
		method : public : Empty() ~ Nil {
			@size := 0;
			@head := Nil;
			@tail := Nil;
			@cursor := Nil;
		}
		
		#~
		Checks to see if the list is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Size of list
		@return size of list
		~#
		method : public : Size() ~ Int {
			return @size;
		}
	}

	class : private : ListNode<H> {
		@value : H;
		@next : ListNode<H>;
		@previous: ListNode<H>;

		New(value : H) {
			@value := value;
		}
		
		method : public : Set(value : H) ~ Nil {
			@value := value;
		}
	
		method : public : Get() ~ H {
			return @value;
		}

		method : public : SetNext(next :  ListNode<H>) ~ Nil {
			@next := next;
		}
	
		method : public : GetNext() ~ ListNode<H> {
			return @next;
		}

		method : public : SetPrevious(previous :  ListNode<H>) ~ Nil {
			@previous := previous;
		}
	
		method : public : GetPrevious() ~ ListNode<H> {
			return @previous;
		}
	}
	
	#~
	Growable generic array
	
	```
	function : Example() ~ Nil {	
	   # insert elements
	   vector := Collection.Vector->New()<IntRef>;
	   vector->AddBack(4);
	   vector->AddBack(1);
	   vector->AddBack(5);
	   vector->AddBack(1);
	   vector->AddBack(0);
   
	   # remove last item
	   vector->RemoveBack();
   
	   # get size
	   vector->Size()->PrintLine();
	   
	   # get elements
	   (vector->Get(0) + vector->Get(1))->PrintLine();
   
	   # print all items with a loop
	   each(item := vector) {
	   	item->PrintLine();
	   };
   
	   # print all items with a function
	   vector->Each(Show(IntRef) ~ Nil);
	}

	function : Show(value : IntRef) ~ Nil {
	   value->PrintLine();
	}
	```
	~#
	class Vector<H> {
		@values : H[];
		@size : Int;
		
		#~
		Default constructor 
		~#
		New() {
			@values := H->New[32];
			@size := 0;
		}
		
		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : H[]) {
			@values := H->New[values->Size()];
			@size := values->Size();
			Runtime->Copy(@values, 0, values, 0, @size);
 		}

		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : Vector<H>) {
			@values := values->ToArray();
			@size := values->Size();
		}
		
		method : Expand() ~ Nil {
			if(@size >= @values->Size()) {
				temp : H[] := H->New[@size + @size >> 2];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
		}

		#~
		Zip two vectors together
		@return list of pairs
		~#
		function : Zip(a : Vector<H>, b : Vector<H>) ~ Vector<Collection.Tuple.Pair<H,H>> {
			max := a->Size();
			if(b->Size() < max) {
				max := b->Size();
			};

			zipped := Vector->New()<Collection.Tuple.Pair<H,H>>;
			each(i : max) {
				tuple := Collection.Tuple.Pair->New(a->Get(i), b->Get(i))<H, H>;
				zipped->AddBack(tuple)<Collection.Tuple.Pair<H,H>>;
			};

			return zipped;
		}

		#~
		Zip three vectors together
		@return list of triplets
		~#
		function : Zip(a : Vector<H>, b : Vector<H>, c : Vector<H>) ~ Vector<Collection.Tuple.Triplet<H,H,H>> {
			max := a->Size();
			if(b->Size() < max) {
				max := b->Size();
				if(c->Size() < max) {
					max := c->Size();
				};
			};

			zipped := Vector->New()<Collection.Tuple.Triplet<H,H,H>>;
			each(i : max) {
				tuple := Collection.Tuple.Triplet->New(a->Get(i), b->Get(i), c->Get(i))<H,H,H>;
				zipped->AddBack(tuple)<Collection.Tuple.Triplet<H,H,H>>;
			};
			
			return zipped;
		}

		#~
		Zip four vectors together
		@return list of quintets
		~#
		function : Zip(a : Vector<H>, b : Vector<H>, c : Vector<H>, d : Vector<H>) ~ Vector<Collection.Tuple.Quartet<H,H,H,H>> {
			max := a->Size();
			if(b->Size() < max) {
				max := b->Size();
				if(c->Size() < max) {
					max := c->Size();
					if(d->Size() < max) {
						max := d->Size();
					};
				};
			};

			zipped := Vector->New()<Collection.Tuple.Quartet<H,H,H,H>>;
			each(i : max) {
				tuple := Collection.Tuple.Quartet->New(a->Get(i), b->Get(i), c->Get(i), d->Get(i))<H,H,H,H>;
				zipped->AddBack(tuple)<Collection.Tuple.Quartet<H,H,H,H>>;
			};
			
			return zipped;
		}

		#~
		Reverses element order
		@return reversed vector, if the vector is empty or hold 1 item then the original list is returned
		~#
		method : public : Reverse() ~ Vector<H> {
			if(@size < 2) {
				return @self;
			}
			
			len := @size;
			reversed := Collection.Vector->New()<H>;
			each(i : @size) {
				reversed->AddBack(@values[--len])
			};

			return reversed;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			each(i : @size) {
				# get string value if instance implements 'Stringify'
				value := @values[i];
				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
				};

				# add comma
				if(i + 1 < @size) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Compresses the Vector freeing unused memory
		~#
		method : public : Compress() ~ Nil {
			temp : H[] := H->New[@size];
			Runtime->Copy(temp, 0, @values, 0, @size);
			@values := temp;
		}

		#~
		Maps the given function to each value in the vector 
		@param f function to apply
		@return newly calculated vector
		~#
		method : public : Map(f : (H) ~ H) ~ Vector<H> {
			array : H[] := H->New[@size];
			for(i : Int := 0; i < @size; i += 1;) {
				array[i] := f(@values[i]);
			};
      
			return Vector->New(array)<H>;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (H) ~ Nil) ~ Vector<H> {
			for(i : Int := 0; i < @size; i += 1;) {
				f(@values[i]);
			};
			return @self;
		}

		#~
		Returns a limited list
		@param l limit
		@return limited list
		~#
		method : public : Limit(l : Int) ~ Vector<H> {
			array := H->New[@size];

			if(l > -1 & l < @size) {
				array := H->New[l];
				for(i : Int := 0; i < l; i += 1;) {
					array[i] := @values[i];
				};
				return Vector->New(array)<H>;
			};
      		
			return Vector->New()<H>;
		}
		
		#~
		Swap two values in the vector
		@param a first value
		@param b second value
		@return true if values were swapped
		~#
		method : public : Swap(a : Int, b : Int) ~ Bool {
			if(a < -1 | b < -1 | a > @size | b > @size) {
				return false;
			};
			
			temp := @values[a];
			@values[a] := @values[b];
			@values[b] := temp;
			
			return true;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : AddBack(value : H) ~ Nil {
			Expand();
			@values[@size] := value;
			@size += 1;
		}

		#~
		Removes the last value
		@return value
		~#
		method : public : RemoveBack() ~ H {
			if(@size > 0) {
				@size -= 1;
				return @values[@size];
			};
	
			return Nil;
		}
		
		#~
		Removes an indexed value
		@param i index
		@return value
		~#
		method : public : Remove(i : Int) ~ H {
			if(i > -1 & i < @size) {
				temp := H->New[@values->Size()];
				Runtime->Copy(temp, 0, @values, 0, i);
				Runtime->Copy(temp, i, @values, i + 1, @size - i - 1);
				value := @values[i];
				@values := temp;
				@size -= 1;
				return value;
			};
			
			return Nil;
		}

		#~
		Gets an indexed value
		@param index index
		@return value, or Nil if invalid index
		~#
		method : public : Get(index : Int) ~ H {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		#~
		Gets the last value
		@return last value, or Nil if not set
		~#
		method : public : Last() ~ H {
			last := @size - 1;
			if(last > -1) {
				return @values[last];
			}

			return Nil;
		}

		#~
		Gets the first value
		@return first value, or Nil if not set
		~#
		method : public : First() ~ H {
			if(@size > -1) {
				return @values[0];
			}

			return Nil;
		}

		#~
		Sets an indexed value
		@param value value
		@param index index
		~#
		method : public : Set(value : H, index : Int) ~ Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values := H->New[32];
			@size := 0;
		}
		
		#~
		Size of vector
		@return size of vector
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Converts the vector into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array : H[] := H->New[@size];
			Runtime->Copy(array, 0, @values, 0, @size);
			return array;
		}
	}

	#~
	Growable array of comparable generics


	```
function : Example() ~ Nil {	
   # insert elements
   vector := Collection.CompareVector->New()<IntRef>;
   vector->AddBack(4);
   vector->AddBack(1);
   vector->AddBack(5);
   vector->AddBack(9);
   vector->AddBack(2);
   vector->AddBack(5);

   # remove last item
   vector->RemoveBack();

   # get size
   vector->Size()->PrintLine();
   
   # get elements
   (vector->Get(0) + vector->Get(1))->PrintLine();

   # sort elements
   vector->Sort();
	
   # print all items with a loop
   each(item := vector) {
   	item->PrintLine();
   };

   # print all items with a function
   vector->Each(Show(IntRef) ~ Nil);
}

function : Show(value : IntRef) ~ Nil {
   value->PrintLine();
}
	```
	~#
	class CompareVector<H : Compare> {
		@values : H[];
		@size : Int;
		
		#~
		Default constructor 
		~#
		New() {
			@values := H->New[32];
			@size := 0;
		}
		
		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : H[]) {
			@values := H->New[values->Size()];
			@size := values->Size();
			Runtime->Copy(@values, 0, values, 0, @size);
 		}

		#~
		Copy constructor
		@param values values to copy 
		~#
		New(values : CompareVector<H>) {
			@values := values->ToArray();
			@size := values->Size();
		}

		#~
		Reverses element order
		@return reversed vector, if the vector is empty or hold 1 item then the original list is returned
		~#
		method : public : Reverse() ~ CompareVector<H> {
			if(@size < 2) {
				return @self;
			}

			len := @size;
			reversed := Collection.CompareVector->New()<H>;
			each(i : @values) {
				reversed->AddBack(@values[--len])
			};

			return reversed;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			each(i : @size) {
				# get string value if instance implements 'Stringify'
				value := @values[i];
				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
				};

				# add comma
				if(i + 1 < @size) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}

		method : Expand() ~ Nil {
			if(@size >= @values->Size()) {
				temp : H[] := H->New[@size + @size >> 2];
				Runtime->Copy(temp, 0, @values, 0, @size);
				@values := temp;
			};
		}
		
		#~
		Compresses the Vector freeing unused memory
		~#
		method : public : Compress() ~ Nil {
			temp : H[] := H->New[@size];
			Runtime->Copy(temp, 0, @values, 0, @size);
			@values := temp;
		}

		#~
		Maps the given function to each value in the vector 
		@param f function to apply
		@return newly calculated vector
		~#
		method : public : Map(f : (H) ~ H) ~ CompareVector<H> {
			array : H[] := H->New[@size];

			for(i : Int := 0; i < @size; i += 1;) {
				array[i] := f(@values[i]);
			};
      
			return CompareVector->New(array)<H>;
		}

		#~
		Returns a limited list
		@param l limit
		@return limited list
		~#
		method : public : Limit(l : Int) ~ CompareVector<H> {
			array := H->New[@size];

			if(l > -1 & l < @size) {
				array := H->New[l];
				for(i : Int := 0; i < l; i += 1;) {
					array[i] := @values[i];
				};
				return CompareVector->New(array)<H>;
			};
      		
			return CompareVector->New()<H>;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (H) ~ Nil) ~ CompareVector<H> {
			for(i : Int := 0; i < @size; i += 1;) {
				f(@values[i]);
			};
			return @self;
		}

		#~
		Adds a value to the end
		@param value value to append 
		~#
		method : public : AddBack(value : H) ~ Nil {
			Expand();
			@values[@size] := value;
			@size += 1;
		}

		#~
		Removes the last value
		@return value
		~#
		method : public : RemoveBack() ~ H {
			if(@size > 0) {
				@size -= 1;
				return @values[@size];
			};
	
			return Nil;
		}
		
		#~
		Removes an indexed value
		@param i index
		@return value
		~#
		method : public : Remove(i : Int) ~ H {
			if(i > -1 & i < @size) {
				temp := H->New[@values->Size()];
				Runtime->Copy(temp, 0, @values, 0, i);
				Runtime->Copy(temp, i, @values, i + 1, @size - i - 1);
				value := @values[i];
				@values := temp;
				@size -= 1;
				return value;
			};
			
			return Nil;
		}

		#~
		Gets an indexed value
		@param index index
		@return value
		~#
		method : public : Get(index : Int) ~ H {
			if(index > -1 & index < @size) {
				return @values[index];
			};

			return Nil;
		}

		#~
		Gets the last value
		@return last value, or Nil if not set
		~#
		method : public : Last() ~ H {
			last := @size - 1;
			if(last > -1) {
				return @values[last];
			}

			return Nil;
		}

		#~
		Gets the first value
		@return first value, or Nil if not set
		~#
		method : public : First() ~ H {
			if(@size > -1) {
				return @values[0];
			}

			return Nil;
		}

		#~
		Sets an indexed value
		@param value value
		@param index index
		~#
		method : public : Set(value : H, index : Int) ~ Bool {
			if(index > -1 & index < @size) {
				@values[index] := value;
				return true;
			};
			
			return false;
		}

		#~
		Clears the vector
		~#
		method : public : Empty() ~ Nil {
			@values := H->New[32];
			@size := 0;
		}
		
		#~
		Size of vector
		@return size of vector
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the vector is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}
		
		#~
		Sorts the values in the vector
		~#	
		method : public : native : Sort() ~ Nil {
			a : H[] := @values;
			b : H[] := H->New[@size];
			MergeSort(0, @size - 1, a, b);
		}
		
		method : MergeSort(low : Int, hi : Int, a : H[], b : H[]) ~ Nil {
			if(low < hi) {
				mid := (low + hi) >> 1;
				MergeSort(low, mid, a, b);
				MergeSort(mid + 1, hi, a, b);
				Merge(low, mid, hi, a, b);
			};	
		}
		
		method : native : Merge(low : Int, mid : Int, hi : Int, a : H[], b : H[]) ~ Nil {
			# copy both halves of a to auxiliary array b
			for(i := low; i <= hi; i += 1;) {
				b[i] := a[i];
			};

			i := low; 
			j := mid + 1; 
			k := low;
			
			# copy back next-greatest element at each time
			while(i <= mid & j <= hi) {
				if(b[i]->Compare(b[j]) < 0 | b[i]->Compare(b[j]) = 0) {
					a[k] := b[i];
					k += 1;
					i += 1;
				}
				else {
					a[k] := b[j];
					k += 1;
					j += 1;
				};
			};
			
			# copy back remaining elements of first half (if any)
			while(i <= mid) {
				a[k] := b[i];
				k += 1;
				i += 1;
			};
		}

		#~
		Finds a given value in the vector via linear search
		@param value value to search for
		@return index of found value, -1 if not found
		~#
		method : public : Find(value : H) ~ Int {
         for(i := 0; i < @size; i += 1;) {
            if(@values[i]->Compare(value) = 0) {
               return i;
            };
         };

         return -1;
      }
		
		#~
		Performs a binary search O(log n)
		@param value value to search for
		@return index of found value, -1 if not found
		~#
		method : public : native : BinarySearch(value : H) ~ Int {
			low := 0;
			high := @size - 1;

			while(low <= high) {
				mid := (low + high) >> 1;
      	
				if(@values[mid]->Compare(value) > 0) {
					high := mid - 1;
				}
				else if(@values[mid]->Compare(value) < 0) {
					low := mid + 1;
				}
				else {
					return mid;
				};
			};

			return -1;
		}
		
		#~
		Check of the given value is in the vector
		@param value value to check for
		@return true if found, false otherwise
		~#
		method : public : Has(value : H) ~ Bool {
			for(i : Int := 0; i < @size; i += 1;) {
				if(@values[i]->Compare(value) = 0) {
					return true;
				};
			};
			
			return false;
		}
		
		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered vector
		~#
		method : public : Filter(f : (H) ~ Bool) ~ CompareVector<H> {
			filtered := CompareVector->New()<H>;
			
			for(i : Int := 0; i < @size; i += 1;) {
				if(f(@values[i])) {
					filtered->AddBack(@values[i]);
				};
			};
			
			return filtered;
		}

		#~
		Uses the given function to reduce the values
		@param a initial value (i.e. accumulator)
		@param f function to use a reduce
		@return reduced vector
		~#
		method : public : Reduce(a : H, f : (H, H) ~ H) ~ H {
			for(i : Int := 0; i < @size; i += 1;) {
				a := f(a, @values[i]);
			};

			return a;
		}

		#~
		Converts the vector into an object array
		@return object array
		~#
		method : public : ToArray() ~ H[] {
			array : H[] := H->New[@size];
			Runtime->Copy(array, 0, @values, 0, @size);
			return array;
		}
	}
	
	#~
	Balanced ordered tree of 'Compare' keys and 'Base' values
	
	```
	function : Example() ~ Nil {	
	   # insert elements
	   map := Collection.Map->New()<IntRef, String>;
	   map->Insert(415, "San Francisco");
	   map->Insert(510, "Oakland");
	   map->Insert(925, "East Bay");

	   # get size
	   map->Size()->PrintLine();

	   # get value by key
	   map->Find(510)->PrintLine();

	   # get key/values
	   key_values := map->GetKeyValues()<Pair<IntRef, String>>;
	   each(key_value := key_values) {
	      key_value->GetFirst()->PrintLine();
	   };

	   # get values
	   values := map->GetValues()<String>;
	   each(value := values) {
	      value->PrintLine();
	   };

	   # check for key
	   map->Has(408)->PrintLine();
	}
	```
	~#
	class Map<K : Compare, V> {
		@root : TreeNode<K, V>;
		@last : TreeNode<K, V>;
		@size : Int;

		#~
		Default constructor 
		~#
		New() {
			@root := Nil;
			@size := 0;	
		}		

		method : native : Skew(node : Collection.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node = Nil | node->GetLeft() = Nil) {
				return node;
			};
				
			if(node->GetLeft()->GetLevel() = node->GetLevel()) {
				left : TreeNode<K, V> := node->GetLeft();
				node->SetLeft(left->GetRight());
				left->SetRight(node);
				return left;
			};
			
			return node;
		}

		#~
		Converts a vector pairs to a map
		@param pairs vector of pairs
		@return mapped pairs
		~#
		function : Dict(pairs : Vector<Collection.Tuple.Pair<K, V>>) ~ Map<K, V> {
			dict := Map->New()<K, V>;

			each(pair in pairs) {
				k := pair->GetFirst();
				v := pair->GetSecond();
				dict->Insert(k, v);
			};

			return dict;
		}

		#~
		Size of queue
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @size;
		}
		
		#~
		Checks to see if the map is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @size = 0;
		}

		#~
		Clears the map
		~#
		method : public : Empty() ~ Nil {
			@root := Nil;
			@last := Nil;
			@size := 0;
		}
		
		method : native : Split(node : Collection.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node = Nil | node->GetRight() = Nil | 
					node->GetRight()->GetRight() = Nil) {
				return node;
			};

			if(node->GetRight()->GetRight()->GetLevel() = node->GetLevel()) {
				right : TreeNode<K, V> := node->GetRight();
				node->SetRight(right->GetLeft());
				right->SetLeft(node);
				right->SetLevel(right->GetLevel() + 1);
				
				return right;
			};
			
			return node;
		}
		
		#~
		Searches for a value in a map
		@param key search key
		@return found value, Nil if not found
		~#
		method : public : Find(key : K) ~ V {
			return Find(key, @root);
		}
		
		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return Find(key, @root) <> Nil;
		}
		
		method : Find(key : K, node : Collection.TreeNode<K, V>) ~ V {
			if(node <> Nil) {
				if(key->Compare(node->GetKey()) < 0) {
					return Find(key, node->GetLeft());
				}
				else if(key->Compare(node->GetKey()) > 0) {
					return Find(key, node->GetRight());
				}
				else {
					return node->Get();		
				};
			};
			
			return Nil;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (K, V) ~ Nil) ~ Map<K, V> {
			Each(@root, f);
			return @self;
		}

		method : Each(node : Collection.TreeNode<K, V>, f : (K, V) ~ Nil) ~ Nil {
			if(node <> Nil) {
				# process left 
				Each(node->GetLeft(), f);

				key := node->GetKey()->As(Clone)->Clone();
				value := node->Get();
				f(key->As(Compare), value);

				# process right
				Each(node->GetRight(), f);
			};
		}

		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~  Collection.Vector<K> {
			vector := Vector->New()<K>;
			GetKeys(@root, vector);
			return vector;
		}

		method : GetKeys(node : Collection.TreeNode<K, V>, vector : Collection.Vector<K>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetKeys(node->GetLeft(), vector);
				
				key : K := node->GetKey();
				vector->AddBack(key);
				
				# process right
				GetKeys(node->GetRight(), vector);
			};
		}
        
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeyValues() ~  Collection.Vector<Pair<K,V>> {
			vector := Vector->New()<Pair<K,V>>;
			GetKeyValues(@root, vector);
			return vector;
		}

		method : GetKeyValues(node : Collection.TreeNode<K, V>, vector : Collection.Vector<Pair<K,V>>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetKeyValues(node->GetLeft(), vector);
				
				key : K := node->GetKey();
                value : V := node->Get();
                
				vector->AddBack(Pair->New(key, value)<K,V>);
				
				# process right
				GetKeyValues(node->GetRight(), vector);
			};
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			pairs := GetKeyValues()<Pair<K,V>>;
			each(i : pairs) {
				# get string value if instance implements 'Stringify'
				pair := pairs->Get(i)<Pair<K,V>>;

				key := pair->GetFirst();
				if(key->TypeOf(Stringify)) {
					buffer->Append('(');
					buffer->Append(key->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append('(');
					buffer->Append(key->GetInstanceID()->ToHexString());
				};

				buffer->Append(':');

				value := pair->GetSecond();
				if(value->TypeOf(Stringify)) {
					buffer->Append(value->As(System.Stringify)->ToString());
					buffer->Append(')');
				}
				# use instance ID instead
				else {
					buffer->Append(value->GetInstanceID()->ToHexString());
					buffer->Append(')');
				};

				# add comma
				if(i + 1 < pairs->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}
        
		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~  Collection.Vector<V> {
			vector := Vector->New()<V>;
			GetValues(@root, vector);
			return vector;
		}

		method : GetValues(node : Collection.TreeNode<K, V>, vector : Collection.Vector<V>) ~ Nil {
			if(node <> Nil) {
				# process left 
				GetValues(node->GetLeft(), vector);
				
				value : V := node->Get();
				vector->AddBack(value);
				
				# process right
				GetValues(node->GetRight(), vector);
			};
		}
        
		#~
		Inserts a value into the map
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			if(key = Nil) {
				return;
			};

			if(@root = Nil) {
				@root := Insert(key, value, Nil->As(Collection.TreeNode<K, V>));
			}
			else {
				@root := Insert(key, value, @root);
			};
		}
		
		method : Insert(key : K, value : V, node : Collection.TreeNode<K, V>) ~  Collection.TreeNode<K, V> {
			if(node = Nil) {
				node := TreeNode->New(key, value, 1)<K, V>;
				@size += 1;
			}
			else {
				if(key->Compare(node->GetKey()) < 0) {
					node->SetLeft(Insert(key, value, node->GetLeft()));
				}
				else if(key->Compare(node->GetKey()) > 0) {
					node->SetRight(Insert(key, value, node->GetRight()));
				}
				else {
					return node;		
				};
				node := Skew(node);
				node := Split(node);
			};	
			
			return node;
		}
		
		#~
		Removes a value from the map
		@param key key for value to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			if(@size = 1 & key->Compare(@root->GetKey()) = 0) {
				@root := Nil;
				@size := 0;
				return true;
			};
			
			node := Remove(key, @root);
			if(node = Nil) {
				return false;
			};
			
			@root := node;
			@size -= 1;
			return true;
		}
		
		method : native : Remove(key : K, node : Collection.TreeNode<K, V>) ~  Collection.TreeNode<K, V> {
			if(node = Nil) {
				return Nil;
			};

			if(key->Compare(node->GetKey()) < 0) {
				node->SetLeft(Remove(key, node->GetLeft()));
			}
			else if(key->Compare(node->GetKey()) > 0) {
				node->SetRight(Remove(key, node->GetRight()));
			}
			else {
				if(node->GetLeft() = Nil & node->GetRight() = Nil) {
					return Nil;
				}
				else if(node->GetLeft() = Nil) {
					temp : TreeNode<K, V> := Successor(node);
					node->SetRight(Remove(temp->GetKey(), node->GetRight()));
					node := temp;
				} 
				else {
					temp : TreeNode<K, V> := Predecessor(node);
					node->SetLeft(Remove(temp->GetKey(), node->GetLeft()));
					node := temp;
				};
				
			};
			
			# rebalanced
			node := DecreaseLevel(node);				
			node := Skew(node);
			node->SetRight(Skew(node->GetRight()));
			if(node->GetRight() <> Nil & node->GetRight()->GetRight() <> Nil) {
				node->GetRight()->SetRight(Skew(node->GetRight()->GetRight()));
			};	
			node := Split(node);								
			node->SetRight(Split(node->GetRight()));

			return node;
		}
		
		method : Predecessor(node : Collection.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetLeft() <> Nil) {
				left : TreeNode<K, V> := node->GetLeft();
				while(left->GetLeft() <> Nil) {
					left := left->GetLeft();
				};

				return left;
			};

			return node;
		}

		method : Successor(node : Collection.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetRight() <> Nil) {
				right : TreeNode<K, V> := node->GetRight();
				while(right->GetRight() <> Nil) {
					right := right->GetRight();
				};

				return right;
			};

			return node;
		}

		 method : DecreaseLevel(node : Collection.TreeNode<K, V>) ~ TreeNode<K, V> {
			if(node->GetLeft() <> Nil & node->GetRight() <> Nil) {
				left : Int := node->GetLeft()->GetLevel();
				right : Int := node->GetRight()->GetLevel();
				value : Int := Int->Min(left, right);
			
				if(value < node->GetLevel()) {
					node->SetLevel(value);
					if(value < node->GetRight()->GetLevel()) {
						node->GetRight()->SetLevel(value);
					};
				};
			};
			
			return node;
		}
		
		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filtered map
		~#
		method : public : Filter(f : (K) ~ Bool) ~ Map<K, V> {
			filtered := Map->New()<K, V>;
			
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				if(f(key)) {
					value := Find(key);
					filtered->Insert(key, value);
				};
			};
			
			return filtered;
		}

		#~
		Uses the given function to reduce the values
		@param a initial value (i.e. accumulator)
		@param f function to use a reduce
		@return reduced vector
		~#
		method : public : Reduce(a : K, f : (K, K) ~ K) ~ K {
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				a := f(a, key);
			};

			return a;
		}
	}
		
	class : private : TreeNode<K : Compare, V> {
		@key : K;
		@value : V;
		@left : TreeNode<K, V>;
		@right : TreeNode<K, V>;
		@level : Int;
		
		New(key : K, value : V, level : Int) {
			@key := key;
			@value := value;
			@level := level;
			@left := Nil;
			@right := Nil;
		}

		method : public : SetKey(key : K) ~ Nil {
			@key := key;
		}
		
		method : public : GetKey() ~ K {
			return @key;
		}

		method : public : Get() ~ V {
			return @value;
		}
		
		method : public : GetLevel() ~ Int {
			return @level;
		}

		method : public : SetLevel(level : Int) ~ Nil {
			@level := level;
		}

		method : public : GetLeft() ~ TreeNode<K, V> {
			return @left;
		}

		method : public : SetLeft(left : TreeNode<K, V>) ~ Nil {
			@left := left;
		}

		method : public : GetRight() ~ TreeNode<K, V> {
			return @right;
		}

		method : public : SetRight(right : TreeNode<K, V>) ~ Nil {
			@right := right;
		}
	}
	
	#~
	Ordered set of generic objects

	```
# insert elements
set := Collection.Set->New()<String>;
set->Insert("San Francisco");
set->Insert("Oakland");
set->Insert("East Bay");

# get size
set->Size()->PrintLine();

# get value by key
set->Has("Oakland")->PrintLine();
	```	
	~#
	class Set<K : Compare> {
		@map : Map<K, Base>;

		#~
		Default constructor 
		~#
		New() {
			@map := Map->New()<K, Base>;
		}

		#~
		Inserts a key into the set
		@param key key
		~#
		method : public : Insert(key : K) ~ Nil {
			@map->Insert(key, key);
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			keys := GetKeys()<K>;
			each(i : keys) {
				# get string value if instance implements 'Stringify'
				key := keys->Get(i);

				if(key->TypeOf(Stringify)) {
					buffer->Append(key->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(key->GetInstanceID()->ToHexString());
				};

				# add comma
				if(i + 1 < keys->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}
		
		#~
		Removes a key from the set
		@param key key for value to remove
		@return true if removed, false otherwise		
		~#
		method : public : Remove(key : K) ~ Bool {
			return @map->Remove(key);
		}
    
    	#~
		Checks for key in set
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return @map->Find(key) <> Nil;
		}
    
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @map->GetKeys();
		}

		#~
		Clears the set
		~#
		method : public : Empty() ~ Nil {
			@map->Empty();
		}

		#~
		Checks to see if the set is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @map->IsEmpty();
		}
		
		#~
		Size of map
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @map->Size();
		}
	}

	#~
	Unordered set of generic objects

	```
# insert elements
set_hash := Collection.SetHash->New()<String>;
set_hash->Insert("San Francisco");
set_hash->Insert("Oakland");
set_hash->Insert("East Bay");

# get size
set_hash->Size()->PrintLine();

# get value by key
set_hash->Has("Oakland")->PrintLine();
	```	
	~#
	class SetHash<K : Compare> {
		@hash : Hash<K, K>;

		#~
		Default constructor 
		~#
		New() {
			@hash := Hash->New()<K, K>;
		}

		#~
		Inserts a key into the set
		@param key key
		~#
		method : public : Insert(key : K) ~ Nil {
			@hash->Insert(key, key);
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			keys := GetKeys()<K>;
			each(i : keys) {
				# get string value if instance implements 'Stringify'
				key := keys->Get(i);

				if(key->TypeOf(Stringify)) {
					buffer->Append(key->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append(key->GetInstanceID()->ToHexString());
				};

				# add comma
				if(i + 1 < keys->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}
		
		#~
		Removes a key from the set
		@param key key for value to remove
		@return true if removed, false otherwise		
		~#
		method : public : Remove(key : K) ~ Bool {
			return @hash->Remove(key);
		}
    
    	#~
		Checks for key in set
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return @hash->Has(key);
		}
    
		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @hash->GetKeys();
		}

		#~
		Clears the set
		~#
		method : public : Empty() ~ Nil {
			@hash->Empty();
		}

		#~
		Checks to see if the set is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @hash->IsEmpty();
		}
		
		#~
		Size of map
		@return size of queue
		~#
		method : public : Size() ~ Int {
			return @hash->Size();
		}
	}
		
	#~
	Ordered binary tree that holds multiple values with the same key
	~#
	class MultiMap<K : Compare, V> {
		@map : Map<K, Vector<V> >;

		#~
		Default constructor 
		~#
		New() {
			@map := Map->New()<K, Vector<V> >;
		}

		#~
		Inserts a value into the map
		@param key key
		@param value value
		~#
		method : public : Insert(key : K, value : V) ~ Nil {
			if(key = Nil) {
				return;
			};

			values := Find(key);
			if(values = Nil) {
				values := Vector->New()<V>;
				@map->Insert(key, values);
			};

			values->AddBack(value);
		}

		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#	
		method : public : Find(key : K) ~ Vector<V> {
			return @map->Find(key);
		}

		#~
		Get a collection of keys
		@return vector of keys
		~#
		method : public : GetKeys() ~ Vector<K> {
			return @map->GetKeys();
		}

		#~
		Gets a collection of values
		@return vector of values
		~#
		method : public : GetValues() ~ Vector<V> {
			values := Vector->New()<V>;

			keys := @map->GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				local_values := @map->Find(key)<V>;
				each(j : local_values) {
					values->AddBack(local_values->Get(j));
				};
			};

			return values;
		}

		#~
		Formats the collection into a string. If an element implements the 'Stringify' 
		interface, it's 'ToString()' is called.
		@return string representation
		~#
		method : public : ToString() ~ String {
			buffer := "[";

			keys := @map->GetKeys();
			each(i : keys) {

				# get key
				key := keys->Get(i)->As(Compare);
				if(key->TypeOf(Stringify)) {
					buffer->Append('(');
					buffer->Append(key->As(System.Stringify)->ToString());
				}
				# use instance ID instead
				else {
					buffer->Append('(');
					buffer->Append(key->GetInstanceID()->ToHexString());
				};
				buffer->Append(':');

				# get values
				values := @map->Find(key)<V>;
				each(j : values) {
					value := values->Get(j);
					if(value <> Nil) {
						if(value->TypeOf(Stringify)) {
							buffer->Append(value->As(System.Stringify)->ToString());
							
						}
						# use instance ID instead
						else {
							buffer->Append(value->GetInstanceID()->ToHexString());
						};
					};

					# add comma
					if(j + 1 < values->Size()) {
						buffer->Append(',');
					};
				};
				buffer->Append(')');

				# add comma
				if(i + 1 < keys->Size()) {
					buffer->Append(',');
				};
			};
			buffer->Append(']');

			return buffer;
		}

		#~
		Checks to see if the map is empty
		@return true if empty, false otherwise
		~#
		method : public : IsEmpty() ~ Bool {
			return @map->Size() = 0;
		}

		#~
		Clears the set
		~#
		method : public : Empty() ~ Nil {
			@map->Empty();
		}

		#~
		Checks for a value in a map
		@param key search key
		@return true if found, false otherwise
		~#
		method : public : Has(key : K) ~ Bool {
			return Find(key) <> Nil;
		}

		#~
		Uses the given function to filter out values
		@param f function to use a filter. If the function evaluates to true the value is added to the collection.
		@return filter vector
		~#
		method : public : Filter(f : (K) ~ Bool) ~ MultiMap<K, V> {
			filtered := MultiMap->New()<K, V>;
			
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				if(f(key)) {
					values := Find(key);
					each(j : values) {
						filtered->Insert(key, values->Get(j));
					};
				};
			};
			
			return filtered;
		}

		#~
		Uses the given function to reduce the values
		@param a initial value (i.e. accumulator)
		@param f function to use a reduce
		@return reduced vector
		~#
		method : public : Reduce(a : K, f : (K, K) ~ K) ~ K {
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i);
				a := f(a, key);
			};

			return a;
		}

		#~
		Function called for each element
		@param f function called
		~#
		method : public : Each(f : (K, V) ~ Nil) ~ MultiMap<K, V> {
			keys := GetKeys();
			each(i : keys) {
				key := keys->Get(i)->As(Clone)->Clone();
				values := Find(key->As(Compare));
				each(j : values) {
					f(key->As(Compare), values->Get(j));
				};
			};
			return @self;
		}

		#~
		Removes a set of values from the map
		@param key key for values to remove
		~#
		method : public : Remove(key : K) ~ Bool {
			return @map->Remove(key);
		}
		
		#~
		Size of unique keys
		@return size of unique keys
		~#
		method : public : Size() ~ Int {
			return @map->Size();
		}

		#~
		Size of values
		@return size of values
		~#
		method : public : TotalSize() ~ Int {
			return @map->GetValues()->Size();
		}
	}

	class Func2Composer<X, R> {
		@func : Func2Ref<X, R>;

		New(first : Func2Ref<X, R>) {
			@func := first;
		}

		method : public : Apply(x : X) ~ R {		
			func := @func->Get();
			return func(x);
		}

		method : public : Compose(before : Func2Ref<Base, X>) ~ Func2Composer<Base, R> {
			return Nil;
		}
	}
}
