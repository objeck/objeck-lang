use System.IO.Net, Collection, Data.JSON, Web.HTTP, Data.JSON.Scheme;

#~
Web server support (-lib net_server)
~#
bundle Web.HTTP.Server {
	#~
	HTTP and HTTP web server
	~#
	class WebServer {
		@stop : static : Bool;

		@secure_server : static : TCPSecureSocketServer;
		@server : static : TCPSocketServer;
		@server_config : static : WebServerConfig;
		@is_debug : static : Bool;

		#~
		Starts a HTTPS server that listens for requests
		@param filename configuration file (an <a href='https://github.com/objeck/objeck-web-server/blob/master/config/weather_config.json' target='_blank'>example</a>)
		~#
		function : ServeSecure(filename : String) ~ Nil {
			if(@server_config = Nil) {
				@server_config := WebServerConfig->New(filename);
			};

			if(@server_config->Load()) {
				callback := @server_config->GetClass();
				port := @server_config->GetPort();
				cert := @server_config->GetCertPath();
				cert_key := @server_config->GetCertKeyPath();
				cert_key_passwd := @server_config->GetCertPassword();

				if(@server_config->IsDebug()) {
					callback_str := "<Nil>";
					if(callback <> Nil) {
						callback_str := callback->GetName();
					};

					"=> Web server config: impl_class='{$callback_str}', port={$port}, cert='{$cert}', cert_key='{$cert_key}', cert_passwd='{$cert_key_passwd}'"->PrintLine();
				};

				if(callback <> Nil & port > 0 & cert <> Nil & cert_key <> Nil & cert_key_passwd <> Nil) {
					ServeSecure(callback, port, cert, cert_key, cert_key_passwd, @server_config->IsDebug());
				};
			};
		}

		#~
		Starts a HTTPS server that listens for requests
		@param callback class inherited from 'HttpsRequestHandler'
		@param port server port
		@param cert SSL certificate
		@param cert_key SSL certificate key
		@param cert_key_passwd SSL certificate password
		@param is_debug true for debug output, false otherwise
		~#
		function : ServeSecure(callback : Class, port : Int, cert : String, cert_key : String, cert_key_passwd : String) ~ Nil {
			ServeSecure(callback, port, cert, cert_key, cert_key_passwd, false);
		}

		#~
		Starts a HTTPS server that listens for requests
		@param callback class inherited from 'HttpsRequestHandler'
		@param port server port
		@param cert SSL certificate
		@param cert_key SSL certificate key
		@param cert_key_passwd SSL certificate password
		@param is_debug true for debug output, false otherwise
		~#
		function : ServeSecure(callback : Class, port : Int, cert : String, cert_key : String, cert_key_passwd : String, is_debug : Bool) ~ Nil {
			@secure_server := TCPSecureSocketServer->New(cert, cert_key, cert_key_passwd, port);
			@is_debug := is_debug;

			Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			if(@secure_server->Listen()) {
				if(@is_debug) {
					platform := Runtime->GetPlatform();
					host := TCPSocket->HostName();
					"=> Running on '{$host}' ({$platform}) port {$port}..."->PrintLine();
				};

				while(<>@stop) {
					thread := System.Concurrency.Thread->New() {
						New() {
							Parent()
						}

						method : public : Run(arg : System.Base) ~ Nil {
							params := arg->As(Collection.Tuple.Quartet<Class, TCPSecureSocket, WebServerConfig, BoolRef>);
							callback := params->GetFirst();
							secure_client := params->GetSecond();
							server_config := params->GetThird();
							is_debug := params->GetForth();

							handler := callback->Instance(callback->GetName())->As(HttpsRequestHandler);
							handler->SetConfig(server_config, is_debug->Get());
							handler->Execute(secure_client);
						}
					};

					params := Collection.Tuple.Quartet->New(callback, @secure_server->Accept(), @server_config, BoolRef->New(@is_debug))<Class, TCPSecureSocket, WebServerConfig, BoolRef>;
					thread->Execute(params);
				};
			}
			else {
				err_msg := @secure_server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
		}

		#~
		Starts a HTTP server that listens for requests
		@param filename configuration file (an <a href='https://github.com/objeck/objeck-web-server/blob/master/config/simple_config.json' target='_blank'>example</a>)
		~#
		function : Serve(filename : String) ~ Nil {
			@server_config := WebServerConfig->New(filename);
			if(@server_config->Load()) {
				# callback : Class, port : Int, is_debug : Bool
			};
		}

		#~
		Starts a HTTP server that listens for requests
		@param callback class inherited from 'HttpRequestHandler'
		@param port server port
		@param is_debug true for debug output, false otherwise
		~#
		function : Serve(callback : Class, port : Int) ~ Nil {
			Serve(callback, port, false);
		}

		#~
		Starts a HTTP server that listens for requests
		@param callback class inherited from 'HttpRequestHandler'
		@param port server port
		@param is_debug true for debug output, false otherwise
		~#
		function : Serve(callback : Class, port : Int, is_debug : Bool) ~ Nil {
			@server := TCPSocketServer->New(port);
			@is_debug := is_debug;

			Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			if(@server->Listen(8)) {
				if(@is_debug) {
					platform := Runtime->GetPlatform();
					host := TCPSocket->HostName();
					"=> Running on '{$host}' ({$platform}) port {$port}..."->PrintLine();
				};

				while(<>@stop) {
					thread := System.Concurrency.Thread->New() {
						New() {
							Parent()
						}

						method : public : Run(arg : System.Base) ~ Nil {
							params := arg->As(Collection.Tuple.Quartet<Class, TCPSocket, WebServerConfig, BoolRef>);
							callback := params->GetFirst();
							client := params->GetSecond();
							server_config := params->GetThird();
							is_debug := params->GetForth();

							handler := callback->Instance(callback->GetName())->As(HttpRequestHandler);
							handler->SetConfig(server_config, is_debug->Get());
							handler->Execute(client);
						}
					};

					params := Collection.Tuple.Quartet->New(callback, @server->Accept(), @server_config, BoolRef->New(@is_debug))<Class, TCPSocket, WebServerConfig, BoolRef>;
					thread->Execute(params);
				};
			}
			else {
				err_msg := @server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
		}

		#~
		Stops the server
		~#
		function : Stop() ~ Nil {
			@stop := true;

			if(@secure_server <> Nil) {
				@secure_server->Close();
			};

			if(@server <> Nil) {
				@server->Close();
			};
		}
		
		function : Shutdown(id : Int) ~ Nil {
			if(@secure_server <> Nil) {
				@secure_server->Close();
			};

			if(@server <> Nil) {
				@server->Close();
			};

			if(@is_debug) {
				"Shutting down..."->PrintLine();
			};
			
			Runtime->Exit(0);
		}
	}

	class WebServerConfig implements RequestPageHandler {
		@filename : String;
		@instance_str : String;
		@is_debug : Bool;
		@is_handling_files : Bool;
		@port : Int;
		@base_dir : String;
		@cert_path : String;
		@cert_key_path : String;
		@cert_passwd : String;
		@file_group_handler_map : Hash<String, FileGroupHandler>;
		@default_handler : FileHandler;
		@content_cache : Map<String, ByteArrayRef>;

		New(filename : String) {
			@filename := filename;
			@file_group_handler_map := Hash->New()<String, FileGroupHandler>;
			@content_cache := Map->New()<String, ByteArrayRef>;
		}

		method : public : GetFilename() ~ String {
			return @filename;
		}

		method : public : GetClass() ~ Class {
			class_instance := Class->Instance(@instance_str);
			if(class_instance <> Nil) {
				return class_instance->GetClass();
			};

			return Nil;
		}
		
		method : public : IsDebug() ~ Bool {
			return @is_debug;
		}

		method : public : IsHandlingFiles() ~ Bool {
			return @is_handling_files;
		}

		method : public : GetPort() ~ Int {
			return @port;
		}

		method : public : GetCertPath() ~ String {
			return @cert_path;
		}

		method : public : GetCertKeyPath() ~ String {
			return @cert_key_path;
		}

		method : public : GetCertPassword() ~ String {
			return @cert_passwd;
		}

		method : public : HasStaticHandler(name : String) ~ Bool {
			alias_str : String;
			if(name->StartsWith('/')) {
				alias_str := name->SubString(1, name->Size() - 1);
				if(alias_str = Nil) {
					return false;
				};
			}
			else {
				alias_str := name;
			};

			file_groups := @file_group_handler_map->GetValues()<FileGroupHandler>;
			each(i : file_groups) {
				file_group := file_groups->Get(i);
				if(file_group->HasGroupHander(alias_str)) {
					return true;
				};
			};

			return @default_handler <> Nil;
		}

		method : public : Load() ~ Bool {
			parser := JsonParser->New(System.IO.Filesystem.FileReader->ReadFile(@filename));
			if(parser->Parse()) {				
				# process network config
				network_json := parser->GetRoot()->Get("network");
				if(network_json = Nil | network_json->IsNull()) {
					"Error: missing 'network' tag"->ErrorLine();
					return false;
				};
				
				network_instance_json := network_json->Get("instance");
				network_port_json := network_json->Get("port");
				if(network_instance_json = Nil | network_instance_json->IsNull() | 
						network_port_json = Nil| network_port_json->IsNull()) {
					"Error: missing 'instance' or 'port' tag"->ErrorLine();
					return false;
				};
				@instance_str := network_instance_json->GetString();
				@port := network_port_json->GetString()->ToInt();

				is_debug_json := network_json->Get("debug");
				if(is_debug_json <> Nil & <>is_debug_json->IsNull()) {
					@is_debug := is_debug_json->GetBool();
				};
				
				network_secure_json := network_json->Get("secure");
				if(network_secure_json <> Nil & <>network_secure_json->IsNull()) {
					network_cert_path_json := network_secure_json->Get("cert_path");
					network_cert_key_json := network_secure_json->Get("cert_key_path");
					network_cert_passwd_json := network_secure_json->Get("cert_passwd");

					if(network_cert_path_json = Nil | network_cert_path_json->IsNull() |
							network_cert_key_json = Nil | network_cert_key_json->IsNull() | 
							network_cert_passwd_json = Nil | network_cert_passwd_json->IsNull()) {
						"Error: missing SSL certificate tags"->ErrorLine();
						return false;
					};
					@cert_path := network_cert_path_json->GetString();
					@cert_key_path := network_cert_key_json->GetString();
					@cert_passwd := network_cert_passwd_json->GetString();
				};

				# process files
				files_json := parser->GetRoot()->Get("files");
				if(files_json <> Nil & <>files_json->IsNull()) {
					# common configuration 
					common_json := files_json->Get("common");
					if(common_json <> Nil & <>common_json->IsNull()) {
						common_base_dir_json := common_json->Get("base_dir");
						if(common_base_dir_json <> Nil & <>common_base_dir_json->IsNull()) {
							@base_dir := common_base_dir_json->GetString();
						};

						# default file handler
						default_json := common_json->Get("default");
						if(default_json <> Nil & <>default_json->IsNull()) {
							alias_str := "<None>";
							alias_json := default_json->Get("alias");
							if(alias_json <> Nil & <>alias_json->IsNull()) {
								alias_str := alias_json->GetString();
							};

							if(alias_str->StartsWith('.') | alias_str->EndsWith('.') | alias_str->Count('.') <> 1) {
								"Error: 'alias' value must have a file extension: {$alias_str}"->ErrorLine();
								return false;
							};

							location_str := "<None>";
							location_json := default_json->Get("location");
							if(location_json <> Nil & <>location_json->IsNull()) {
								location_str := location_json->GetString();
							};

							mime_type_str := "text/plain";
							mime_type_json := default_json->Get("mime-type");
							if(mime_type_json <> Nil & <>mime_type_json->IsNull()) {
								mime_type_str := mime_type_json->GetString();
							};

							cache_flag : Bool;
							cache_json := default_json->Get("cache");
							if(cache_json <> Nil & <>cache_json->IsNull()) {
								cache_flag := cache_json->GetBool();
							};

							@default_handler := FileHandler->New("[default]", alias_str, location_str, mime_type_str, cache_flag);
						};

					};

					# individual files
					groups_json := files_json->Get("groups");
					if(groups_json <> Nil & <>groups_json->IsNull()) {
						each(group_json in groups_json) {
							if(group_json->Has("group") & group_json->Has("items") & group_json->Has("mime-type") & group_json->Size() = 3) {
								group_str := group_json->Get("group")->GetString();
								mime_str := group_json->Get("mime-type")->GetString();
								items_json := group_json->Get("items");
								each(item_json in items_json) {
									if(<>AddFiles(group_str, mime_str, item_json)) {
										return false;
									};
								};
							}
							else {
								"Error: group have a 'group' label and an array of 'items'."->ErrorLine();
								return false;
							};
						};

						@is_handling_files := true;
					}
					else {
						"Error: missing 'groups' tag"->ErrorLine();
						return false;
					}
					@is_handling_files := true;
				}
				else {
					"Error: missing 'files' tag"->ErrorLine();
					return false;
				};

				if(@is_debug) {
					group_handler_size := @file_group_handler_map->Size();
					"File group count: {$group_handler_size}"->PrintLine();
				}

				return true;
			};

			return false;
		}

		method : AddFiles(group : String, mimi : String, item_json : JsonElement) ~ Bool {		
			if(<>group->StartsWith('.')) {
				"Error: file 'group' value must start with '.'"->ErrorLine();
				return false;
			};

			if(<>AddHandler(group, mimi, item_json)) {
				return false;
			};

			return true;
		}

		method : AddHandler(group : String, mimi : String, item_json : JsonElement) ~ Bool {
			alias_str := "<None>";
			alias_json := item_json->Get("alias");
			if(alias_json <> Nil & <>alias_json->IsNull()) {
				alias_str := alias_json->GetString();
			};

			if(alias_str->StartsWith('.') | alias_str->EndsWith('.') | alias_str->Count('.') <> 1) {
				"Error: 'alias' value must have a file extension: {$alias_str}"->ErrorLine();
				return false;
			};

			location_str := "<None>";
			location_json := item_json->Get("location");
			if(location_json <> Nil & <>location_json->IsNull()) {
				location_str := location_json->GetString();
			};

			cache_flag : Bool;
			cache_json := item_json->Get("cache");
			if(cache_json <> Nil & <>cache_json->IsNull()) {
				cache_flag := cache_json->GetBool();
			};

			# get/add handler
			group_handler := @file_group_handler_map->Find(group);
			if(group_handler = Nil) {
				group_handler := FileGroupHandler->New(group);
				@file_group_handler_map->Insert(group, group_handler);
			};

			if(<>group_handler->Insert(alias_str, location_str, mimi, cache_flag)) {
				"Unable to add file: alias='{$alias_str}', location='{$location_str}'"->ErrorLine();
				return false;
			};

			return true;
		}

		method : public : ToString() ~ String {
			buffer := "[Network]\n";
			buffer += "\tfilename='{$@filename}', instance='{$@instance_str}', handling_files='{$@is_handling_files}', port='{$@port}, is_debug='{$@is_debug}\n";
			if(@cert_path <> Nil & @cert_key_path <> Nil & @cert_passwd <> Nil) {
				buffer += "\tcert_path='{$@cert_path}', cert_key='{$@cert_key_path}', cert_passwd='{$@cert_passwd}'\n";
			};

			buffer += "[Files]\n";
			file_group_pairs := @file_group_handler_map->GetKeyValues()<Pair<String, FileGroupHandler>>;
			each(i : file_group_pairs) {
				file_group_pair := file_group_pairs->Get(i);

				file_group_name := file_group_pair->GetFirst();
				buffer += "\t{'{$file_group_name}}\n";
				file_group_handler := file_group_pair->GetSecond();
				buffer += file_group_handler->ToString();
			};
			
			return buffer;
		}

		#~
		Callback for GET requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : ProcessGet(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool {
			return Process(request , response);
		}

		#~
		Callback for POST requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : ProcessPost(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool {
			return Process(request , response);
		}

		method : Process(request : Request, response : Response) ~ Bool {
			request_path : String;
			if(response->HasForwardAlias()) {
				request_path := response->GetForwardAlias();
			}
			else {
				request_path := request->GetPath();
			};

			request_group_index := request_path->FindLast('.');
			# alias
			if(request_group_index > 0) {
				request_group := request_path->SubString(request_group_index, request_path->Size() - request_group_index);
				if(request_group = Nil) {
					return false;
				};

				alias_str := request_path->SubString(1, request_path->Size() - 1);
				if(alias_str = Nil) {
					return false;
				};

				file_group_handler := @file_group_handler_map->Find(request_group);
				if(file_group_handler = Nil) {
					return false;
				};

				file_handler := file_group_handler->GetFileHander(alias_str);
				if(file_handler = Nil) {
					# last ditch effort...
					if(@default_handler <> Nil) {
						file_handler := @default_handler;
					}
					else {
						return false;
					};
				};

				return Process(file_handler, response);
			};

			# last ditch effort...
			if(@default_handler <> Nil) {
				return Process(@default_handler, response);
			};
			
			return false;
		}

		method : Process(file_handler : FileHandler, response : Response) ~ Bool {
			if(@is_debug) {
				file_handler_str := file_handler->ToString();
				"Item properties: {$file_handler_str}"->PrintLine();
			};
			
			buffer : Byte[];

			file_location : String;

			if(@base_dir <> Nil) {
				file_location := String->New(@base_dir);
				if(<>file_location->EndsWith('/') & <>file_location->EndsWith('\\')) {
					file_location += System.IO.Filesystem.Directory->GetSlash();
				};
				file_location += file_handler->GetLocation();
			}
			else {
				file_location := file_handler->GetLocation();
			};

			if(@is_debug) {
				"File location='{$file_location}'"->PrintLine();
			};

			# use caching
			if(file_handler->IsCached()) {
				buffer_holder := @content_cache->Find(file_location);
				if(buffer_holder = Nil) {
					buffer := System.IO.Filesystem.FileReader->ReadBinaryFile(file_location);
					if(buffer = Nil) {
						return false;
					};
					@content_cache->Insert(file_location, ByteArrayRef->New(buffer));
					if(@is_debug) {
						"---"->PrintLine();
					};
				}
				else {
					if(@is_debug) {
						"=> Cached\n---"->PrintLine();
					};
					buffer := buffer_holder->Get();
				};
			}
			# non-caching
			else {	
				buffer := System.IO.Filesystem.FileReader->ReadBinaryFile(file_location);
				if(buffer = Nil) {
					return false;
				};					
			};
			response->SetCodeContent(200, buffer);
			
			return true;
		}
	}

	class : private : FileGroupHandler {
		@group : String;
		@alias_map : Map<String, FileHandler>;

		New(group : String) {
			@group := group;
			@alias_map := Map->New()<String, FileHandler>;
		}

		method : public : Insert(alias_str : String, location_str : String, mime_type_str : String, cache_flag : Bool) ~ Bool {
			if(alias_str->Equals("<None>") | location_str->Equals("<None>") | @alias_map->Has(location_str)) {
				return false;
			};

			file_handler := FileHandler->New(@group, alias_str, location_str, mime_type_str, cache_flag);
			@alias_map->Insert(alias_str, file_handler);

			return true;
		}

		method : public : GetFileHander(alias_str : String) ~ FileHandler {
			return @alias_map->Find(alias_str);
		}

		method : public : HasGroupHander(alias_str : String) ~ Bool {
			return @alias_map->Has(alias_str);
		}

		method : public : ToString() ~ String {
			buffer := "";

			alias_handlers := @alias_map->GetValues()<FileHandler>;
			each(i : alias_handlers) {
				alias_handler := alias_handlers->Get(i);
				buffer += '\t';
				buffer += alias_handler->ToString();
				buffer += "\n";
			};

			return buffer;
		}
	}

	class : private : FileHandler {
		@group : String;
		@alias_str : String;
		@location : String;
		@mime_type : String;
		@cache : Bool;

		New(group : String, alias_str : String, location : String, mime_type : String, cache : Bool) {
			@group := group;
			@alias_str := alias_str;
			@location := location;
			@mime_type := mime_type;
			@cache := cache;
		}

		method : public : GetAlias() ~ String {
			return @alias_str;
		}

		method : public : GetLocation() ~ String {
			return @location;
		}

		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		method : public : IsCached() ~ Bool {
			return @cache;
		}

		method : public : ToString() ~ String {
			return "alias='{$@alias_str}', location='{$@location}', mime_type='{$@mime_type}', cache={$@cache}, group='{$@group}'";
		}
	}

	#~
	Web server request
	~#
	class Request {
		@request_line : String;
		@request_path : String;
		@request_query : String;

		@request_headers : Map<String, String>;
		@request_params : Map<String, String>;
		@cookies : Map<String, Cookie>;
		@content : Byte[];

		New(request_line : String, request_headers : Map<String, String>) {
			@request_line := request_line;
			@request_headers := request_headers;

			query_index := @request_line->Find('?');
			if(query_index > 0) {
				@request_path := @request_line->SubString(query_index);
				query_index += 1;
				@request_query := @request_line->SubString(query_index, @request_line->Size() - query_index);
				@content := @request_query->ToByteArray();
			}
			else {
				@request_path := request_line;
			};
		}

		New(request_line : String, request_headers : Map<String, String>, content : Byte[]) {
			@request_line := request_line;
			@request_headers := request_headers;
			@content := content;
		}

		#~
		Parses an attribute string
		@param attrib_str attribute string
		@return map of names/values
		~#
		function : ParseAttribs(attrib_str : String) ~ Map<String, String> {
			return WebCommon->ParseAttribs(attrib_str);
		}

		#~
		Gets a parameter value
		@param name parameter name
		@return parameter value
		~#
		method : public : GetParam(name : String) ~ String {
			ParseParams();

			if(@request_params <> Nil) {
				return @request_params->Find(name);
			};

			return Nil;
		}

		#~
		Checks for a parameter
		@param name parameter name
		@return true if parameter exists, false otherwise
		~#
		method : public : HasParam(name : String) ~ Bool {
			ParseParams();

			if(@request_params <> Nil) {
				return @request_params->Has(name);
			};

			return false;
		}

		#~
		Gets parameters
		@return parameters
		~#
		method : public : GetParams() ~ Map<String, String> {
			ParseParams();

			if(@request_params <> Nil) {
				return @request_params;
			};

			return Nil;
		}

		method : ParseParams() ~ Nil {
			if(@content <> Nil & @request_params = Nil) {
				@request_params := Map->New()<String, String>;
				
				params_str := @content->ToString();
				param_names_values := params_str->Split('&');
				if(param_names_values->Size() > 0) {
					each(i : param_names_values) {
						param_name_value := param_names_values[i]->Split('=');
						if(param_name_value->Size() = 2) {
							name := param_name_value[0];
							value := Url->Decode(param_name_value[1]);
							@request_params->Insert(name, value);
						};
					};
				}
				else {
					param_name_value := params_str->Split('=');
					if(param_name_value->Size() = 2) {
						@request_params->Insert(param_name_value[0], param_name_value[1]);
					};
				};
			};
		}

		#~
		Gets a cookie value
		@param name cookie name
		@return cookie value
		~#
		method : public : GetCookie(name : String) ~ Cookie {
			ParseCookies();

			return @cookies->Find(name);
		}

		#~
		Checks for a cookie
		@param name cookie name
		@return true if cookie exists, false otherwise
		~#
		method : public : HasCookie(name : String) ~ Bool {
			ParseCookies();

			return @cookies->Has(name);
		}

		#~
		Gets cookies
		@return cookies
		~#
		method : public : GetCookies() ~ Vector<Cookie> {
			ParseCookies();

			return @cookies->GetValues()<Cookie>;
		}

		method : ParseCookies() ~ Nil {
			if(@cookies = Nil) {
				@cookies := Map->New()<String, Cookie>;
				
				cookies_str := @request_headers->Find("Cookie");
				if(cookies_str <> Nil) {
					cookie_names_values := cookies_str->Split("; ");
					each(i : cookie_names_values) {
						cookie_name_value := cookie_names_values[i]->Split('=');
						if(cookie_name_value->Size() = 2) {
							name := cookie_name_value[0];
							value := cookie_name_value[1];

							@cookies->Insert(name, Cookie->New(name, value));
						};
					};
				};
			};
		}

		#~
		Gets the request body content
		@return request content
		~#
		method : public : GetContent() ~ String {
			return @content->ToString();
		}

		#~
		Checks for request body content
		@return true if content exists, false otherwise
		~#
		method : public : HasContent() ~ Bool {
			return @content <> Nil;
		}

		#~
		Gets the request body content as bytes
		@return request content as bytes
		~#
		method : public : GetContentBytes() ~ Byte[] {
			return @content;
		}

		#~
		Gets the request line
		@return request line
		~#
		method : public : GetRequestLine() ~ String {
			return @request_line;
		}

		#~
		Gets the request path
		@return request path
		~#
		method : public : GetPath() ~ String {
			return @request_path;
		}

		#~
		Gets the request query
		@return request query
		~#
		method : public : GetQuery() ~ String {
			return @request_query;
		}

		#~
		Gets a request header
		@param name header name
		@return request header
		~#
		method : public : GetHeader(name : String) ~ String {
			return @request_headers->Find(name)<String>;
		}
	}

	#~
	Web server response
	~#
	class Response {
		@code : Int;
		@content : Byte[];
		@compression : Compression;
		@is_compressed : Bool;
		@reason : String;
		@response_headers : Map<String, String>;
		@cookies : Map<String, Cookie>;
		@server_config : WebServerConfig;
		@request_path : String;
		@forward_alias_name : String;

		enum Compression := 100 {
			NONE,
			GZIP,
			DEFLATE,
			BR
		}

		New(server_config : WebServerConfig, request_path : String) {
			@server_config := server_config;
			@request_path := request_path;

			@code := 400;
			@compression := Compression->NONE;
			@is_compressed := false;
			@response_headers := Map->New()<String, String>;
			@cookies := Map->New()<String, Cookie>;
		}

		#~
		Adds a cookie
		@param cookie cookie
		~#
		method : public : AddCookie(cookie : Cookie) ~ Nil {
			@cookies->Insert(cookie->GetName(), cookie);
		}

		#~
		Updates a cookie
		@param name cookie name
		@param value cookie value
		~#
		method : public : GetCookie(name : String) ~ Cookie {
			return @cookies->Find(name);
		}

		#~
		Removes a cookie
		@param name cookie name
		~#
		method : public : RemoveCookie(name : String) ~ Nil {
			cookie := @cookies->Find(name);
			if(cookie <> Nil) {
				cookie->Expire();
			};
		}

		#~
		Gets all cookies
		@return all cookies
		~#
		method : public : GetCookies() ~ Vector<Cookie> {
			return @cookies->GetValues()<Cookie>;
		}

		#~
		Check to see if the response has configured handler
		@return true if handler exists, false otherwise
		~#
		method : public : HasStaticHandler() ~ Bool {
			if(@server_config <> Nil & @request_path <> Nil) {
				return @server_config->HasStaticHandler(@request_path);
			};

			return false;
		}

		#~
		Set the forward page alias
		@param name forward page alias
		@return true if set, false otherwise
		~#
		method : public : SetForwardAlias(name : String) ~ Bool {
			if(@server_config <> Nil & @server_config->HasStaticHandler(name)) {
				@forward_name := "";
				if(<>name->StartsWith('/')) {
					@forward_name += '/';
				};
				@forward_name += name;

				return true;
			};

			return false;
		}

		#~
		Gets the forward page alias
		@return forward page alias
		~#
		method : public : GetForwardAlias() ~ String {
			return @forward_alias_name;
		}

		#~
		Checks the forward page alias
		@return true if forward page alias exists, false otherwise
		~#
		method : public : HasForwardAlias() ~ Bool {
			return @forward_alias_name <> Nil;
		}

		#~
		Get the response code
		@return response code
		~#
		method : public : GetCode() ~ Int {
			return @code;
		}

		#~
		Set response code
		@param code response code
		~#
		method : public : SetCode(code : Int) ~ Nil {
			@code := code;
		}

		#~
		Set response content
		@param content response content
		~#
		method : public : SetContent(content : Byte[]) ~ Nil {
			@content := content;
		}

		#~
		Set response code
		@param content response content
		~#
		method : public : SetContent(content : String) ~ Nil {
			@content := content->ToByteArray();
		}

		#~
		Set the response compression, should be called after the content is set
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetCompression(compression : Compression) ~ Nil {
			if(<>@is_compressed & @content <> Nil) {
				select(compression) {
					label Compression->GZIP	{
						@content := @content->CompressGzip();
						@response_headers->Insert("Content-Encoding", "gzip");
						@is_compressed := true;
					}

					label Compression->DEFLATE {
						@content := @content->CompressZlib();
						@response_headers->Insert("Content-Encoding", "deflate");
						@is_compressed := true;
					}

					label Compression->BR {
						@content := @content->CompressBr();
						@response_headers->Insert("Content-Encoding", "br");
						@is_compressed := true;
					}
				};
			};
		}

		#~
		Set response code, content and compression type
		@param code response code
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetCodeContentCompression(code : Int, content : String, compression : Compression) ~ Nil {
			SetCodeContentCompression(code, content->ToByteArray(), compression);
		}

		#~
		Set response code, content and compression type
		@param code response code
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetCodeContentCompression(code : Int, content : Byte[], compression : Compression) ~ Nil {
			@code := code;
			@content := content;
			SetCompression(compression);
		}

		#~
		Set content and compression type
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetContentCompression(content : String, compression : Compression) ~ Nil {
			SetContentCompression(content->ToByteArray(), compression);
		}

		#~
		Set content and compression type
		@param content response content
		@param compression response compression (br = Brotli, deflate = zlib, gzip = GNU zip)
		~#
		method : public : SetContentCompression(content : Byte[], compression : Compression) ~ Nil {
			@content := content;
			SetCompression(compression);
		}

		#~
		Set response code and content
		@param code response code
		@param content response content
		~#
		method : public : SetCodeContent(code : Int, content : Byte[]) ~ Nil {
			@code := code;
			@content := content;
		}

		#~
		Set response code and content
		@param code response code
		@param content response content
		~#
		method : public : SetCodeContent(code : Int, content : String) ~ Nil {
			@code := code;
			@content := content->ToByteArray();
		}

		#~
		Set response code, type and content
		@param code response code
		@param type content type
		@param content response content
		~#
		method : public : SetCodeTypeContent(code : Int, type : String, content : Byte[]) ~ Nil {
			@code := code;
			@content := content;
			SetContentType(type);
		}

		#~
		Set response code and type
		@param code response code
		@param type content type
		~#
		method : public : SetCodeType(code : Int, type : String) ~ Nil {
			@code := code;
			SetContentType(type);
		}

		#~
		Set response code and content
		@param code response code
		@param type content type
		@param content response content
		~#
		method : public : SetCodeTypeContent(code : Int, type : String, content : String) ~ Nil {
			@code := code;
			@content := content->ToByteArray();
			SetContentType(type);
		}

		#~
		Get the response content
		@return response content
		~#
		method : public : GetContent() ~ Byte[] {
			return @content;
		}

		#~
		Checks for request body content
		@return true if content exists, false otherwise
		~#
		method : public : HasContent() ~ Bool {
			return @content <> Nil;
		}

		#~
		Get the response content as string
		@return response content as string
		~#
		method : public : GetStringContent() ~ String {
			return @content->ToString();
		}

		#~
		Set response reason
		@param reason response reason
		~#
		method : public : SetReason(reason : String) ~ Nil {
			@reason := reason;
		}

		#~
		Get the reason string
		@return reason sting
		~#
		method : public : GetReason() ~ String {
			return @reason;
		}

		#~
		Sets the content type
		@param type content type
		~#
		method : public : SetContentType(type : String) ~ Nil {
			@response_headers->Insert("Content-Type", type);
		}

		#~
		Gets a response header
		@param name header name
		@return response header
		~#
		method : public : GetHeader(name : String) ~ String {
			return @response_headers->Find(name)<String>;
		}

		#~
		Gets response headers
		@return response headers
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			return @response_headers;
		}

		#~
		Sets a response header
		@param name header name
		@param value header value
		~#
		method : public : SetHeader(name : String, value : String) ~ Nil {
			if(value = Nil | value->IsEmpty()) {
				@response_headers->Remove(name);
			}
			else {
				@response_headers->Insert(name, value)<String>;
			};
		}

		#~
		Removed a response header
		@param name header name
		~#
		method : public : RemoveHeader(name : String) ~ Nil {
			SetHeader(name, Nil);
		}

		#~
		Check for a response header
		@param name header name
		@return true if header exists, false otherwise
		~#
		method : public : HasHeader(name : String) ~ Bool {
			return @response_headers->Has(name);
		}

		#~
		Get the reason string
		@return reason sting
		~#
		method : public : ToString() ~ String {
			if(@content <> Nil) {
				content_size := @content->Size();
				return "code='{$@code}, reason='{$@reason}, content_size='{$content_size}";
			};

			return "<Nil>";
		}
	}

	#~
	Multipart encoder
	~#
	class MultipartEncoder {
		@parts : Vector<MultipartContent>;
		@boundary : String;

		New() {
			@parts := Vector->New()<MultipartContent>;
			@boundary := GetBoundary();
		}

		#~
		Add a multipart encoding content part
		@param part content part to add
		~#
		method : public : Add(part : MultipartContent) ~ Nil {
			@parts->AddBack(part);
		}

		#~
		Formats content into multi-parts bytes
		@return multi-parts bytes
		~#
		method : public : ToByteArray() ~ Byte[] {
			buffer := ByteBuffer->New();

			crlf := "\r\n"->ToByteArray();
			header_space := ": "->ToByteArray();

			each(part in @parts) {
				buffer->Append("--"->ToByteArray());
				buffer->Append(@boundary->ToByteArray());
				buffer->Append(crlf);

				part_headers := part->GetHeaders();
				names_values := part_headers->GetKeyValues()<Pair<String, String>>;
				each(name_value in names_values) {
					name := name_value->GetFirst();
					value := name_value->GetSecond();

					buffer->Append(name->ToByteArray());
					buffer->Append(header_space);
					buffer->Append(value->ToByteArray());
					buffer->Append(crlf);
				};
				buffer->Append(crlf);

				# content
				buffer->Append(part->GetContent());
				buffer->Append(crlf);
			};
	
			buffer->Append("--"->ToByteArray());
			buffer->Append(@boundary->ToByteArray());
			buffer->Append("--"->ToByteArray());

			return buffer->ToByteArray();
		}

		#~
		Get boundary marker
		@return boundary marker
		~#
		method : public : GetBoundary() ~ String {
			if(@boundary = Nil) {
				@boundary := "------------------------";

				corups := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
				do {
					c := corups->Get(Int->Random(0, corups->Size() - 1));
					@boundary->Append(c);
				}
				while(@boundary->Size() < 48);
			};

			return @boundary;		
		}
	}
	
	#~
	Multipart decoder
	~#
	class MultipartDecoder {
		@encoded : Byte[];

		#~
		Parses multipart encoding
		@param encoded encoded bytes
		~#
		New(encoded : Byte[]) {
			@encoded := encoded;
		}
		
		#~
		Parses multipart encoding
		@return content parts
		~#
		method : public : native : Parse() ~ Vector<MultipartContent> {
			multipart_content := Vector->New()<MultipartContent>;

			marker_bytes : Byte[];
			offset := 0;
			do {
				bytes := ReadLine(offset, @encoded);
				if(bytes = Nil) {
					offset := -1;
				}
				else {
					offset += bytes->Size() + 1;
					line := String->New(bytes)->Trim();
					
					if(line->IsEmpty()) {
						offset := -1;
					}
					else {
						if(line->StartsWith("---")) {

						}
						else if(line->StartsWith("boundary=")) {
							boundry_offset := "boundary="->Size() + 1;
							marker_str := line->SubString(boundry_offset, line->Size() - boundry_offset - 1);
							marker_bytes := marker_str->ToByteArray();
						};
					};
				};
			}
			while(offset > -1);

			if(marker_bytes = Nil) {
				return Nil;
			};

			encoding_size := @encoded->Size();
			
			# fetch all markers
			marker_indexes := Byte->FindAll(@encoded, marker_bytes);
			if(marker_indexes = Nil) {
				return Nil;
			};

			for(i := 0; i < marker_indexes->Size() - 1; i += 1;) {
				marker_indexes[i]->PrintLine();
			};

			boundry_index := 0;
			for(i := 0; i < marker_indexes->Size() - 1; i += 1;) {
				boundary_bytes := ReadLine(marker_indexes[i], @encoded);
				if(boundary_bytes = Nil) {
					return Nil;
				};
				boundry_index += boundary_bytes->Size();

				# read white space
				if(MatchSpace(boundry_index, @encoded)) {
					boundry_index += 2;
				};
	 
				# read content headers
				done := false;
				headers := Map->New()<String, String>;
				do {
					# read content line
					header_bytes := ReadLine(boundry_index, @encoded);
					if(header_bytes <> Nil) {			
						boundry_index += header_bytes->Size();
						content_str := header_bytes->ToString();
						
						# parse header name/value pair
						content_str_index := content_str->Find(':');
						if(content_str_index > 0) {
							header_name := content_str->SubString(content_str_index);
							content_str_index += 2;
							header_value := content_str->SubString(content_str_index, content_str->Size() - content_str_index);
							
							if(<>header_name->IsEmpty() & <>header_value->IsEmpty()) {
								headers->Insert(header_name->ToLower(), header_value);
							};
						};
					}
					else {
						done := true;
					};

					# read white space
					if(<>MatchSpace(boundry_index, @encoded)) {

						return Nil;
					};
					boundry_index += 2;
				}
				while(<>done);
				
				# read content
				content_size := marker_indexes[i + 1] - boundry_index - 2;
				
				content_bytes := Byte->New[content_size];
				if(<>Runtime->Copy(content_bytes, 0, @encoded, boundry_index, content_size)) {
					return Nil;
				};
				boundry_index += content_bytes->Size();

				# read white space
				if(MatchSpace(boundry_index, @encoded)) {
					boundry_index += 2;
				};


				multipart_content->AddBack(MultipartContent->New(headers, content_bytes));
			};

			# read ending boundary
			boundary_bytes := ReadLine(marker_indexes[marker_indexes->Size() - 1], @encoded);
			if(boundary_bytes = Nil) {
				return Nil;
			};
			boundry_index += boundary_bytes->Size();

			# read white space
			if(<>MatchSpace(boundry_index, @encoded)) {
				return Nil;
			};
			boundry_index += 2;

			boundary_str := boundary_bytes->ToString();
			if(boundary_str->EndsWith("--") & encoding_size = boundry_index) {
				return multipart_content;
			};

			return Nil;
		}

		method : native : ReadLine(offset : Int, encoded : Byte[]) ~ Byte[] {
			i := offset;
			if(i < encoded->Size()) {
				done := false;
				read := 0;
				while(<>done & i < encoded->Size()) {
					byte := encoded[i++];
					if(byte = '\r') {
						done := true;
					}
					else {
						read += 1;
					};
				};

				line := Byte->New[read];
				if(Runtime->Copy(line, 0, encoded, offset, read)) {
					return line;
				};
			};

			return Nil;
		}

		method : native : MatchSpace(offset : Int, encoded : Byte[]) ~ Bool {
			if(offset + 1 < encoded->Size()) {
				return encoded[offset] = '\r' & encoded[offset + 1] = '\n';
			};

			return false;
		}
	}

	#~
	Multipart content 
	~#
	class MultipartContent {
		@headers : Map<String, String>;
		@content : Byte[];

		#~
		Constructor
		@param headers name/value headers. Names are store as lower-case.
		@param content content
		~#
		New(headers : Map<String, String>, content : Byte[]) {
			@content := content;

			@headers := Map->New()<String, String>;
			keys_values := headers->GetKeyValues()<Pair<String, String>>;
			each(key_value in keys_values) {
				key := key_value->GetFirst()->ToLower();
				@headers->Insert(key, key_value->GetSecond());
			};

		}

		#~
		Get MIME content header
		@param name header name
		@return header value
		~#
		method : public : GetHeader(name : String) ~ String {	
			return @headers->Find(name);
		}

		#~
		Get MIME content headers
		@return content headers 
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			return @headers;
		}

		#~
		Get MIME content header names
		@return header names
		~#
		method : public : GetHeaderNames() ~ Vector<String> {	
			return @headers->GetKeys()<String>;
		}

		#~
		Get MIME content
		@return MIME bytes
		~#
		method : public : GetContent() ~ Byte[] {
			return @content;
		}

		#~
		Checks for request body content
		@return true if content exists, false otherwise
		~#
		method : public : HasContent() ~ Bool {
			return @content <> Nil;
		}
	}

	#~
	Interface for HTTP page requests
	~#
	interface RequestPageHandler {
		#~
		Callback for GET requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : virtual : ProcessGet(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool;

		#~
		Callback for POST requests
		@param request HTTP request
		@param response HTTP response
		~#
		method : public : virtual : ProcessPost(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool;
	}

	#~
	Request handler for HTTPS GET and POST requests. <p>Sample <a href="https://github.com/objeck/objeck-web-server/blob/master/config/simple_config.json" target="_blank">configuration</a> file<./p>

```
use Web.HTTP.Server;

class Test {
   function : Main(args : String[]) ~ Nil {
      WebServer->ServeSecure("config/simple_config.json");
   }
}

class RequestHandler from HttpsRequestHandler {
   New() {
      Parent();
   }
   
   method : ProcessGet(request : Request, response : Response) ~ Bool {
      return response->HasStaticHandler();
   }

   method : ProcessPost(request : Request, response : Response) ~ Bool {
      return false;
   }
}      
```
	~#
	class HttpsRequestHandler from System.Concurrency.Thread {
		@client : TCPSecureSocket;
		@server_config : WebServerConfig;
		@is_debug : Bool;

		New() {
			Parent();
		}

		method : public : SetConfig(server_config : WebServerConfig, is_debug : Bool) ~ Nil {
			@server_config := server_config;
			@is_debug := is_debug;
		}
        
		method : public : Run(param : Base) ~ Nil {
			@client := param->As(TCPSecureSocket);

			if(@client <> Nil & @client->IsOpen()) {
				# get request
				request := @client->ReadLine();
				if(@is_debug) {
					request_address := @client->GetAddress();
					"===\nRequest: '{$request}' from '{$request_address}'\n==="->PrintLine();
				};

				# parse request
				request_verb : String; request_path : String;
				if(request->Size() > 0) {
					request_parts := request->Split(" ");
					if(request_parts->Size() = 3) {
						request_verb := request_parts[0];
						request_path := request_parts[1];
					};
				};

				# get request headers
				request_headers := GetHeaders();

				# verify request
				if(request_verb <> Nil & request_path <> Nil & <>request_path->IsEmpty()) {
					# GET and HEAD request
					if(request_verb->Equals("GET") | request_verb->Equals("HEAD")) {
						# retrieve content
						if(request_path = Nil | request_path->Equals("/") | request_path->Has("..")) {
							request_path := "/index.html";
						};

						# write response
						http_request := Request->New(request_path, request_headers);
						http_response := Response->New(@server_config, http_request->GetPath());
						
						if(ProcessGet(http_request, http_response) & @server_config <> Nil & @server_config->IsHandlingFiles()) {
							@server_config->ProcessGet(http_request, http_response);
						};
						ProcessResponse(http_response, request_verb->Equals("HEAD"));
					}
					# POST request
					else if(request_verb->Equals("POST")) {
						content_length_str := request_headers->Find("content-length");
						if(content_length_str <> Nil) {
							content_length  := content_length_str->ToInt();
							if(content_length > 0) {
								buffer := WebCommon->ReadPost(content_length, @client);
								
								# retrieve content
								if(request_path = Nil | request_path->Equals("/") | request_path->Has("..")) {
									request_path := "/index.html";
								};

								# write response
								http_request := Request->New(request_path, request_headers, buffer);
								http_response := Response->New(@server_config, http_request->GetPath());
								
								if(ProcessPost(http_request, http_response) & @server_config <> Nil & @server_config->IsHandlingFiles()) {
									@server_config->ProcessPost(http_request, http_response);
								};
								ProcessResponse(http_response);
							};
						};
					};
				};

				@client->Close();
			};
		}

		method : ProcessResponse(response : Response, is_head : Bool := false) ~ Nil {
			if(response <> Nil) {
				response_headers := response->GetHeaders();
				if(response->GetCode() = 200) {
					response_header := "";
					key_values := response_headers->GetKeyValues()<Pair<String, String>>;
					each(i : key_values) {
						key_value := key_values->Get(i);
						key := key_value->GetFirst();
						value := key_value->GetSecond();
						response_header += "{$key}: {$value}\r\n";
					};

					content := response->GetContent();
					if(content <> Nil) {
						content_size := content->Size();
						response_header += "content-length: {$content_size}\r\nAccept-Ranges: bytes\r\nConnection: close\r\n";

						cookies := response->GetCookies()<Cookie>;
						each(i : cookies) {
							cookie := cookies->Get(i);
							response_header += "Set-Cookie: ";
							response_header += cookie->ToString();
							response_header += "\r\n";
						};

						@client->WriteString("HTTP/1.1 200 OK\r\n{$response_header}\r\n");
						if(<>is_head) {
							@client->WriteBuffer(content);
						};
					}
					else {
						@client->WriteString("HTTP/1.1 200\r\n\r\n");
					};
				}
				else {
					select(response->GetCode()) {
						label 202 {
							@client->WriteString("HTTP/1.1 202 Accepted\r\n\r\n");
						}

						label 302 {
							reason := response->GetReason();
							if(reason <> Nil) {
								@client->WriteString("HTTP/1.1 302 Found\r\nLocation: {$reason}\r\nConnection: close\r\n\r\n");
							}
							else {
								@client->WriteString("HTTP/1.1 400\r\n\r\n");
							};
						}

						label 404 {
							@client->WriteString("HTTP/1.1 404 Not Found\r\n\r\n");
						}

						label 410 {
							@client->WriteString("HTTP/1.1 410 Gone\r\n\r\n");
						}

						other {
							@client->WriteString("HTTP/1.1 400\r\n\r\n");
						}
					};
				};
			};
		}
		
		#~
		Get HTTP headers
		@return HTTP headers
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			headers := Map->New()<String, String>;
			
			header := @client->ReadLine();
			while(header <> Nil & header->Size() > 0) {
				if(@is_debug) {				
					"header: {$header}"->PrintLine();
				};
                
				header_parts := header->Split(": ");
				if(header_parts->Size() = 2) {
					headers->Insert(header_parts[0]->ToLower(), header_parts[1]);
				};

				header := @client->ReadLine();
			};
			
			return headers;
		}

		#~
		Callback for GET requests
		@param request HTTP request
		@param response HTTP response
		@return true to continue processing, false otherwise
		~#
		method : virtual : ProcessGet(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool;

		#~
		Callback for POST requests
		@param request HTTP request
		@param response HTTP response
		@return true to continue processing, false otherwise
		~#
		method : virtual : ProcessPost(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool;
	}

	#~
	Request handler for HTTP GET and POST requests
	~#
	class HttpRequestHandler from System.Concurrency.Thread {
		@client : TCPSocket;
		@server_config : WebServerConfig;
		@is_debug : Bool;

		New() {
			Parent();
		}

		method : public : SetConfig(server_config : WebServerConfig, is_debug : Bool) ~ Nil {
			@server_config := server_config;
			@is_debug := is_debug;
		}

		method : public : Run(param : Base) ~ Nil {
			@client := param->As(TCPSocket);

			if(@client <> Nil & @client->IsOpen()) {
				# get request
				request := @client->ReadLine();
				if(@is_debug) {
					request_address := @client->GetAddress();
					"===\nRequest: '{$request}' from '{$request_address}'\n==="->PrintLine();
				};

				# parse request
				request_verb : String; request_path : String;
				if(request->Size() > 0) {
					request_parts := request->Split(" ");
					if(request_parts->Size() = 3) {
						request_verb := request_parts[0];
						request_path := request_parts[1];
					};
				};

				# get request headers
				request_headers := GetHeaders();

				# verify request
				if(request_verb <> Nil & request_path <> Nil & <>request_path->IsEmpty()) {
					# GET and HEAD request
					if(request_verb->Equals("GET") | request_verb->Equals("HEAD")) {
						# retrieve content
						if(request_path = Nil | request_path->Equals("/") | request_path->Has("..")) {
							request_path := "/index.html";
						};

						# write response
						http_request := Request->New(request_path, request_headers);
						http_response := Response->New(@server_config, http_request->GetPath());
						
						if(ProcessGet(http_request, http_response) & @server_config <> Nil & @server_config->IsHandlingFiles()) {
							@server_config->ProcessGet(http_request, http_response);
						};
						ProcessResponse(http_response, request_verb->Equals("HEAD"));
					}
					# POST request
					else if(request_verb->Equals("POST")) {
						content_length_str := request_headers->Find("content-length");
						if(content_length_str <> Nil) {
							content_length := content_length_str->ToInt();
							if(content_length > 0) {
								buffer := WebCommon->ReadPost(content_length, @client);
								
								# retrieve content
								if(request_path = Nil | request_path->Equals("/") | request_path->Has("..")) {
									request_path := "/index.html";
								};

								# write response
								http_request := Request->New(request_path, request_headers, buffer);
								http_response := Response->New(@server_config, http_request->GetPath());
								
								if(ProcessPost(http_request, http_response) & @server_config <> Nil & @server_config->IsHandlingFiles()) {
									@server_config->ProcessPost(http_request, http_response);
								};
								ProcessResponse(http_response);
							};
						};
					};
				};
				
				@client->Close();
			};
		}

		method : ProcessResponse(response : Response, is_head : Bool := false) ~ Nil {
			if(response <> Nil) {
				response_headers := response->GetHeaders();
				if(response->GetCode() = 200) {
					response_header := "";
					key_values := response_headers->GetKeyValues()<Pair<String, String>>;
					each(i : key_values) {
						key_value := key_values->Get(i);
						key := key_value->GetFirst();
						value := key_value->GetSecond();
						response_header += "{$key}: {$value}\r\n";
					};

					content := response->GetContent();
					if(content <> Nil) {
						content_size := content->Size();
						response_header += "Content-Length: {$content_size}\r\nAccept-Ranges: bytes\r\nConnection: close\r\n";

						cookies := response->GetCookies()<Cookie>;
						each(i : cookies) {
							cookie := cookies->Get(i);
							response_header += "Set-Cookie: ";
							response_header += cookie->ToString();
							response_header += "\r\n";
						};

						@client->WriteString("HTTP/1.1 200 OK\r\n{$response_header}\r\n");
						if(<>is_head) {
							@client->WriteBuffer(content);
						};
					}
					else {
						@client->WriteString("HTTP/1.1 200\r\n\r\n");
					};
				}
				else {
					select(response->GetCode()) {
						label 202 {
							@client->WriteString("HTTP/1.1 202 Accepted\r\n\r\n");
						}

						label 302 {
							reason := response->GetReason();
							if(reason <> Nil) {
								@client->WriteString("HTTP/1.1 302 Found\r\nLocation: {$reason}\r\nConnection: close\r\n\r\n");
							}
							else {
								@client->WriteString("HTTP/1.1 400\r\n\r\n");
							};
						}

						label 404 {
							@client->WriteString("HTTP/1.1 404 Not Found\r\n\r\n");
						}

						label 410 {
							@client->WriteString("HTTP/1.1 410 Gone\r\n\r\n");
						}

						other {
							@client->WriteString("HTTP/1.1 400\r\n\r\n");
						}
					};
				};
			};
		}
		
		#~
		Get HTTP headers
		@return HTTP headers
		~#
		method : public : GetHeaders() ~ Map<String, String> {
			headers := Map->New()<String, String>;
			
			header := @client->ReadLine();
			while(header <> Nil & header->Size() > 0) {
				if(@is_debug) {				
					"header: {$header}"->PrintLine();
				};

				header_parts := header->Split(": ");
				if(header_parts->Size() = 2) {
					headers->Insert(header_parts[0]->ToLower(), header_parts[1]);
				};

				header := @client->ReadLine();
			};
			
			return headers;
		}

		#~
		Callback for GET requests
		@param request HTTP request
		@param response HTTP response
		@return true to continue processing, false otherwise
		~#
		method : virtual : ProcessGet(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool;

		#~
		Callback for POST requests
		@param request HTTP request
		@param response HTTP response
		@return true to continue processing, false otherwise
		~#
		method : virtual : ProcessPost(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool;
	}
}

#~
MCP server support (-lib net_server)
~#
bundle Web.HTTP.Server.MCP {
	#~
	MCP server
	~#
	class McpServer {
		@is_debug : static : Bool;
		@config : static : JsonElement;

		#~
		Returns rather the server is in debug mode
		@return true is in debug mode, false otherwise
		~#
		function : IsDebug() ~ Bool {
			return @is_debug;
		}

		function : virtual : Foo() ~ Nil;
		
		#~
		Initializes the MPC server
		@param config JSON configuration file
		~#
		function : Serve(config : JsonElement, handler : McpRequestHandler) ~ Nil {
			if(@config <> Nil) {
				">>> Error MCP server already initialized <<<"->ErrorLine();
				return;
			};

			@config := config;
			@is_debug := config->Get("debug")->GetBool();
			
			http_port := config->Get("http_port")->GetInt();
			if(http_port <= 0 | <>McpRequestHandler->Initialize(config)) {
				">>> Unable to initialize MCP server <<<"->ErrorLine();
				return;
			};

			WebServer->Serve(handler->GetClass(), http_port, @is_debug);
		}
	}

	class McpRequestHandler from HttpRequestHandler {
		@config : static : JsonElement;

		@session_cache : static : Hash<String, Hash<String, String>>;
		@session_cache_timer : static : CacheTimer;
		@session_cache_mutex : static : System.Concurrency.ThreadMutex;

		New() {
			Parent();
		}

		function : Initialize(config : JsonElement) ~ Bool {
			@config := config;

			session_timeout := config->Get("http_session_timeout")->GetInt();
			if(session_timeout <= 0) {
				return false;
			};

			@session_cache_mutex := System.Concurrency.ThreadMutex->New("cache_mutex");
	 		@session_cache := Hash->New()<String, Hash<String, String>>;
			@session_cache_timer := CacheTimer->New(session_timeout * 1000); # in seconds
	 		@session_cache_timer->Start(Nil);

	 		return true;
		}

		function : CheckCache() ~ Nil {
			critical(@session_cache_mutex) {
				# get key/values
				expired_session_keys := Vector->New()<String>;

				session_key_values := @session_cache->GetKeyValues()<Pair<String, Hash<String, String>>>;
				each(session_key_value in session_key_values) {
					session := session_key_value->GetSecond();
					timestamp_str := session->Find("_timestamp_");
					if(timestamp_str <> Nil) {
						time_diff := System.Time.Date->New()->GetUnixTime() - timestamp_str->ToInt();
						session_key := session_key_value->GetFirst();
						if(McpServer->IsDebug()) {
							"session: key={$session_key}, diff={$time_diff}"->PrintLine();
						};

						if(time_diff >= 60) {
							expired_session_keys->AddBack(session_key);
						}
					};				
				};

				each(session_key in expired_session_keys) {
					@session_cache->Remove(session_key);
					if(McpServer->IsDebug()) {
						"*** removing: key={$session_key} ***"->PrintLine();
					};
				};

				if(McpServer->IsDebug()) {
					"---"->PrintLine();
				};
			}
		}

		method : virtual : ListTemplates() ~ Vector<ResourceTemplate>;

		method : virtual : ListResources() ~ Vector<ResourceItem>;
		method : virtual : GetResource(uri : Url) ~ Vector<ResourceContent>;
		
		method : virtual : ListTools() ~ Vector<ToolItem>;
		method : virtual : CallTool(name : String, arguments : JsonElement) ~ Vector<ToolContent>;
		
		# TODO: prompts
		
		method : ProcessGet(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool {
			session : Hash<String, String>;
			session_id := request->GetHeader("mcp-session-id");
			if(session_id <> Nil) {
				critical(@session_cache_mutex) {
					session := @session_cache->Find(session_id);
				};
			};

			if(McpServer->IsDebug()) {
				if(session_id = Nil) {
					session_id := "<nil>";
				};

				has_session := session <> Nil;
				"\n### GET: session_id='{$session_id}', has_session={$has_session} ####"->PrintLine();
			};
			
			response->SetCodeTypeContent(200, "text/event-stream", ": keepalive\n\n");
			return false;
		}

		method : ProcessPost(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool {
			session : Hash<String, String>;
			session_id := request->GetHeader("mcp-session-id");
			if(session_id <> Nil) {
				critical(@session_cache_mutex) {
					session := @session_cache->Find(session_id);
				};
			};

			if(McpServer->IsDebug()) {
				if(session_id = Nil) {
					"\n### POST ####"->PrintLine();
				}
				else {
					has_session := session <> Nil;
					"\n### POST: session_id='{$session_id}', has_session={$has_session} ####"->PrintLine();
				};
			};

			# expired session
			if(session_id <> Nil & session = Nil) {
				response->SetCode(404);
				return false;
			};

			if(request->HasContent()) {
				content := request->GetContent();

				if(McpServer->IsDebug()) {
					ShowPayload(content);
				};

				parser := JsonParser->New(content);
				if(parser->Parse()) {
					root_json := parser->GetRoot();

					# process method
					method_name := root_json->Get("method")->GetValue();
					if(method_name <> Nil) {
						if(McpServer->IsDebug()) {
							"[Post: method_name='{$method_name}']"->PrintLine();
						};

						# execute method
						select(method_name) {
							# ping
							label "ping": {
								id := root_json->Get("id")->GetInt();
								WriteResponse(Nil, id, response, 200);
								return false;
							}

							# initialize
							label "initialize": {
								name := @config->Get("name")->GetValue();
								instructions := @config->Get("instructions")->GetValue();
								version := @config->Get("version")->GetValue();

								# TODO: better error checking
								id := root_json->Get("id")->GetInt();

								result := JsonElement->New(JsonElement->JsonType->OBJECT);
								result->Insert("protocolVersion", "2025-06-18");
								result->Insert("instructions", instructions);

								# add capabilities
								capabilities_json := JsonElement->New(JsonElement->JsonType->OBJECT);

								tools_json :=  JsonElement->New(JsonElement->JsonType->OBJECT);
								tools_json->Insert("listChanged", true);
								capabilities_json->Insert("tools", tools_json);
								
								resources_json :=  JsonElement->New(JsonElement->JsonType->OBJECT);
								resources_json->Insert("listChanged", true);
								capabilities_json->Insert("resources", resources_json);

								prompts_json :=  JsonElement->New(JsonElement->JsonType->OBJECT);
								prompts_json->Insert("listChanged", true);
								capabilities_json->Insert("resources", prompts_json);

								result->Insert("capabilities", capabilities_json);

								# server information
								server_json :=  JsonElement->New(JsonElement->JsonType->OBJECT);
								server_json->Insert("name", name);
								server_json->Insert("version", version);

								result->Insert("serverInfo", server_json);

								session_id := Runtime->GetUuid();
								
								session := Hash->New()<String, String>;
								session->Insert("_timestamp_", System.Time.Date->New()->GetUnixTime()->ToString())
								
								critical(@session_cache_mutex) {
									@session_cache->Insert(session_id, session);
								};

								response->SetHeader("mcp-session-id", session_id);
								WriteResponse(result, id, response, 200);

								return false;
							}
							
							# notifications/initialized
							label "notifications/initialized": {
								if(McpServer->IsDebug()) {
									"### notifications/initialized ###"->PrintLine();
								};

								response->SetCode(202);
								return false;
							}
							
							# logging/setLevel
							label "logging/setLevel": {
								id := root_json->Get("id")->GetInt();
								WriteResponse(Nil, id, response, 200);
								return false;
							}

							# resources/templates/list
							label "resources/templates/list": {
								id := root_json->Get("id")->GetInt();

								templates_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);

								templates := ListTemplates();
								each(template in templates) {
									templates_array_json->Add(template->ToJson());
								};

								result := JsonElement->New(JsonElement->JsonType->OBJECT);
								result->Insert("resourceTemplates", templates_array_json);

								ListResources();
								
								WriteResponse(result, id, response, 200);
								return false;
							}
							
							# resources/list
							label "resources/list": {
								id := root_json->Get("id")->GetInt();

								resources_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);

								resources := ListResources();
								each(resource in resources) {
									resources_array_json->Add(resource->ToJson());
								};

								result := JsonElement->New(JsonElement->JsonType->OBJECT);
								result->Insert("resources", resources_array_json);
								
								WriteResponse(result, id, response, 200);
								return false;
							}
							
							# resources/read
							label "resources/read": {
								id := root_json->Get("id")->GetInt();
								uri_str := root_json->Get("params")->Get("uri")->GetValue();

								resources_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);

								resource_details := GetResource(Url->New(uri_str));
								each(resource_detail in resource_details) {
									resources_array_json->Add(resource_detail->ToJson());
								};

								result := JsonElement->New(JsonElement->JsonType->OBJECT);
								result->Insert("contents", resources_array_json);
								
								WriteResponse(result, id, response, 200);
								return false;
							}
							
							# tools/list
							label "tools/list": {
								id := root_json->Get("id")->GetInt();

								tools := ListTools();

								tools_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
								each(tool in tools) {
									tools_array_json->Add(tool->ToJson());
								};

								result := JsonElement->New(JsonElement->JsonType->OBJECT);
								result->Insert("tools", tools_array_json);
								
								WriteResponse(result, id, response, 200);
								return false;
							}

							# tools/call
							label "tools/call": {
								call_name : String; text : String;
								call_params_json := root_json->Get("params");								
								if(call_params_json <> Nil) {
									name_json := call_params_json->Get("name");
									if(name_json <> Nil) {
										call_name := name_json->GetValue();
									};

									call_params_json := call_params_json->Get("arguments");
									if(call_params_json <> Nil & call_name <> Nil) {
										id := root_json->Get("id")->GetInt();

										contents := CallTool(call_name, call_params_json);

										content_array_json := JsonElement->New(JsonElement->JsonType->ARRAY);
										each(content in contents) {
											content_array_json->Add(content->ToJson());
										};

										result := JsonElement->New(JsonElement->JsonType->OBJECT);
										result->Insert("content", content_array_json);
										
										WriteResponse(result, id, response, 200);
										return false;
									};
								};
							}

							# prompts/list
							label "prompts/list": {
								id := root_json->Get("id")->GetInt();
								payload := "{
									\"jsonrpc\": \"2.0\",  
									\"id\": {$id},  \"result\": {    
										\"prompts\": [ 
											{        
												\"name\": \"greet\",
												\"title\": \"Greet a User\",
												\"description\": \"Compose a friendly greeting.\",
												\"arguments\": [ { 
													\"name\": \"name\", \"description\": \"User's name\", \"required\": true }
												]
											},
											{
												\"name\": \"explain_topic\",
												\"title\": \"Explain a Topic\",
												\"description\": \"Short explanation suitable for a beginner.\",
												\"arguments\": [ {
													\"name\": \"topic\", \"description\": \"Subject to explain\", \"required\": true }
												]
											}
										]
									}
								}";

								if(McpServer->IsDebug()) {
									ShowPayload(payload);
								};

								response->SetCodeTypeContent(200, "application/json", payload);
								return false;
							}

							# prompts/get
							label "prompts/get": {
								call_name : String; 
								
								call_params_json := root_json->Get("params");								
								if(call_params_json <> Nil) {
									name_json := call_params_json->Get("name");
									if(name_json <> Nil) {
										call_name := name_json->GetValue();
									};

									call_params_json := call_params_json->Get("arguments");
									if(call_params_json <> Nil & call_name <> Nil) {
										id := root_json->Get("id")->GetInt();

										# greet prompt
										if(call_name->Equals("greet")) {
											name := call_params_json->Get("name")->GetValue();

											payload := "{
												\"jsonrpc\": 
												\"2.0\",  
												\"id\": {$id},  
												\"result\": {  
													\"description\": \"Greeting prompt\",  
													\"messages\": [
														{
															\"role\": \"user\",
															\"content\": { 
																\"type\": \"text\", 
																\"text\": \"{$name}\" 
															}
														}
													]    
												}
											}";

											if(McpServer->IsDebug()) {
												ShowPayload(payload);
											};

											response->SetCodeTypeContent(200, "application/json", payload);
											return false;
										}
										# greet prompt
										else if(call_name->Equals("explain_topic")) {
											explain_topic := call_params_json->Get("topic")->GetValue();
											
											payload := "{
												\"jsonrpc\": 
												\"2.0\",  
												\"id\": {$id},  
												\"result\": {  
													\"description\": \"Explain prompt\",  
													\"messages\": [
														{
															\"role\": \"user\",
															\"content\": { 
																\"type\": \"text\", 
																\"text\": \"{$explain_topic}\" 
															}
														}
													]    
												}
											}";

											if(McpServer->IsDebug()) {
												ShowPayload(payload);
											};

											response->SetCodeTypeContent(200, "application/json", payload);
											return false;
										}
									};
								};
							}
						};
					};
				};
			};

			response->SetCode(204);
			if(McpServer->IsDebug()) {
				">>>  Unknown Message <<<"->ErrorLine();
			};
			return false;
		}

		method : WriteResponse(message : JsonElement, id : Int, response : Web.HTTP.Server.Response, code : Int) ~ Nil {
			packet := JsonElement->New(JsonElement->JsonType->OBJECT);
			packet->Insert("jsonrpc", "2.0");
			packet->Insert("id", id);

			if(message <> Nil) {
				packet->Insert("result", message);
			}
			else {
				packet->Insert("result", JsonElement->New(JsonElement->JsonType->OBJECT));
			};

			if(McpServer->IsDebug()) {
				packet->ToFormattedString()->PrintLine();
			};

			response->SetCodeTypeContent(code, "application/json", packet->ToString());
		}

		function : ShowPayload(payload : String) ~ Nil {
			payload->ReplaceAll("\t", "  ")->PrintLine();
		}
	} 

	class : private : CacheTimer from System.Time.Alarm {
		New(time : Int) {
			Parent(time, true);
		}

		method : public : Ring(param:System.Base) ~ Nil {
			McpRequestHandler->CheckCache();
		}
	}

	#~
	TODO
	~#
	class ResourceItem {
		@uri : Url;
		@name : String;
		@description : String;
		@mime_type : String;
		@title : String;
		@size : Int;

		New(uri : Url, name : String, title : String, description : String, mime_type : String, size : Int) {
			@uri := uri;
			@name := name;
			@title := title;
			@description := description;
			@mime_type := mime_type;
			@size := size;
		}

		New(uri : Url, name : String, title : String, description : String, mime_type : String) {
			@uri := uri;
			@name := name;
			@title := title;
			@description := description;
			@mime_type := mime_type;
		}

		New(uri : Url, name : String, title : String, mime_type : String) {
			@uri := uri;
			@name := name;
			@title := title;
			@mime_type := mime_type;
		}

		New(uri : Url, name : String, mime_type : String) {
			@uri := uri;
			@name := name;
			@mime_type := mime_type;
		}

		New(uri : Url, name : String) {
			@uri := uri;
			@name := name;
		}

		method : public : GetUri() ~ Url {
			return @uri;
		}

		method : public : GetTitle() ~ String {
			return @title;
		}

		method : public : GetSize() ~ Int {
			return @size;
		}

		method : public : GetName() ~ String {
			return @name;
		}
		
		method : public : GetDescription() ~ String {
			return @description;
		}
		
		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("uri", @uri->GetUrl());
			buffer_json->Insert("name", @name);

			if(@description <> Nil) {
				buffer_json->Insert("description", @description);
			};

			if(@title <> Nil) {
				buffer_json->Insert("title", @title);
			};

			if(@mime_type <> Nil) {
				buffer_json->Insert("mimeType", @mime_type);
			};

			if(@size > 0) {
				buffer_json->Insert("size", @size);
			};

			return buffer_json;
		}
	}

	#~
	TODO
	~#
	class ResourceContent from ResourceItem {
		@text : String;
		@is_blob : Bool;
		
		New(uri : Url, name : String, title : String, description : String, mime_type : String, text : String, is_blob : Bool := false) {
			Parent(uri, name, title, description, mime_type);

			@text := text;
			@is_blob := is_blob;
		}

		New(uri : Url, name : String, title : String, mime_type : String, text : String, is_blob : Bool := false) {
			Parent(uri, name, title, mime_type);

			@text := text;
			@is_blob := is_blob;
		}

		New(uri : Url, name : String, mime_type : String, text : String, is_blob : Bool := false) {
			Parent(uri, name, mime_type);

			@text := text;
			@is_blob := is_blob;
		}

		method : public : IsBlob() ~ Bool {
			return @is_blob;
		}

		method : public : GetText() ~ String {
			return @text;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("uri", @uri->GetUrl());
			buffer_json->Insert("name", @name);

			if(@description <> Nil) {
				buffer_json->Insert("description", @description);
			};

			if(@title <> Nil) {
				buffer_json->Insert("title", @title);
			};

			if(@size > 0) {
				buffer_json->Insert("size", @size);
			};

			if(@is_blob) {
				buffer_json->Insert("blob", @text);
			}
			else {
				buffer_json->Insert("text", @text);
			};

			return buffer_json;
		}
	}

	#~
	TODO
	~#
	class ResourceTemplate from ResourceItem {
		New(uri : Url, name : String, title : String, description : String, mime_type : String) {
			Parent(uri, name, title, description, mime_type);
			@title := title;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("uriTemplate", @uri->GetUrl());
			buffer_json->Insert("name", @name);
			buffer_json->Insert("title", @title);
			buffer_json->Insert("description", @description);
			buffer_json->Insert("mimeType", @mime_type);

			return buffer_json;
		}
	}

	#~
	TODO
	~#
	class ToolItem {
		@name : String;
		@title : String;
		@description : String;
		@input_schema : FunctionType;
		@output_schema : FunctionType;

		New(name : String, title : String, description : String, input_schema : FunctionType, output_schema : FunctionType) {
			@name := name;
			@title := title;
			@description := description;

			@input_schema := input_schema;
			@output_schema := output_schema;
		}

		New(name : String, description : String, input_schema : FunctionType, output_schema : FunctionType) {
			@name := name;
			@description := description;

			@input_schema := input_schema;
			@output_schema := output_schema;
		}

		New(name : String, description : String, input_schema : FunctionType) {
			@name := name;
			@description := description;

			@input_schema := input_schema;
		}

		New(name : String, input_schema : FunctionType, output_schema : FunctionType) {
			@name := name;
			
			@input_schema := input_schema;
			@output_schema := output_schema;
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GeTitle() ~ String {
			return @title;
		}
		
		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : GetInputSchema() ~ FunctionType {
			return @input_schema;
		}

		method : public : GetOutputSchema() ~ FunctionType {
			return @output_schema;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("name", @name);
			
			if(@title <> Nil) {
				buffer_json->Insert("title", @title);
			};

			if(@description <> Nil) {
				buffer_json->Insert("description", @description);
			};

			input_schema_json := @input_schema->ToJson();
			input_schema_json->Insert("type", "object")
			buffer_json->Insert("inputSchema", input_schema_json);

			if(@output_schema <> Nil) {
				output_schema_json := @output_schema->ToJson();
				output_schema_json->Insert("type", "object")
				buffer_json->Insert("outputSchema", output_schema_json);
			};

			return buffer_json;
		}
	}

	#~
	TODO
	~#
	class ToolContent {
		#~
		TODO
		~#
		enum Type {
			TEXT, 
			IMAGE, 
			AUDIO, 
			LINK, 
			EMBEDDED
		}

		@type : String;
		@uri : Url;
		@title : String;
		@description : String;
		@mime_type : String;

		@text : String;
		@is_blob : Bool;

		New(type : String, text : String, is_blob : Bool := false) {
			@type := type;
			@text := text;
			@is_blob := is_blob;
		}

		New(type : String, mime_type : String, text : String, is_blob : Bool := false) {
			@type := type;
			@mime_type := mime_type;
			@text := text;
			@is_blob := is_blob;
		}

		New(type : String, mime_type : String, description : String, text : String, is_blob : Bool := false) {
			@type := type;
			@mime_type := mime_type;
			@description := description;
			@text := text;
			@is_blob := is_blob;
		}

		New(type : String, mime_type : String, title : String, description : String, text : String, is_blob : Bool := false) {
			@type := type;
			@mime_type := mime_type;
			@title := title;
			@description := description;
			@text := text;
			@is_blob := is_blob;
		}

		method : public : GetType() ~ String {
			return @type;
		}

		method : public : GetTitle() ~ String {
			return @title;
		}
		
		method : public : GetDescription() ~ String {
			return @description;
		}
		
		method : public : GetMimeType() ~ String {
			return @mime_type;
		}

		method : public : IsBlob() ~ Bool {
			return @is_blob;
		}

		method : public : GetText() ~ String {
			return @text;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("type", @type);
			
			if(@title <> Nil) {
				buffer_json->Insert("title", @title);
			};

			if(@description <> Nil) {
				buffer_json->Insert("description", @description);
			};

			if(@mime_type <> Nil) {
				buffer_json->Insert("mimeType", @mime_type);
			};

			if(@is_blob) {
				buffer_json->Insert("data", @text);
			}
			else {
				buffer_json->Insert("text", @text);
			};

			return buffer_json;
		}
	}

	#~
	TODO
	~#
	class PromptItem {
		@name : String;
		@uri : Url;
		@title : String;
		@description : String;
		@arguments : Vector<PromptArgument>;

		New(name : String, uri : Url, title : String, description : String) {
			@name := name;
			@uri := uri;
			@title := title;
			@description := description;
		}

		New(name : String, description : String) {
			@name := name;
			@description := description;
		}

		New(name : String) {
			@name := name;			
		}

		method : public : GetName() ~ String {
			return @name;
		}

		method : public : GeTitle() ~ String {
			return @title;
		}

		method : public : GetUri() ~ Url {
			return @uri;
		}
		
		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : GetArguments() ~ Vector<PromptArgument> {
			return @arguments;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("name", @name);
			
			if(@title <> Nil) {
				buffer_json->Insert("title", @title);
			};

			if(@description <> Nil) {
				buffer_json->Insert("description", @description);
			};

			if(@uri <> Nil) {
				buffer_json->Insert("uriTemplate", @uri->GetUrl());
			};

			return buffer_json;
		}
	}

	#~
	TODO: restrict types?
	~#
	class PromptArgument {
		@type : String;
		@description : String;

		New(type : String, description : String) {
			@type := type;
			@description := description;
		}

		method : public : GetType() ~ String {
			return @type;
		}

		method : public : GetDescription() ~ String {
			return @description;
		}

		method : public : ToJson() ~ JsonElement {
			buffer_json := JsonElement->New(JsonElement->JsonType->OBJECT);

			buffer_json->Insert("type", @type);
			
			if(@description <> Nil) {
				buffer_json->Insert("description", @description);
			};

			return buffer_json;
		}
	}
}

#~
OAuth client (-lib net_server)
~#
bundle System.IO.Net.OAuth {
	#~
	OAuth client
	
```
scopes := ["https://www.googleapis.com/auth/cloud-platform", 
  "https://www.googleapis.com/auth/generative-language.retriever"];
client := System.IO.Net.OAuth.OAuthClient->New("client_secret.json", scopes);
each(i : 3) {
  client->GetToken()->GetAccessToken()->PrintLine();
};
```
	~#
	class OAuthClient {
		@config_json : OAuthConfig;

		#~
		Constructor
		@param filename OAuth configuration credentials in Google <a href='https://googleapis.github.io/google-api-python-client/docs/client-secrets.html'>installed</a> JSON format
		@param scopes list of OAuth scopes
		~#
		New(filename : String, scopes : String[]) {
			@config_json := OAuthConfig->Load(filename, scopes);
		}

		#~
		Get an OAuth token
		@return OAuth token, Nil if error
		~#
		method : public : GetToken() ~ OAuthToken {
			access_token : String; 
			refresh_token : String;

			token := OAuthHandler->Get();
			if(token <> Nil) {
				access_token := token->GetAccessToken();
				refresh_token := token->GetRefreshToken();
			};

			if(@config_json <> Nil & access_token = Nil) {
				client_id := @config_json->GetClientId();
				state := @config_json->GetState();
				scope := @config_json->GetScope();
				redirect_uri := @config_json->GetRedirectUri();

				auth_uri_str := @config_json->GetAuthUri();
				login_url_str := "{$auth_uri_str}?client_id={$client_id}&response_type=code&redirect_uri={$redirect_uri}&state={$state}&scope={$scope}";

				"Please login: {$login_url_str}"->PrintLine();

				OAuthHandler->Initialize(@config_json);				
				WebServer->Serve(OAuthHandler->New()->GetClass(), @config_json->GetRedirectPort(), false);
			}
			else if(@config_json <> Nil & refresh_token <> Nil) {
				client_id := @config_json->GetClientId();
				client_secret := @config_json->GetClientSecret();
				redirect_uri := @config_json->GetRedirectUri();
				scope := @config_json->GetScope();

				data := "&client_secret={$client_secret}&client_id={$client_id}&redirect_uri={$redirect_uri}&refresh_token={$refresh_token}&scope={$scope}&grant_type=refresh_token&"->ToByteArray();
				# data->ToString()->PrintLine();

				token_uri_str := @config_json->GetTokenUri();
				headers := Collection.Map->New()<String, String>;
				headers->Insert("Content-Type", "application/x-www-form-urlencoded");
				post_response := HttpsClient->QuickPost(Url->New(token_uri_str), data, "application/x-www-form-urlencoded", headers);

				if(post_response <> Nil) {
					# post_response->GetContent()->ToString()->PrintLine();			
					response_json := JsonParser->TextToElement(post_response->GetContent()->ToString());
						
					if(response_json->Has("access_token")) {
						access_token := response_json->Get("access_token")->GetString();
						expires_in := response_json->Get("expires_in")->GetInt();
						scope := response_json->Get("scope")->GetString();
						OAuthHandler->Set(access_token, expires_in, scope);
					} 
					else {
						return Nil;
					};
				};	
			}
			else {
				return Nil;
			};

			token := OAuthHandler->Get();
			access_token := token->GetAccessToken(); 
			expires_in := token->GetExpiresIn(); 
			scope := token->GetScope();
			refresh_token := token->GetRefreshToken();
			
			if(expires_in > 0 & access_token <> Nil & scope <> Nil & refresh_token <> Nil) {
				return OAuthToken->New(access_token, refresh_token, expires_in, scope);
			};

			return Nil;
		}
	}

	class : private : OAuthHandler from HttpRequestHandler {
		@client_id : static : String;
		@client_secret: static : String;
		@redirect_uri : static : String;
		@state : static : String;
		@token_uri_str : static : String;
		
		@token : static : OAuthToken;

		function : Initialize(config : OAuthConfig) ~ Nil {
			@client_id := config->GetClientId();
			@client_secret := config->GetClientSecret();
			@redirect_uri := config->GetRedirectUri();
			@state := config->GetState();
			@token_uri_str := config->GetTokenUri();
		}

		New() {
			Parent();
		}

		function : Get() ~ OAuthToken {
			return @token;
		}

		function : Set(access_token : String, expires_in : Int, scope : String) ~ Nil {
			if(@token <> Nil) {
				@token->Set(access_token, expires_in, scope);
			};
		}

		method : ProcessGet(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool {
			if(<>request->HasParam("error") & request->GetParam("state")->Equals(@state)) {
				code_id := request->GetParam("code");
				data := "code={$code_id}&client_id={$@client_id}&client_secret={$@client_secret}&redirect_uri={$@redirect_uri}&grant_type=authorization_code"->ToByteArray();

				headers := Collection.Map->New()<String, String>;
				headers->Insert("Content-Type", "application/x-www-form-urlencoded");
				post_response := HttpsClient->QuickPost(Url->New(@token_uri_str), data, "application/x-www-form-urlencoded", headers);

				if(post_response <> Nil) {
					# post_response->GetContent()->ToString()->PrintLine();			
					response_json := JsonParser->TextToElement(post_response->GetContent()->ToString());
						
					if(response_json->Has("access_token")) {
						access_token := response_json->Get("access_token")->GetString();
						refresh_token := response_json->Get("refresh_token")->GetString();
						expires_in := response_json->Get("expires_in")->GetInt();
						scope := response_json->Get("scope")->GetString();

						@token := OAuthToken->New(access_token, refresh_token, expires_in, scope);

						response->SetCodeContent(200, "<html><center>You are logged in...</center></html>");
						WebServer->Stop();
						return false;
					};
				}
			};	

			@token := Nil;
			return false;
		}

		method : ProcessPost(request : Web.HTTP.Server.Request, response : Web.HTTP.Server.Response) ~ Bool {
			return false;
		}
	}

	class : private : OAuthConfig {
		@install_json : JsonElement;

		@scope : String;
		@redirect_uri : String;
		@redirect_port : Int;

		@client_id : String;
		@client_secret : String;
		@state : String;
		@auth_uri : String;
		@token_uri : String;

		New : private(install_json : JsonElement, scopes : String[]) {
			@install_json := install_json;

			@scope := "";
			each(scope in scopes) {
				@scope->Append(scope);
				@scope->Append(' ');
			};
			@scope := Url->Encode(@scope->Trim());

			# get redirects
			redirect_uris_json := @install_json->Get("redirect_uris");
			if(redirect_uris_json->Size() = 1) {
				@redirect_uri := Url->Encode(redirect_uris_json->Get(0)->GetString());
			};

			# decode and parse
			redirect_uri_str := Url->Decode(@redirect_uri);
			@redirect_port := 80;
			if(redirect_uri_str->Count(':') > 1) {
				redirect_uri_str_index := redirect_uri_str->FindLast(':') + 1;
				@redirect_port := redirect_uri_str->SubString(redirect_uri_str_index, redirect_uri_str->Size() - redirect_uri_str_index)->ToInt();
			};
		}

		function : Load(filename : String, scopes : String[]) ~ OAuthConfig {
			buffer := System.IO.Filesystem.FileReader->ReadFile(filename);
			if(buffer <> Nil) {
				config_json := JsonParser->TextToElement(buffer);
				if(config_json <> Nil) {
					return OAuthConfig->New(config_json->Get("installed"), scopes);
				};
			};

			return Nil;
		}

		method : public : GetRedirectUri() ~ String {
			return @redirect_uri;
		}

		method : public : GetRedirectPort() ~ Int {
			return @redirect_port;
		}

		method : public : GetScope() ~ String {
			return @scope;
		}

		method : Get(name : String) ~ String {
			if(@install_json <> Nil) {
				return @install_json->Get(name)->GetString();
			};

			return Nil;
		}

		method : public : GetClientId() ~ String {
			if(@client_id = Nil) {
				@client_id := Get("client_id");
			};

			return @client_id;
		}

		method : public : GetClientSecret() ~ String {
			if(@client_secret = Nil) {
				@client_secret := Get("client_secret");
			};

			return @client_secret;
		}

		method : public : GetAuthUri() ~ String {
			if(@auth_uri = Nil) {
				@auth_uri := Get("auth_uri");
			};

			return @auth_uri;
		}

		method : public : GetTokenUri() ~ String {
			if(@token_uri = Nil) {
				@token_uri := Get("token_uri");
			};

			return @token_uri;
		}

		method : public : GetState() ~ String {
			if(@state = Nil) {
				@state := GenerateState();
			};

			return @state;
		}

		method : GenerateState() ~ String {
			values := [ 
				'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
				'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
				'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 
				'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 
				'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 
				'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 
				'w', 'x', 'y', 'z', '0', '1', '2', '3', 
				'4', '5', '6', '7', '8', '9'
			];

			buffer := "";

			each(i : 8) {
				index := Int->Random(0, values->Size() - 1);
				buffer->Append(values[index]);
			};

			return buffer;
		}
	}

	#~
	OAuth token
	~#
	class OAuthToken {
		@access_token : String;
		@refresh_token : String;
		@scope : String;
		@expires_in : Int;
		@session : String;

		New(access_token : String, refresh_token : String, expires_in : Int, scope : String) {
			@access_token := access_token;
			@refresh_token := refresh_token; 
			@expires_in := expires_in;
			@scope := scope;

			@session := FormatNewToken(@access_token, @expires_in);
		}

		function : FormatNewToken(access_token : String, expires_in : Int) ~ String {
			date := System.Time.Date->New();
			date->AddSeconds(expires_in);
			date_str := date->GetUnixTime()->ToString();

			return "{$date_str}\r\n{$access_token}";
		}
		
		function : ReadTokenFormat(secret_str : String) ~ String {
			if(secret_str <> Nil) {
				client_secret_parts := secret_str->Split("\r\n");
				if(client_secret_parts->Size() = 2){
					date_str := client_secret_parts[0];
					create_time := System.Time.Date->New(date_str->ToInt());
					create_time->AddMinutes(-2);

					if(create_time->Compare(System.Time.Date->New(true)) > 0) {
						token_str := client_secret_parts[1];
						return token_str;
					};
				};
			};

			return Nil;
		}

		#~
		Get access token
		@return access token
		~#
		method : public : GetAccessToken() ~ String {
			return @access_token;
		}

		#~
		Get refresh token
		@return refresh token
		~#
		method : public : GetRefreshToken() ~ String {
			if(ReadTokenFormat(@session) <> Nil) {
				return @refresh_token;
			};

			return Nil;
		}

		#~
		Get scope
		@return scope
		~#
		method : public : GetScope() ~ String {
			return @scope;
		}

		#~
		Get expiration time
		@return expiration time
		~#
		method : public : GetExpiresIn() ~ Int {
			return @expires_in;
		}

		method : public : Set(access_token : String, expires_in : Int, scope : String) ~ Nil {
			@access_token := access_token;
			@expires_in := expires_in;
			@scope := scope;
		}

		#~
		Get token as string
		@return token as string
		~#
		method : public : ToString() ~ String {
			buffer := "";

			buffer->Append("Token:\n");
			buffer->Append("  access_token='{$@access_token}'\n");
			buffer->Append("  refresh_token='{$@refresh_token}'\n");
			buffer->Append("  scope='{$@scope}'\n");
			buffer->Append("  expires_in={$@expires_in}\n");

			return buffer;
		}
	}
}